From 6fc9939bc8bb3b01a91ba5edb0c215764736172a Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelman@morgridge.org>
Date: Wed, 30 Apr 2025 08:30:20 -0500
Subject: [PATCH 08/10] Tweak throttle manager after large-scale testing

- Standardize the username / UID calculation.
- Allow low-concurrency users to immediately proceed without waiting.
- If a user is below their threshold and has existing waiters, immediately
  allow them to run another of their I/O requests.
---
 src/XrdThrottle/XrdThrottleFile.cc    | 11 +----
 src/XrdThrottle/XrdThrottleManager.cc | 67 +++++++++++++++++++++------
 src/XrdThrottle/XrdThrottleManager.hh | 17 +++++--
 3 files changed, 66 insertions(+), 29 deletions(-)

diff --git a/src/XrdThrottle/XrdThrottleFile.cc b/src/XrdThrottle/XrdThrottleFile.cc
index 16a7672b5..1a6931305 100644
--- a/src/XrdThrottle/XrdThrottleFile.cc
+++ b/src/XrdThrottle/XrdThrottleFile.cc
@@ -58,16 +58,7 @@ File::open(const char                *fileName,
            const XrdSecEntity        *client,
            const char                *opaque)
 {
-   // Try various potential "names" associated with the request, from the most
-   // specific to most generic.
-   if (client->eaAPI && client->eaAPI->Get("token.subject", m_user)) {
-       if (client->vorg) m_user = std::string(client->vorg) + ":" + m_user;
-   } else if (client->eaAPI) {
-       std::string user;
-       if (client->eaAPI->Get("request.name", user) && !user.empty()) m_user = user;
-   }
-   if (m_user.empty()) {m_user = client->name ? client->name : "nobody";}
-   m_uid = XrdThrottleManager::GetUid(m_user.c_str());
+   std::tie(m_user, m_uid) = m_throttle.GetUserInfo(client);
    m_throttle.PrepLoadShed(opaque, m_loadshed);
    std::string open_error_message;
    if (!m_throttle.OpenFile(m_user, open_error_message)) {
diff --git a/src/XrdThrottle/XrdThrottleManager.cc b/src/XrdThrottle/XrdThrottleManager.cc
index 2c0884e3c..401992d2c 100644
--- a/src/XrdThrottle/XrdThrottleManager.cc
+++ b/src/XrdThrottle/XrdThrottleManager.cc
@@ -2,6 +2,8 @@
 #include "XrdThrottleManager.hh"
 
 #include "XrdOuc/XrdOucEnv.hh"
+#include "XrdSec/XrdSecEntity.hh"
+#include "XrdSec/XrdSecEntityAttr.hh"
 #include "XrdSys/XrdSysAtomics.hh"
 #include "XrdSys/XrdSysTimer.hh"
 #include "XrdSys/XrdSysPthread.hh"
@@ -81,6 +83,23 @@ XrdThrottleManager::Init()
 
 }
 
+std::tuple<std::string, uint16_t>
+XrdThrottleManager::GetUserInfo(const XrdSecEntity *client) {
+    // Try various potential "names" associated with the request, from the most
+    // specific to most generic.
+    std::string user;
+
+    if (client->eaAPI && client->eaAPI->Get("token.subject", user)) {
+        if (client->vorg) user = std::string(client->vorg) + ":" + user;
+    } else if (client->eaAPI) {
+        std::string request_name;
+        if (client->eaAPI->Get("request.name", request_name) && !request_name.empty()) user = request_name;
+    }
+    if (user.empty()) {user = client->name ? client->name : "nobody";}
+    uint16_t uid = GetUid(user.c_str());
+    return std::make_tuple(user, uid);
+}
+
 /*
  * Take as many shares as possible to fulfill the request; update
  * request with current remaining value, or zero if satisfied.
@@ -359,12 +378,13 @@ XrdThrottleManager::ComputeWaiterOrder()
         auto io_duration_rep = waiter.m_io_time.exchange(std::chrono::steady_clock::duration(0).count());
         std::chrono::steady_clock::duration io_duration = std::chrono::steady_clock::duration(io_duration_rep);
         std::chrono::duration<double> io_duration_secs = io_duration;
-        auto recent_concurrency = io_duration_secs.count() / elapsed_secs.count();
+        auto prev_concurrency = io_duration_secs.count() / elapsed_secs.count();
+        float new_concurrency = waiter.m_concurrency;
 
-        auto new_concurrency = (1 - alpha) * waiter.m_concurrency + alpha * recent_concurrency;
+        new_concurrency = (1 - alpha) * new_concurrency + alpha * prev_concurrency;
         waiter.m_concurrency = new_concurrency;
         if (new_concurrency > 0) {
-            TRACE(DEBUG, "User " << i << " has concurrency of " << waiter.m_concurrency);
+            TRACE(DEBUG, "User " << i << " has concurrency of " << new_concurrency);
         }
         unsigned waiting;
         {
@@ -442,6 +462,7 @@ XrdThrottleManager::ComputeWaiterOrder()
     // interval, try waking up enough operations to fill the gap.  If we race with new incoming operations,
     // the threads will just go back to sleep.
     if (users_with_waiters) {
+        m_waiting_users = users_with_waiters;
         auto io_active = m_io_active.load(std::memory_order_acquire);
         for (size_t idx = io_active; idx < static_cast<size_t>(m_concurrency_limit); idx++) {
             NotifyOne();
@@ -611,19 +632,14 @@ XrdThrottleManager::RecomputeInternal()
 /*
  * Do a simple hash across the username.
  */
-int
-XrdThrottleManager::GetUid(const char *username)
+uint16_t
+XrdThrottleManager::GetUid(const std::string &username)
 {
-   const char *cur = username;
-   int hval = 0;
-   while (cur && *cur && *cur != '@' && *cur != '.')
-   {
-      hval += *cur;
-      hval %= m_max_users;
-      cur++;
-   }
-   //std::cerr << "Calculated UID " << hval << " for " << username << std::endl;
-   return hval;
+    std::hash<std::string> hash_fn;
+    auto hash = hash_fn(username);
+    auto uid = static_cast<uint16_t>(hash % m_max_users);
+    TRACE(DEBUG, "Mapping user " << username << " to UID " << uid);
+    return uid;
 }
 
 /*
@@ -662,6 +678,13 @@ XrdThrottleManager::StartIOTimer(uint16_t uid, bool &ok)
 
    while (m_concurrency_limit >= 0 && cur_counter >= m_concurrency_limit)
    {
+      // If the user has essentially no concurrency, then we let them
+      // temporarily exceed the limit.  This prevents potential waits for
+      // every single read for an infrequent user.
+      if (m_waiter_info[uid].m_concurrency < 1)
+      {
+         break;
+      }
       m_loadshed_limit_hit++;
       m_io_active.fetch_sub(1, std::memory_order_acq_rel);
       TRACE(DEBUG, "ThrottleManager (user=" << uid << "): IO concurrency limit hit; waiting for other IOs to finish.");
@@ -688,6 +711,20 @@ XrdThrottleManager::StopIOTimer(std::chrono::steady_clock::duration & event_dura
    m_waiter_info[uid].m_io_time += event_duration.count();
    if (old_active == static_cast<unsigned>(m_concurrency_limit))
    {
+      // If we are below the concurrency limit threshold and have another waiter
+      // for our user, then execute it immediately.  Otherwise, we will give
+      // someone else a chance to run (as we have gotten more than our share recently).
+      unsigned waiting_users = m_waiting_users;
+      if (waiting_users == 0) waiting_users = 1;
+      if (m_waiter_info[uid].m_concurrency < m_concurrency_limit / waiting_users)
+      {
+         std::unique_lock<std::mutex> lock(m_waiter_info[uid].m_mutex);
+         if (m_waiter_info[uid].m_waiting > 0)
+         {
+            m_waiter_info[uid].NotifyOne(std::move(lock));
+            return;
+         }
+      }
       NotifyOne();
    }
 }
diff --git a/src/XrdThrottle/XrdThrottleManager.hh b/src/XrdThrottle/XrdThrottleManager.hh
index a97588217..d0f8a5db6 100644
--- a/src/XrdThrottle/XrdThrottleManager.hh
+++ b/src/XrdThrottle/XrdThrottleManager.hh
@@ -40,6 +40,7 @@
 #include "XrdSys/XrdSysRAtomic.hh"
 #include "XrdSys/XrdSysPthread.hh"
 
+class XrdSecEntity;
 class XrdSysError;
 class XrdOucTrace;
 class XrdThrottleTimer;
@@ -61,6 +62,11 @@ void        Apply(int reqsize, int reqops, int uid);
 
 bool        IsThrottling() {return (m_ops_per_second > 0) || (m_bytes_per_second > 0);}
 
+// Returns the user name and UID for the given client.
+//
+// The UID is a hash of the user name; it is not guaranteed to be unique.
+std::tuple<std::string, uint16_t> GetUserInfo(const XrdSecEntity *client);
+
 void        SetThrottles(float reqbyterate, float reqoprate, int concurrency, float interval_length)
             {m_interval_length_seconds = interval_length; m_bytes_per_second = reqbyterate;
              m_ops_per_second = reqoprate; m_concurrency_limit = concurrency;}
@@ -78,9 +84,6 @@ void        SetMonitor(XrdXrootdGStream *gstream) {m_gstream = gstream;}
 
 //int         Stats(char *buff, int blen, int do_sync=0) {return m_pool.Stats(buff, blen, do_sync);}
 
-static
-int         GetUid(const char *username);
-
 // Notify that an I/O operation has started for a given user.
 //
 // If we are at the maximum concurrency limit then this will block;
@@ -106,6 +109,11 @@ void        StopIOTimer(std::chrono::steady_clock::duration & event_duration, ui
 
 private:
 
+// Determine the UID for a given user name.
+// This is a hash of the username; it is not guaranteed to be unique.
+// The UID is used to index into the waiters array and cannot be more than m_max_users.
+uint16_t    GetUid(const std::string &);
+
 void        Recompute();
 
 void        RecomputeInternal();
@@ -168,7 +176,7 @@ struct alignas(64) Waiter
    // EWMA of the concurrency for this user.  This is used to determine how much
    // above / below the user's concurrency share they've been recently.  This subsequently
    // will affect the likelihood of being woken up.
-   float m_concurrency{0};
+   XrdSys::RAtomic<float> m_concurrency{0};
 
    // I/O time for this user since the last recompute interval.  The value is used
    // to compute the EWMA of the concurrency (m_concurrency).
@@ -204,6 +212,7 @@ std::array<XrdSys::RAtomic<int16_t>, m_max_users> m_wake_order_1; // A second wa
 XrdSys::RAtomic<char> m_wake_order_active; // The current active wake order array; 0 or 1
 std::atomic<size_t> m_waiter_offset{0}; // Offset inside the wake order array; this is used to wake up the next potential user in line.  Cannot be relaxed atomic as offsets need to be seen in order.
 std::chrono::steady_clock::time_point m_last_waiter_recompute_time; // Last time we recomputed the wait ordering.
+XrdSys::RAtomic<unsigned> m_waiting_users{0}; // Number of users waiting behind the throttle as of the last recompute time.
 
 std::atomic<uint32_t> m_io_active; // Count of in-progress IO operations: cannot be a relaxed atomic as ordering of inc/dec matters.
 XrdSys::RAtomic<std::chrono::steady_clock::duration::rep> m_io_active_time; // Total IO wait time recorded since the last recompute interval; reset to zero about every second.
-- 
2.43.5

