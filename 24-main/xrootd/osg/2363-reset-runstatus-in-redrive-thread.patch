From b9d604c5b4801e09c4cc8cdbdab195f2dd7fac8c Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelman@morgridge.org>
Date: Thu, 24 Oct 2024 10:55:33 -0500
Subject: [PATCH] Reset the state after processing while in redrive

Each time we process successfully from the redrive thread, we should
decrement the status counter.

Otherwise, after multiple requests, the attempt to `Run` from XrdHttp
will fail.  This was observed to cause failures in closing files
100% of the time when the open was delayed, causing failures in
the XrdHttp response.

This additionally adds logging on failures for submitting the run.
---
 src/XrdXrootd/XrdXrootdTransit.cc | 22 ++++++++++++++++++----
 1 file changed, 18 insertions(+), 4 deletions(-)

diff --git a/src/XrdXrootd/XrdXrootdTransit.cc b/src/XrdXrootd/XrdXrootdTransit.cc
index 52d454de7c6..57720b78ac0 100644
--- a/src/XrdXrootd/XrdXrootdTransit.cc
+++ b/src/XrdXrootd/XrdXrootdTransit.cc
@@ -463,6 +463,11 @@ void XrdXrootdTransit::Redrive()
         if (rc == 0) {
           rc = realProt->Process(NULL);
         }
+        if (runStatus)
+           {AtomicBeg(runMutex);
+            AtomicZAP(runStatus);
+            AtomicEnd(runMutex);
+           }
       } while((rc == 0) && !runError && !runWait);
    }
       else rc = Send(kXR_error, ioV, 2, 0);
@@ -567,7 +572,10 @@ bool XrdXrootdTransit::Run(const char *xreqP, char *xdataP, int xdataL)
    AtomicBeg(runMutex);
    rc = AtomicInc(runStatus);
    AtomicEnd(runMutex);
-   if (rc) return false;
+   if (rc)
+      {TRACEP(REQ, "Bridge request failed due to re-entry");
+       return false;
+      }
 
 // Copy the request header
 //
@@ -579,13 +587,17 @@ bool XrdXrootdTransit::Run(const char *xreqP, char *xdataP, int xdataL)
    if (Request.header.requestid & 0x8000
    || Request.header.requestid > static_cast<kXR_unt16>(kXR_truncate)
    || !reqTab[Request.header.requestid - kXR_auth])
-      return Fail(kXR_Unsupported, "Unsupported bridge request");
+      {TRACEP(REQ, "Unsupported bridge request");
+       return Fail(kXR_Unsupported, "Unsupported bridge request");
+      }
 
 // Validate the data length
 //
    Request.header.dlen      = ntohl(Request.header.dlen);
    if (Request.header.dlen < 0)
-      return Fail(kXR_ArgInvalid, "Invalid request data length");
+      {TRACEP(REQ, "Invalid request data length");
+       return Fail(kXR_ArgInvalid, "Invalid request data length");
+      }
 
 // Copy the stream id and trace this request
 //
@@ -607,7 +619,9 @@ bool XrdXrootdTransit::Run(const char *xreqP, char *xdataP, int xdataL)
        if (!runArgs || movLen > runABsz)
           {if (runArgs) free(runArgs);
            if (!(runArgs = (char *)malloc(movLen)))
-              return Fail(kXR_NoMemory, "Insufficient memory");
+              {TRACEP(REQ, "Failed to allocate memory");
+               return Fail(kXR_NoMemory, "Insufficient memory");
+              }
            runABsz = movLen;
           }
        memcpy(runArgs, xdataP, movLen); runALen = movLen;
