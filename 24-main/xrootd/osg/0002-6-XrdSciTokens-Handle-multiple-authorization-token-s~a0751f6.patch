From b251f925b3bdf8516d583c02b9249302003a17a7 Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelman@morgridge.org>
Date: Tue, 28 Jan 2025 09:57:02 -0600
Subject: [PATCH 2/7] [#6] [XrdSciTokens] Handle multiple authorization token
 setups

---
 src/XrdHttpTpc/XrdHttpTpcUtils.cc      |   5 +-
 src/XrdMacaroons/XrdMacaroonsAuthz.cc  |   4 +
 src/XrdOuc/XrdOucEnv.cc                |  60 ++-
 src/XrdOuc/XrdOucPrivateUtils.hh       |   4 +-
 src/XrdOuc/XrdOucUtils.cc              |   2 +-
 src/XrdSciTokens/CMakeLists.txt        |  17 +-
 src/XrdSciTokens/README.md             |  11 +
 src/XrdSciTokens/XrdSciTokensAccess.cc | 631 ++++++++++++++-----------
 src/XrdSciTokens/XrdSciTokensAccess.hh | 214 +++++++++
 tests/XRootD/scitokens-module.cfg      |   8 +-
 tests/XRootD/scitokens.sh              |  21 +
 tests/XrdOucTests/CMakeLists.txt       |   2 +-
 tests/XrdOucTests/XrdOucEnvTests.cc    |  28 ++
 tests/XrdOucTests/XrdOucUtilsTests.cc  |   3 +
 tests/scitokens/CMakeLists.txt         |   9 +
 tests/scitokens/XrdSciTokens.cc        |  73 +++
 16 files changed, 784 insertions(+), 308 deletions(-)
 create mode 100644 src/XrdSciTokens/XrdSciTokensAccess.hh
 create mode 100644 tests/XrdOucTests/XrdOucEnvTests.cc
 create mode 100644 tests/scitokens/XrdSciTokens.cc

diff --git a/src/XrdHttpTpc/XrdHttpTpcUtils.cc b/src/XrdHttpTpc/XrdHttpTpcUtils.cc
index 6f5f3f603..8a09100f0 100644
--- a/src/XrdHttpTpc/XrdHttpTpcUtils.cc
+++ b/src/XrdHttpTpc/XrdHttpTpcUtils.cc
@@ -43,6 +43,9 @@ std::string XrdHttpTpcUtils::prepareOpenURL(const std::string & reqResource, std
           reqHeaders["Authorization"] = token.substr(6);
           has_authz_header = true;
         }
+      } else if (!strncmp(token.c_str(), "access_token=", 13) && !has_authz_header) {
+        reqHeaders["Authorization"] = token.substr(13);
+        has_authz_header = true;
       } else {
         opaque << "&" << token;
       }
@@ -60,4 +63,4 @@ std::string XrdHttpTpcUtils::prepareOpenURL(const std::string & reqResource, std
   }
 
   return reqResource + opaque.str();
-}
\ No newline at end of file
+}
diff --git a/src/XrdMacaroons/XrdMacaroonsAuthz.cc b/src/XrdMacaroons/XrdMacaroonsAuthz.cc
index df771b06c..aee058442 100644
--- a/src/XrdMacaroons/XrdMacaroonsAuthz.cc
+++ b/src/XrdMacaroons/XrdMacaroonsAuthz.cc
@@ -173,6 +173,10 @@ Authz::Access(const XrdSecEntity *Entity, const char *path,
 
     const char *authz = env ? env->Get("authz") : nullptr;
     if (authz && !strncmp(authz, "Bearer%20", 9))
+    {
+        authz += 9;
+    }
+    else if (!authz && (authz = env ? env->Get("access_token") : nullptr) && !strncmp(authz, "Bearer%20", 9))
     {
         authz += 9;
     }
diff --git a/src/XrdOuc/XrdOucEnv.cc b/src/XrdOuc/XrdOucEnv.cc
index 704049a0d..72fd9df6b 100644
--- a/src/XrdOuc/XrdOucEnv.cc
+++ b/src/XrdOuc/XrdOucEnv.cc
@@ -102,13 +102,13 @@ char *XrdOucEnv::Delimit(char *value)
 
 void XrdOucEnv::EnvBuildTidy()
 {
-   char *tidyEnv, *authInfo;
-   int aBeg, aEnd;
+   char *tidyEnv, *authInfo, *accessAuthInfo = nullptr, *working=global_env;
+   int aBeg, aEnd, aCount = 6;
 
 // We need to sanitize the current env string by removing auth info. If there
-// is no auth informationn, then we can short cicuit this.
+// is no auth information, then we can short circuit this.
 //
-   if ((authInfo = strstr(global_env, "authz=")) == 0)
+   if ((authInfo = strstr(global_env, "authz=")) == 0 && (accessAuthInfo = strstr(global_env, "access_token=")) == 0)
       {Put(TIDY_ENVVAR, "");
        return;
       }
@@ -116,23 +116,41 @@ void XrdOucEnv::EnvBuildTidy()
 // Get position of the auth string and check if we can do a fast deletion.
 // Otherwise, we must trudge along.
 //
-   aBeg = authInfo - global_env;
-   if (aBeg && global_env[aBeg-1] == '&') aBeg--;
-   if (!(tidyEnv = index(authInfo+6, '&')))
-      {char aSave = global_env[aBeg];
-       global_env[aBeg] = 0;
-       Put(TIDY_ENVVAR, global_env);
-       global_env[aBeg] = aSave;
-      } else {
-       XrdOucString tidyStr(global_env);
-       do{if ((aEnd = tidyStr.find('&', aBeg+6)) == STR_NPOS)
-             {tidyStr.erase(aBeg);
-              break;
-             }
-          tidyStr.erase(aBeg, aEnd-aBeg);
-         } while((aBeg = tidyStr.find("&authz=")) != STR_NPOS);
-       Put(TIDY_ENVVAR, tidyStr.c_str());
-      }
+   for (int idx = 0; idx < 2; idx++)
+       {if (idx == 1)
+           {if (authInfo)
+               {working=Get(TIDY_ENVVAR);
+                accessAuthInfo = strstr(working, "access_token=");
+               }
+            aCount = 13;
+            authInfo = accessAuthInfo;
+           }
+        if (!authInfo) continue;
+        aBeg = authInfo - working;
+        if (aBeg && working[aBeg-1] == '&') aBeg--;
+        if (!(tidyEnv = index(authInfo+aCount, '&')))
+           {char aSave = working[aBeg];
+            if (aBeg) {
+                working[aBeg] = 0;
+                Put(TIDY_ENVVAR, working);
+                working[aBeg] = aSave;
+               } else {
+                Put(TIDY_ENVVAR, "&");
+               }
+           } else {
+            XrdOucString tidyStr(working);
+            do{if ((aEnd = tidyStr.find('&', aBeg+aCount)) == STR_NPOS)
+                  {tidyStr.erase(aBeg);
+                   break;
+                  }
+               tidyStr.erase(aBeg, aEnd-aBeg);
+              } while((aBeg = tidyStr.find(idx ? "&access_token=" : "&authz=")) != STR_NPOS);
+             if (!tidyStr.length())
+                Put(TIDY_ENVVAR, "&");
+             else
+                Put(TIDY_ENVVAR, tidyStr.c_str());
+           }
+       }
 }
  
 /******************************************************************************/
diff --git a/src/XrdOuc/XrdOucPrivateUtils.hh b/src/XrdOuc/XrdOucPrivateUtils.hh
index e5e220000..d7d1b391b 100644
--- a/src/XrdOuc/XrdOucPrivateUtils.hh
+++ b/src/XrdOuc/XrdOucPrivateUtils.hh
@@ -30,8 +30,8 @@
 /**
  * Returns true if path @p subdir is a subdirectory of @p dir.
  */
-static inline bool is_subdirectory(const std::string& dir,
-                                   const std::string& subdir)
+static inline bool is_subdirectory(const std::string_view dir,
+                                   const std::string_view subdir)
 {
     if (subdir.size() < dir.size())
       return false;
diff --git a/src/XrdOuc/XrdOucUtils.cc b/src/XrdOuc/XrdOucUtils.cc
index f92e07ee0..662a21e78 100644
--- a/src/XrdOuc/XrdOucUtils.cc
+++ b/src/XrdOuc/XrdOucUtils.cc
@@ -1490,7 +1490,7 @@ std::string obfuscateAuth(const std::string& input)
 {
   static const regex_t auth_regex = []() {
     constexpr char re[] =
-      "(authz=|(transferheader)?(www-|proxy-)?auth(orization|enticate)[[:space:]]*:[[:space:]]*)"
+      "(access_token=|authz=|(transferheader)?(www-|proxy-)?auth(orization|enticate)[[:space:]]*:[[:space:]]*)"
       "(Bearer([[:space:]]|%20)?(token([[:space:]]|%20)?)?)?";
 
     regex_t regex;
diff --git a/src/XrdSciTokens/CMakeLists.txt b/src/XrdSciTokens/CMakeLists.txt
index df34f4289..003a6496d 100644
--- a/src/XrdSciTokens/CMakeLists.txt
+++ b/src/XrdSciTokens/CMakeLists.txt
@@ -18,12 +18,12 @@ endif()
 
 set(XrdAccSciTokens XrdAccSciTokens-${PLUGIN_VERSION})
 
-add_library(${XrdAccSciTokens} MODULE
+add_library(XrdSciTokensObj
   XrdSciTokensAccess.cc XrdSciTokensHelper.hh
   XrdSciTokensMon.cc    XrdSciTokensMon.hh
 )
 
-target_link_libraries(${XrdAccSciTokens}
+target_link_libraries(XrdSciTokensObj
   PRIVATE
     XrdUtils
     XrdServer
@@ -32,20 +32,29 @@ target_link_libraries(${XrdAccSciTokens}
     ${CMAKE_DL_LIBS}
 )
 
-target_include_directories(${XrdAccSciTokens}
+target_include_directories(XrdSciTokensObj
   PRIVATE
     vendor/inih
     vendor/picojson
     ${SCITOKENS_CPP_INCLUDE_DIR}
 )
 
+set_target_properties(XrdSciTokensObj PROPERTIES POSITION_INDEPENDENT_CODE ON)
 if(HAVE_SCITOKEN_CONFIG_SET_STR)
-  target_compile_definitions(${XrdAccSciTokens}
+  target_compile_definitions(XrdSciTokensObj
     PRIVATE
       HAVE_SCITOKEN_CONFIG_SET_STR
   )
 endif()
 
+add_library(${XrdAccSciTokens} MODULE
+  "$<TARGET_OBJECTS:XrdSciTokensObj>"
+)
+target_link_libraries(${XrdAccSciTokens}
+  PRIVATE
+    XrdSciTokensObj
+)
+
 install(
   TARGETS
     ${XrdAccSciTokens}
diff --git a/src/XrdSciTokens/README.md b/src/XrdSciTokens/README.md
index 1edecf944..ab47f60e2 100644
--- a/src/XrdSciTokens/README.md
+++ b/src/XrdSciTokens/README.md
@@ -129,6 +129,15 @@ are:
       For the `group` and `mapping` cases, the username and group are set in the internal XRootD request credential,
       but the final authorization must be done by a subsequent plugin.  The default value is `capability group mapping`.
       *Note*: if `mapping` is present, then a token without a capability may still have authorized actions.
+   -  `required_authorization` (optional): In some configurations, there may be multiple possible issuers for a given path; by
+      default, authorization from any one issuer is sufficient.  This option indicates the issuer's authorization is _required_
+      for the path (meaning that a token from this issuer is always required for the paths it manages, regardless of what
+      other issuers may authorize).  Valid values are `none`, `read`, `write`, or `all`; default is `none`.
+   -  `acceptable_authorization` (optional): Whether a valid token from this issuer is acceptable for the XRootD authorization
+      framework.  If so, the user, issuer, and group information will be extracted from the token and passed to the
+      XRootD credential (the username may, for example, be used by a subsequent OSS plugin for interacting with the
+      filesystem).  This may be useful in cases where a token is required from a given issuer but shouldn't be used
+      to populate the username.  Valid values are `none`, `read`, `write`, or `all`; default is `all`.
 
 
 Group- and Scope-based authorization
@@ -142,6 +151,8 @@ If there is a group-based attribute, then the contents are copied into XRootD's
 not necessarily immediately authorize (see the `onmissing` attribute) but rather can be used by a further authorization
 plugin.
 
+If there are multiple tokens in the request, they are processed in order until an acceptable authorization is found.
+
 Mapfile format
 --------------
 
diff --git a/src/XrdSciTokens/XrdSciTokensAccess.cc b/src/XrdSciTokens/XrdSciTokensAccess.cc
index f982556a3..3eda05f82 100644
--- a/src/XrdSciTokens/XrdSciTokensAccess.cc
+++ b/src/XrdSciTokens/XrdSciTokensAccess.cc
@@ -25,6 +25,7 @@
 #include "picojson.h"
 
 #include "scitokens/scitokens.h"
+#include "XrdSciTokens/XrdSciTokensAccess.hh"
 #include "XrdSciTokens/XrdSciTokensHelper.hh"
 #include "XrdSciTokens/XrdSciTokensMon.hh"
 
@@ -33,6 +34,8 @@
 XrdVERSIONINFO(XrdAccAuthorizeObject, XrdAccSciTokens);
 XrdVERSIONINFO(XrdAccAuthorizeObjAdd, XrdAccSciTokens);
 
+XrdSciTokensHelper *SciTokensHelper = nullptr;
+
 namespace {
 
 enum LogMask {
@@ -43,13 +46,6 @@ enum LogMask {
     All = 0xff
 };
 
-enum IssuerAuthz {
-    Capability = 0x01,
-    Group = 0x02,
-    Mapping = 0x04,
-    Default = 0x07
-};
-
 std::string LogMaskToString(int mask) {
     if (mask == LogMask::All) {return "all";}
 
@@ -74,8 +70,6 @@ std::string LogMaskToString(int mask) {
     return ss.str();
 }
 
-typedef std::vector<std::pair<Access_Operation, std::string>> AccessRulesRaw;
-
 inline uint64_t monotonic_time() {
   struct timespec tp;
 #ifdef CLOCK_MONOTONIC_COARSE
@@ -225,54 +219,6 @@ void ParseCanonicalPaths(const std::string &path, std::vector<std::string> &resu
     } while (pos != std::string::npos);
 }
 
-struct MapRule
-{
-    MapRule(const std::string &sub,
-            const std::string &username,
-            const std::string &path_prefix,
-            const std::string &group,
-            const std::string &result)
-        : m_sub(sub),
-          m_username(username),
-          m_path_prefix(path_prefix),
-          m_group(group),
-          m_result(result)
-    {
-        //std::cerr << "Making a rule {sub=" << sub << ", username=" << username << ", path=" << path_prefix << ", group=" << group << ", result=" << name << "}" << std::endl;
-    }
-
-    const std::string match(const std::string &sub,
-                            const std::string &username,
-                            const std::string &req_path,
-                            const std::vector<std::string> &groups) const
-    {
-        if (!m_sub.empty() && sub != m_sub) {return "";}
-
-        if (!m_username.empty() && username != m_username) {return "";}
-
-        if (!m_path_prefix.empty() &&
-            strncmp(req_path.c_str(), m_path_prefix.c_str(), m_path_prefix.size()))
-        {
-            return "";
-        }
-
-        if (!m_group.empty()) {
-            for (const auto &group : groups) {
-                if (group == m_group)
-                    return m_result;
-            }
-            return "";
-        }
-        return m_result;
-    }
-
-    std::string m_sub;
-    std::string m_username;
-    std::string m_path_prefix;
-    std::string m_group;
-    std::string m_result;
-};
-
 struct IssuerConfig
 {
     IssuerConfig(const std::string &issuer_name,
@@ -284,8 +230,12 @@ struct IssuerConfig
                  const std::string &default_user,
                  const std::string &username_claim,
                  const std::string &groups_claim,
-                 const std::vector<MapRule> rules)
+                 const std::vector<MapRule> rules,
+                 AuthzSetting acceptable_authz,
+                 AuthzSetting required_authz)
         : m_map_subject(map_subject || !username_claim.empty()),
+          m_acceptable_authz(acceptable_authz),
+          m_required_authz(required_authz),
           m_authz_strategy(authz_strategy),
           m_name(issuer_name),
           m_url(issuer_url),
@@ -298,6 +248,8 @@ struct IssuerConfig
     {}
 
     const bool m_map_subject;
+    const AuthzSetting m_acceptable_authz;
+    const AuthzSetting m_required_authz;
     const uint32_t m_authz_strategy;
     const std::string m_name;
     const std::string m_url;
@@ -309,8 +261,6 @@ struct IssuerConfig
     const std::vector<MapRule> m_map_rules;
 };
 
-}
-
 class OverrideINIReader: public INIReader {
 public:
     OverrideINIReader() {};
@@ -347,113 +297,142 @@ protected:
 
 };
 
-class XrdAccRules
-{
-public:
-    XrdAccRules(uint64_t expiry_time, const std::string &username, const std::string &token_subject,
-        const std::string &issuer, const std::vector<MapRule> &rules, const std::vector<std::string> &groups,
-        uint32_t authz_strategy) :
-        m_authz_strategy(authz_strategy),
-        m_expiry_time(expiry_time),
-        m_username(username),
-        m_token_subject(token_subject),
-        m_issuer(issuer),
-        m_map_rules(rules),
-        m_groups(groups)
-    {}
 
-    ~XrdAccRules() {}
+void
+ParseTokenString(const std::string &param, XrdOucEnv *env, std::vector<std::string_view> &authz_list)
+{
+    if (!env) {return;}
+    const char *authz = env->Get(param.c_str());
+    if (!authz) {return;}
+    std::string_view authz_view(authz);
+    size_t pos;
+    do {
+        // Note: this is more permissive than the plugin was previously.
+        // The prefix 'Bearer%20' used to be required as that's what HTTP
+        // required.  However, to make this more pleasant for XRootD protocol
+        // users, we now simply "handle" the prefix insterad of requiring it.
+        if (authz_view.substr(0, 9) == "Bearer%20") {
+            authz_view = authz_view.substr(9);
+        }
+        pos = authz_view.find(",");
+        authz_list.push_back(authz_view.substr(0, pos));
+        authz_view = authz_view.substr(pos + 1);
+    } while (pos != std::string_view::npos);
+}
 
-    bool apply(Access_Operation oper, std::string path) {
-      for (const auto & rule : m_rules) {
-        // Skip rules that don't match the current operation
-        if (rule.first != oper)
-          continue;
+} // namespace
 
-        // If the rule allows any path, allow the operation
-        if (rule.second == "/")
-          return true;
+std::string
+SubpathMatch::str() const {
+    return AccessRuleStr(m_rules); // Returns a human-friendly representation of the access rules
+}
 
-        // Allow operation if path is a subdirectory of the rule's path
-        if (is_subdirectory(rule.second, path)) {
-          return true;
-        } else {
-          // Allow stat and mkdir of parent directories to comply with WLCG token specs
-          if (oper == AOP_Stat || oper == AOP_Mkdir)
-            if (is_subdirectory(path, rule.second))
-              return true;
+// Convert a list of authorizations into a human-readable string.
+const std::string
+XrdAccRules::str() const
+{
+    std::stringstream ss;
+    ss << "mapped_username=" << m_username << ", subject=" << m_token_subject
+        << ", issuer=" << m_issuer;
+    if (!m_groups.empty()) {
+        ss << ", groups=";
+        bool first=true;
+        for (const auto &group : m_groups) {
+            ss << (first ? "" : ",") << group;
+            first = false;
         }
-      }
-      return false;
     }
+    if (!m_matcher.empty()) {
+        ss << ", authorizations=" << m_matcher.str();
+    }
+    return ss.str();
+}
 
-    bool expired() const {return monotonic_time() > m_expiry_time;}
+bool XrdAccRules::expired() const
+{
+    return monotonic_time() > m_expiry_time;
+}
 
-    void parse(const AccessRulesRaw &rules) {
-        m_rules.reserve(rules.size());
-        for (const auto &entry : rules) {
-            m_rules.emplace_back(entry.first, entry.second);
-        }
-    }
+// Determine whether a list of authorizations contains at least one entry
+// from each of the applicable required issuers.
+//
+// - `oper`: The operation type (read, write) to test for authorization.
+// - `path`: The requested path for the operation.
+// - `required_issuers`: A map from a list of paths to an issuer.
+// - `access_rules_list`: A list of access rules derived from the token
+//
+// If the requested path/operation matches one of the required issuers, then one
+// of the provided authorizations (e.g., the token's scopes) must come from that
+// issuer.
+//
+// The return value indicates whether the required authorization was missing, found,
+// or there was no required issuer for the path.
+bool AuthorizesRequiredIssuers(Access_Operation client_oper, const std::string_view &path,
+    const std::vector<std::pair<std::unique_ptr<SubpathMatch>, std::string>> &required_issuers,
+    const std::vector<std::shared_ptr<XrdAccRules>> &access_rules_list)
+{
 
-    std::string get_username(const std::string &req_path) const
-    {
-        for (const auto &rule : m_map_rules) {
-            std::string name = rule.match(m_token_subject, m_username, req_path, m_groups);
-            if (!name.empty()) {
-                return name;
-            }
-        }
-        return "";
-    }
+    // Translate the client-attempted operation to one of the simpler operations we've defined.
+    Access_Operation oper;
+    switch (client_oper) {
+        case AOP_Any:
+            return false; // Invalid request
+            break;
+        case AOP_Chmod: [[fallthrough]];
+        case AOP_Chown: [[fallthrough]];
+        case AOP_Create: [[fallthrough]];
+        case AOP_Excl_Create: [[fallthrough]];
+        case AOP_Delete: [[fallthrough]];
+        case AOP_Excl_Insert: [[fallthrough]];
+        case AOP_Insert: [[fallthrough]];
+        case AOP_Lock:
+            oper = AOP_Create;
+            break;
+        case AOP_Mkdir:
+            oper = AOP_Mkdir;
+            break;
+        case AOP_Read:
+            oper = AOP_Read;
+            break;
+        case AOP_Readdir:
+            oper = AOP_Readdir;
+            break;
+        case AOP_Rename:
+            oper = AOP_Create;
+            break;
+        case AOP_Stat:
+            oper = AOP_Stat;
+            break;
+        case AOP_Update:
+            oper = AOP_Update;
+            break;
+        default:
+            return false; // Invalid request
+    };
 
-    const std::string str() const
-    {
-        std::stringstream ss;
-        ss << "mapped_username=" << m_username << ", subject=" << m_token_subject
-           << ", issuer=" << m_issuer;
-        if (!m_groups.empty()) {
-            ss << ", groups=";
-            bool first=true;
-            for (const auto &group : m_groups) {
-                ss << (first ? "" : ",") << group;
-                first = false;
+    // Iterate through all the required issuers
+    for (const auto &info : required_issuers) {
+        // See if this issuer is required for this path/operation.
+        if (info.first->apply(oper, path)) {
+            bool has_authz = false;
+            // If so, see if one of the tokens (a) is from this issuer and (b) authorizes the request.
+            for (const auto &rules : access_rules_list) {
+                if (rules->get_issuer() == info.second && rules->apply(oper, path)) {
+                    has_authz = true;
+                    break;
+                }
+            }
+            if (!has_authz) {
+                return false;
             }
         }
-        if (!m_rules.empty()) {
-            ss << ", authorizations=" << AccessRuleStr(m_rules);
-        }
-        return ss.str();
     }
-
-
-        // Return the token's subject, an opaque unique string within the issuer's
-        // namespace.  It may or may not be related to the username one should
-        // use within the authorization framework.
-    const std::string & get_token_subject() const {return m_token_subject;}
-    const std::string & get_default_username() const {return m_username;}
-    const std::string & get_issuer() const {return m_issuer;}
-
-    uint32_t get_authz_strategy() const {return m_authz_strategy;}
-
-    size_t size() const {return m_rules.size();}
-    const std::vector<std::string> &groups() const {return m_groups;}
-
-private:
-    uint32_t m_authz_strategy;
-    AccessRulesRaw m_rules;
-    uint64_t m_expiry_time{0};
-    const std::string m_username;
-    const std::string m_token_subject;
-    const std::string m_issuer;
-    const std::vector<MapRule> m_map_rules;
-    const std::vector<std::string> m_groups;
-};
+    return true;
+}
 
 class XrdAccSciTokens;
 
 XrdAccSciTokens *accSciTokens = nullptr;
-XrdSciTokensHelper *SciTokensHelper = nullptr;
 
 class XrdAccSciTokens : public XrdAccAuthorize, public XrdSciTokensHelper,
                         public XrdSciTokensMon
@@ -491,64 +470,87 @@ public:
                                   const Access_Operation oper,
                                         XrdOucEnv       *env) override
     {
-        const char *authz = env ? env->Get("authz") : nullptr;
-            // Note: this is more permissive than the plugin was previously.
-            // The prefix 'Bearer%20' used to be required as that's what HTTP
-            // required.  However, to make this more pleasant for XRootD protocol
-            // users, we now simply "handle" the prefix insterad of requiring it.
-        if (authz && !strncmp(authz, "Bearer%20", 9)) {
-            authz += 9;
-        }
-            // If there's no request-specific token, then see if the ZTN authorization
-            // has provided us with a session token.
-        if (!authz && Entity && !strcmp("ztn", Entity->prot) && Entity->creds &&
+        std::vector<std::string_view> authz_list;
+        authz_list.reserve(1);
+
+        // Parse the authz environment entry as a comma-separated list of tokens.
+        // Traditionally, `authz` has been used as the parameter for XRootD; however,
+        // RFC 6750 Section 2.3 ("URI Query Parameter") specifies that access_token
+        // is correct.  We support both.
+        ParseTokenString("authz", env, authz_list);
+        ParseTokenString("access_token", env, authz_list);
+
+        if (Entity && !strcmp("ztn", Entity->prot) && Entity->creds &&
             Entity->credslen && Entity->creds[Entity->credslen] == '\0')
         {
-            authz = Entity->creds;
+            authz_list.push_back(Entity->creds);
         }
-        if (authz == nullptr) {
+
+        if (authz_list.empty()) {
             return OnMissing(Entity, path, oper, env);
         }
+
+        // A potential DoS would be providing a large number of tokens to consider for ACLs.
+        // Have a hardcoded assumption of <10 tokens per request.
+        if (authz_list.size() > 10) {
+            m_log.Log(LogMask::Warning, "Access", "Request had more than 10 tokens attached; ignoring");
+            return OnMissing(Entity, path, oper, env);
+        }
+
         m_log.Log(LogMask::Debug, "Access", "Trying token-based access control");
-        std::shared_ptr<XrdAccRules> access_rules;
+        std::vector<std::shared_ptr<XrdAccRules>> access_rules_list;
         uint64_t now = monotonic_time();
         Check(now);
-        {
-            std::lock_guard<std::mutex> guard(m_mutex);
-            const auto iter = m_map.find(authz);
-            if (iter != m_map.end() && !iter->second->expired()) {
-                access_rules = iter->second;
-            }
-        }
-        if (!access_rules) {
-            m_log.Log(LogMask::Debug, "Access", "Token not found in recent cache; parsing.");
-            try {
-                uint64_t cache_expiry;
-                AccessRulesRaw rules;
-                std::string username;
-                std::string token_subject;
-                std::string issuer;
-                std::vector<MapRule> map_rules;
-                std::vector<std::string> groups;
-                uint32_t authz_strategy;
-                if (GenerateAcls(authz, cache_expiry, rules, username, token_subject, issuer, map_rules, groups, authz_strategy)) {
-                    access_rules.reset(new XrdAccRules(now + cache_expiry, username, token_subject, issuer, map_rules, groups, authz_strategy));
-                    access_rules->parse(rules);
-                } else {
-                    m_log.Log(LogMask::Warning, "Access", "Failed to generate ACLs for token");
-                    return OnMissing(Entity, path, oper, env);
+        for (const auto &authz : authz_list) {
+            std::shared_ptr<XrdAccRules> access_rules;
+            {
+                std::lock_guard<std::mutex> guard(m_mutex);
+                const auto iter = m_map.find(authz);
+                if (iter != m_map.end() && !iter->second->expired()) {
+                    access_rules = iter->second;
                 }
-                if (m_log.getMsgMask() & LogMask::Debug) {
-                    m_log.Log(LogMask::Debug, "Access", "New valid token", access_rules->str().c_str());
+            }
+            if (!access_rules) {
+                m_log.Log(LogMask::Debug, "Access", "Token not found in recent cache; parsing.");
+                try {
+                    uint64_t cache_expiry;
+                    AccessRulesRaw rules;
+                    std::string username;
+                    std::string token_subject;
+                    std::string issuer;
+                    std::vector<MapRule> map_rules;
+                    std::vector<std::string> groups;
+                    uint32_t authz_strategy;
+                    AuthzSetting acceptable_authz;
+                    if (GenerateAcls(authz, cache_expiry, rules, username, token_subject, issuer, map_rules, groups, authz_strategy, acceptable_authz)) {
+                        access_rules.reset(new XrdAccRules(now + cache_expiry, username, token_subject, issuer, map_rules, groups, authz_strategy, acceptable_authz));
+                        access_rules->parse(rules);
+                    } else {
+                        m_log.Log(LogMask::Warning, "Access", "Failed to generate ACLs for token");
+                        continue;
+                    }
+                    if (m_log.getMsgMask() & LogMask::Debug) {
+                        m_log.Log(LogMask::Debug, "Access", "New valid token", access_rules->str().c_str());
+                    }
+                } catch (std::exception &exc) {
+                    m_log.Log(LogMask::Warning, "Access", "Error generating ACLs for authorization", exc.what());
+                    continue;
                 }
-            } catch (std::exception &exc) {
-                m_log.Log(LogMask::Warning, "Access", "Error generating ACLs for authorization", exc.what());
-                return OnMissing(Entity, path, oper, env);
+                std::lock_guard<std::mutex> guard(m_mutex);
+                m_map[std::string(authz)] = access_rules;
+            } else if (m_log.getMsgMask() & LogMask::Debug) {
+                m_log.Log(LogMask::Debug, "Access", "Cached token", access_rules->str().c_str());
             }
-            std::lock_guard<std::mutex> guard(m_mutex);
-            m_map[authz] = access_rules;
-        } else if (m_log.getMsgMask() & LogMask::Debug) {
-            m_log.Log(LogMask::Debug, "Access", "Cached token", access_rules->str().c_str());
+            access_rules_list.push_back(access_rules);
+        }
+        if (access_rules_list.empty()) {
+            return OnMissing(Entity, path, oper, env);
+        }
+        std::string_view path_view(path, strlen(path));
+
+        // Apply the logic for the required issuers.
+        if (!AuthorizesRequiredIssuers(oper, path_view, m_required_issuers, access_rules_list)) {
+            return OnMissing(Entity, path, oper, env);
         }
 
         // Strategy: assuming the corresponding strategy is enabled, we populate the name in
@@ -562,93 +564,103 @@ public:
         // We always populate the issuer and the groups, if present.
 
         // Access may be authorized; populate XrdSecEntity
-        XrdSecEntity new_secentity;
-        new_secentity.vorg = nullptr;
-        new_secentity.grps = nullptr;
-        new_secentity.role = nullptr;
-        new_secentity.secMon = Entity->secMon;
-        new_secentity.addrInfo = Entity->addrInfo;
-        const auto &issuer = access_rules->get_issuer();
-        if (!issuer.empty()) {
-            new_secentity.vorg = strdup(issuer.c_str());
-        }
-        bool group_success = false;
-        if ((access_rules->get_authz_strategy() & IssuerAuthz::Group) && access_rules->groups().size()) {
-            std::stringstream ss;
-            for (const auto &grp : access_rules->groups()) {
-                ss << grp << " ";
-            }
-            const auto &groups_str = ss.str();
-            new_secentity.grps = static_cast<char*>(malloc(groups_str.size() + 1));
-            if (new_secentity.grps) {
-                memcpy(new_secentity.grps, groups_str.c_str(), groups_str.size());
-                new_secentity.grps[groups_str.size()] = '\0';
+        for (const auto &access_rules : access_rules_list) {
+            // Make sure this issuer is acceptable for the given operation.
+            if (!access_rules->acceptable_authz(oper)) {
+                m_log.Log(LogMask::Debug, "Access", "Issuer is not acceptable for given operation:", access_rules->get_issuer().c_str());
+                continue;
             }
-            group_success = true;
-        }
 
-        std::string username;
-        bool mapping_success = false;
-        bool scope_success = false;
-        username = access_rules->get_username(path);
+            XrdSecEntity new_secentity;
+            new_secentity.vorg = nullptr;
+            new_secentity.grps = nullptr;
+            new_secentity.role = nullptr;
+            new_secentity.secMon = Entity->secMon;
+            new_secentity.addrInfo = Entity->addrInfo;
+            const auto &issuer = access_rules->get_issuer();
+            if (!issuer.empty()) {
+                new_secentity.vorg = strdup(issuer.c_str());
+            }
+            bool group_success = false;
+            if ((access_rules->get_authz_strategy() & IssuerAuthz::Group) && access_rules->groups().size()) {
+                std::stringstream ss;
+                for (const auto &grp : access_rules->groups()) {
+                    ss << grp << " ";
+                }
+                const auto &groups_str = ss.str();
+                new_secentity.grps = static_cast<char*>(malloc(groups_str.size() + 1));
+                if (new_secentity.grps) {
+                    memcpy(new_secentity.grps, groups_str.c_str(), groups_str.size());
+                    new_secentity.grps[groups_str.size()] = '\0';
+                }
+                group_success = true;
+            }
 
-        mapping_success = (access_rules->get_authz_strategy() & IssuerAuthz::Mapping) && !username.empty();
-        scope_success = (access_rules->get_authz_strategy() & IssuerAuthz::Capability) && access_rules->apply(oper, path);
-        if (scope_success && (m_log.getMsgMask() & LogMask::Debug)) {
-            std::stringstream ss;
-            ss << "Grant authorization based on scopes for operation=" << OpToName(oper) << ", path=" << path;
-            m_log.Log(LogMask::Debug, "Access", ss.str().c_str());
-        }
+            std::string username;
+            bool mapping_success = false;
+            bool scope_success = false;
+            username = access_rules->get_username(path_view);
+
+            mapping_success = (access_rules->get_authz_strategy() & IssuerAuthz::Mapping) && !username.empty();
+            scope_success = (access_rules->get_authz_strategy() & IssuerAuthz::Capability) && access_rules->apply(oper, path_view);
+            if (scope_success && (m_log.getMsgMask() & LogMask::Debug)) {
+                std::stringstream ss;
+                ss << "Grant authorization based on scopes for operation=" << OpToName(oper) << ", path=" << path;
+                m_log.Log(LogMask::Debug, "Access", ss.str().c_str());
+            }
 
-        if (!scope_success && !mapping_success && !group_success) {
-            auto returned_accs = OnMissing(&new_secentity, path, oper, env);
-            // Clean up the new_secentity
-            if (new_secentity.vorg != nullptr) free(new_secentity.vorg);
-            if (new_secentity.grps != nullptr) free(new_secentity.grps);
-            if (new_secentity.role != nullptr) free(new_secentity.role);
+            if (!scope_success && !mapping_success && !group_success) {
+                auto returned_accs = OnMissing(&new_secentity, path, oper, env);
+                // Clean up the new_secentity
+                if (new_secentity.vorg != nullptr) free(new_secentity.vorg);
+                if (new_secentity.grps != nullptr) free(new_secentity.grps);
+                if (new_secentity.role != nullptr) free(new_secentity.role);
 
-            return returned_accs;
-        }
+                return returned_accs;
+            }
 
-        // Default user only applies to scope-based mappings.
-        if (scope_success && username.empty()) {
-            username = access_rules->get_default_username();
-        }
+            // Default user only applies to scope-based mappings.
+            if (scope_success && username.empty()) {
+                username = access_rules->get_default_username();
+            }
 
-        // Setting the request.name will pass the username to the next plugin.
-        // Ensure we do that only if map-based or scope-based authorization worked.
-        if (scope_success || mapping_success) {
-            // Set scitokens.name in the extra attribute
-            Entity->eaAPI->Add("request.name", username, true);
-            new_secentity.eaAPI->Add("request.name", username, true);
-            m_log.Log(LogMask::Debug, "Access", "Request username", username.c_str());
-        }
+            // Setting the request.name will pass the username to the next plugin.
+            // Ensure we do that only if map-based or scope-based authorization worked.
+            if (scope_success || mapping_success) {
+                // Set scitokens.name in the extra attribute
+                Entity->eaAPI->Add("request.name", username, true);
+                new_secentity.eaAPI->Add("request.name", username, true);
+                m_log.Log(LogMask::Debug, "Access", "Request username", username.c_str());
+            }
 
-            // Make the token subject available.  Even though it's a reasonably bad idea
-            // to use for *authorization* for file access, there may be other use cases.
-            // For example, the combination of (vorg, token.subject) is a reasonable
-            // approximation of a unique 'entity' (either person or a robot) and is
-            // more reasonable to use for resource fairshare in XrdThrottle.
-        const auto &token_subject = access_rules->get_token_subject();
-        if (!token_subject.empty()) {
-            Entity->eaAPI->Add("token.subject", token_subject, true);
-        }
+                // Make the token subject available.  Even though it's a reasonably bad idea
+                // to use for *authorization* for file access, there may be other use cases.
+                // For example, the combination of (vorg, token.subject) is a reasonable
+                // approximation of a unique 'entity' (either person or a robot) and is
+                // more reasonable to use for resource fairshare in XrdThrottle.
+            const auto &token_subject = access_rules->get_token_subject();
+            if (!token_subject.empty()) {
+                Entity->eaAPI->Add("token.subject", token_subject, true);
+            }
 
-        // When the scope authorized this access, allow immediately.  Otherwise, chain
-        XrdAccPrivs returned_op = scope_success ? AddPriv(oper, XrdAccPriv_None) : OnMissing(&new_secentity, path, oper, env);
+            // When the scope authorized this access, allow immediately.  Otherwise, chain
+            XrdAccPrivs returned_op = scope_success ? AddPriv(oper, XrdAccPriv_None) : OnMissing(&new_secentity, path, oper, env);
 
-        // Since we are doing an early return, insert token info into the
-        // monitoring stream if monitoring is in effect and access granted
-        //
-        if (Entity->secMon && scope_success && returned_op && Mon_isIO(oper))
-           Mon_Report(new_secentity, token_subject, username);
+            // Since we are doing an early return, insert token info into the
+            // monitoring stream if monitoring is in effect and access granted
+            //
+            if (Entity->secMon && scope_success && returned_op && Mon_isIO(oper))
+            Mon_Report(new_secentity, token_subject, username);
 
-        // Cleanup the new_secentry
-        if (new_secentity.vorg != nullptr) free(new_secentity.vorg);
-        if (new_secentity.grps != nullptr) free(new_secentity.grps);
-        if (new_secentity.role != nullptr) free(new_secentity.role);
+            // Cleanup the new_secentry
+            if (new_secentity.vorg != nullptr) free(new_secentity.vorg);
+            if (new_secentity.grps != nullptr) free(new_secentity.grps);
+            if (new_secentity.role != nullptr) free(new_secentity.role);
+            return returned_op;
+        }
 
-        return returned_op;
+        // We iterated through all available credentials and none provided authorization; fall back
+        return OnMissing(Entity, path, oper, env);
     }
 
     virtual  Issuers IssuerList() override
@@ -753,12 +765,12 @@ private:
         return XrdAccPriv_None;
     }
 
-    bool GenerateAcls(const std::string &authz, uint64_t &cache_expiry, AccessRulesRaw &rules, std::string &username, std::string &token_subject, std::string &issuer, std::vector<MapRule> &map_rules, std::vector<std::string> &groups, uint32_t &authz_strategy) {
+    bool GenerateAcls(const std::string_view &authz, uint64_t &cache_expiry, AccessRulesRaw &rules, std::string &username, std::string &token_subject, std::string &issuer, std::vector<MapRule> &map_rules, std::vector<std::string> &groups, uint32_t &authz_strategy, AuthzSetting &acceptable_authz) {
         // Does this look like a JWT?  If not, bail out early and
         // do not pollute the log.
         bool looks_good = true;
         int separator_count = 0;
-        for (auto cur_char = authz.c_str(); *cur_char; cur_char++) {
+        for (auto cur_char = authz.data(); *cur_char; cur_char++) {
             if (*cur_char == '.') {
                 separator_count++;
                 if (separator_count > 2) {
@@ -783,7 +795,7 @@ private:
         char *err_msg;
         SciToken token = nullptr;
         pthread_rwlock_rdlock(&m_config_lock);
-        auto retval = scitoken_deserialize(authz.c_str(), &token, &m_valid_issuers_array[0], &err_msg);
+        auto retval = scitoken_deserialize(authz.data(), &token, &m_valid_issuers_array[0], &err_msg);
         pthread_rwlock_unlock(&m_config_lock);
         if (retval) {
             // This originally looked like a JWT so log the failure.
@@ -991,6 +1003,7 @@ private:
         username = std::move(tmp_username);
         issuer = std::move(token_issuer);
         groups = std::move(groups_parsed);
+        acceptable_authz = config.m_acceptable_authz;
 
         return true;
     }
@@ -1128,6 +1141,33 @@ private:
         return true;
     }
 
+    // A helper function for parsing one of the authorization setting variables (required_authz, acceptable_authz).
+    // The result object is only changed if the variable is set to a non-empty string in the configuration.
+    //
+    // Returns false on failure.
+    bool ParseAuthzSetting(OverrideINIReader &reader, const std::string &section, const std::string &variable, AuthzSetting &result) {
+        auto authz_setting_str = reader.Get(section, variable, "");
+        AuthzSetting authz_setting(AuthzSetting::None);
+        if (authz_setting_str == "") {
+            return true;
+        } else if (authz_setting_str == "none") {
+            authz_setting = AuthzSetting::None;
+        } else if (authz_setting_str == "all") {
+            authz_setting = AuthzSetting::All;
+        } else if (authz_setting_str == "read") {
+            authz_setting = AuthzSetting::Read;
+        } else if (authz_setting_str == "write") {
+            authz_setting = AuthzSetting::Write;
+        } else {
+            std::stringstream ss;
+            ss << "Failed to parse " << variable << " in section " << section << ": unknown authorization setting " << authz_setting_str;
+            m_log.Log(LogMask::Error, "Reconfig", ss.str().c_str());
+            return false;
+        }
+        result = authz_setting;
+        return true;
+    }
+
     bool Reconfig()
     {
         errno = 0;
@@ -1272,6 +1312,14 @@ private:
             auto username_claim = reader.Get(section, "username_claim", "");
             auto groups_claim = reader.Get(section, "groups_claim", "wlcg.groups");
 
+            AuthzSetting required_authz(AuthzSetting::None), acceptable_authz(AuthzSetting::All);
+            if (!ParseAuthzSetting(reader, section, "required_authorization", required_authz)) {
+                m_log.Log(LogMask::Error, "Reconfig", "Ignoring required_authorization and using default of 'none'");
+            }
+            if (!ParseAuthzSetting(reader, section, "acceptable_authorization", acceptable_authz)) {
+                m_log.Log(LogMask::Error, "Reconfig", "Ignoring acceptable_authorization and using default of 'all'");
+            }
+
             auto authz_strategy_str = reader.Get(section, "authorization_strategy", "");
             uint32_t authz_strategy = 0;
             if (authz_strategy_str.empty()) {
@@ -1295,7 +1343,33 @@ private:
             issuers.emplace(std::piecewise_construct,
                             std::forward_as_tuple(issuer),
                             std::forward_as_tuple(name, issuer, base_paths, restricted_paths,
-                                                  map_subject, authz_strategy, default_user, username_claim, groups_claim, rules));
+                                                  map_subject, authz_strategy, default_user, username_claim, groups_claim, rules,
+                                                  acceptable_authz, required_authz));
+
+            // If this is an issuer that is required for authorization, calculate the paths that it is
+            // responsible for.
+            if (required_authz != AuthzSetting::None) {
+                AccessRulesRaw rules;
+                for (const auto &base_path : base_paths) {
+                    if (restricted_paths.empty()) {
+                        restricted_paths.emplace_back("/");
+                    }
+                    for (const auto &restricted_path : restricted_paths) {
+                        auto full_path = base_path + "/" + restricted_path;
+                        std::string cleaned_path;
+                        MakeCanonical(full_path, cleaned_path);
+                        if (required_authz == AuthzSetting::Read || required_authz == AuthzSetting::All) {
+                            rules.emplace_back(AOP_Read, cleaned_path);
+                            rules.emplace_back(AOP_Stat, cleaned_path);
+                        } else if (required_authz == AuthzSetting::Write || required_authz == AuthzSetting::All) {
+                            rules.emplace_back(AOP_Create, cleaned_path);
+                            rules.emplace_back(AOP_Mkdir, cleaned_path);
+                            rules.emplace_back(AOP_Stat, cleaned_path);
+                        }
+                    }
+                }
+                m_required_issuers.emplace_back(std::make_unique<SubpathMatch>(rules), issuer);
+            }
         }
 
         if (issuers.empty()) {
@@ -1349,10 +1423,13 @@ private:
     pthread_rwlock_t m_config_lock;
     std::vector<std::string> m_audiences;
     std::vector<const char *> m_audiences_array;
-    std::map<std::string, std::shared_ptr<XrdAccRules>> m_map;
+    std::map<std::string, std::shared_ptr<XrdAccRules>, std::less<>> m_map; // Note: std::less<> is used as the comparator to enable transparent casting from std::string_view for key lookup
     XrdAccAuthorize* m_chain;
     const std::string m_parms;
     std::vector<const char*> m_valid_issuers_array;
+    // Authorization from these issuers are required for any matching path.  The map tracks the
+    // base prefix to the issuer URL.
+    std::vector<std::pair<std::unique_ptr<SubpathMatch>, std::string>> m_required_issuers;
     std::unordered_map<std::string, IssuerConfig> m_issuers;
     uint64_t m_next_clean{0};
     XrdSysError m_log;
diff --git a/src/XrdSciTokens/XrdSciTokensAccess.hh b/src/XrdSciTokens/XrdSciTokensAccess.hh
new file mode 100644
index 000000000..fa330a7d5
--- /dev/null
+++ b/src/XrdSciTokens/XrdSciTokensAccess.hh
@@ -0,0 +1,214 @@
+
+#include "XrdAcc/XrdAccAuthorize.hh"
+#include "XrdOuc/XrdOucPrivateUtils.hh"
+
+#include <memory>
+#include <string>
+#include <string_view>
+#include <vector>
+
+#include <string.h>
+
+/**
+ * Class and function definitions for the SciTokens plugin.
+ */
+
+typedef std::vector<std::pair<Access_Operation, std::string>> AccessRulesRaw;
+
+// Class representing a rule in the administrator-provided mapfile.
+// All predicates must match for the rule to apply.
+struct MapRule
+{
+    MapRule(const std::string &sub,
+            const std::string &username,
+            const std::string &path_prefix,
+            const std::string &group,
+            const std::string &result)
+        : m_sub(sub),
+          m_username(username),
+          m_path_prefix(path_prefix),
+          m_group(group),
+          m_result(result)
+    {
+        //std::cerr << "Making a rule {sub=" << sub << ", username=" << username << ", path=" << path_prefix << ", group=" << group << ", result=" << name << "}" << std::endl;
+    }
+
+    const std::string match(const std::string &sub,
+                            const std::string &username,
+                            const std::string_view &req_path,
+                            const std::vector<std::string> &groups) const
+    {
+        if (!m_sub.empty() && sub != m_sub) {return "";}
+
+        if (!m_username.empty() && username != m_username) {return "";}
+
+        if (!m_path_prefix.empty() &&
+            strncmp(req_path.data(), m_path_prefix.c_str(), m_path_prefix.size()))
+        {
+            return "";
+        }
+
+        if (!m_group.empty()) {
+            for (const auto &group : groups) {
+                if (group == m_group)
+                    return m_result;
+            }
+            return "";
+        }
+        return m_result;
+    }
+
+    std::string m_sub;
+    std::string m_username;
+    std::string m_path_prefix;
+    std::string m_group;
+    std::string m_result;
+};
+
+// Control whether a given issuer is required for the paths it authorizes
+enum class AuthzSetting {
+    None, // Issuer's authorization is not necessary
+    Read, // Authorization from this issuer is necessary for reads.
+    Write, // Authorization from this issuer is necessary for writes.
+    All, // Authorization from this issuer is necessary for all operations.
+};
+
+// Controls what part of the token is used to determine a positive authorization.
+//
+// E.g., if IssuerAuthz::Group is set, then the positive authorization may be based
+// on the groups embedded in the token.
+enum IssuerAuthz {
+    Capability = 0x01,
+    Group = 0x02,
+    Mapping = 0x04,
+    Default = 0x07
+};
+
+// Given a list of access rules, this class determines whether a requested operation / path
+// is permitted by the access rules.
+class SubpathMatch final {
+public:
+    SubpathMatch() = default;
+    SubpathMatch(const AccessRulesRaw &rules)
+    : m_rules(rules)
+    {}
+
+    // Determine whether the known access rules permit the requested `oper` on `path`.
+    bool apply(Access_Operation oper, const std::string_view path) const {
+
+        for (const auto & rule : m_rules) {
+            // Skip rules that don't match the current operation
+            if (rule.first != oper)
+                continue;
+
+            // If the rule allows any path, allow the operation
+            if (rule.second == "/")
+                return true;
+
+            // Allow operation if path is a subdirectory of the rule's path
+            if (is_subdirectory(rule.second, path)) {
+                return true;
+            } else {
+                // Allow stat and mkdir of parent directories to comply with WLCG token specs
+                if (oper == AOP_Stat || oper == AOP_Mkdir)
+                if (is_subdirectory(path, rule.second))
+                    return true;
+            }
+        }
+        return false;
+    }
+
+    bool empty() const {return m_rules.empty();} // Returns true if there are no rules to match
+
+    std::string str() const; // Returns a human-friendly representation of the access rules
+
+    size_t size() const {return m_rules.size();} // Returns the count of rules
+private:
+
+    AccessRulesRaw m_rules;
+};
+
+/**
+ * A class that encapsulates the access rules generated from a token.
+ * 
+ * The access rules are generated from the token's claims; the object
+ * is intended to be kept in a cache and periodically checked for expiration.
+ */
+class XrdAccRules
+{
+public:
+    XrdAccRules(uint64_t expiry_time, const std::string &username, const std::string &token_subject,
+        const std::string &issuer, const std::vector<MapRule> &rules, const std::vector<std::string> &groups,
+        uint32_t authz_strategy, AuthzSetting acceptable_authz) :
+        m_authz_strategy(authz_strategy),
+        m_acceptable_authz(acceptable_authz),
+        m_expiry_time(expiry_time),
+        m_username(username),
+        m_token_subject(token_subject),
+        m_issuer(issuer),
+        m_map_rules(rules),
+        m_groups(groups)
+    {}
+
+    ~XrdAccRules() {}
+
+    bool apply(Access_Operation oper, const std::string_view path) {
+        return m_matcher.apply(oper, path);
+    }
+
+    // Check to see if the access rules generated for this token have expired
+    bool expired() const;
+
+    void parse(const AccessRulesRaw &rules) {
+        m_matcher = SubpathMatch(rules);
+    }
+
+    std::string get_username(const std::string_view &req_path) const
+    {
+        for (const auto &rule : m_map_rules) {
+            std::string name = rule.match(m_token_subject, m_username, req_path, m_groups);
+            if (!name.empty()) {
+                return name;
+            }
+        }
+        return "";
+    }
+
+    const std::string str() const;
+
+        // Return the token's subject, an opaque unique string within the issuer's
+        // namespace.  It may or may not be related to the username one should
+        // use within the authorization framework.
+    const std::string & get_token_subject() const {return m_token_subject;}
+    const std::string & get_default_username() const {return m_username;}
+    const std::string & get_issuer() const {return m_issuer;}
+
+    uint32_t get_authz_strategy() const {return m_authz_strategy;}
+    bool acceptable_authz(Access_Operation oper) const {
+        if (m_acceptable_authz == AuthzSetting::All) return true;
+        if (m_acceptable_authz == AuthzSetting::None) return false;
+
+        bool is_read = oper == AOP_Read || oper == AOP_Readdir || oper == AOP_Stat;
+        if (is_read) return m_acceptable_authz == AuthzSetting::Read;
+        else return m_acceptable_authz == AuthzSetting::Write;
+    }
+
+    size_t size() const {return m_matcher.size();}
+    const std::vector<std::string> &groups() const {return m_groups;}
+
+private:
+    const uint32_t m_authz_strategy;
+    const AuthzSetting m_acceptable_authz;
+    SubpathMatch m_matcher;
+    const uint64_t m_expiry_time{0};
+    const std::string m_username;
+    const std::string m_token_subject;
+    const std::string m_issuer;
+    const std::vector<MapRule> m_map_rules;
+    const std::vector<std::string> m_groups;
+};
+
+bool AuthorizesRequiredIssuers(Access_Operation client_oper, const std::string_view &path,
+    const std::vector<std::pair<std::unique_ptr<SubpathMatch>, std::string>> &required_issuers,
+    const std::vector<std::shared_ptr<XrdAccRules>> &access_rules_list);
+
diff --git a/tests/XRootD/scitokens-module.cfg b/tests/XRootD/scitokens-module.cfg
index 795b97289..014e61f32 100644
--- a/tests/XRootD/scitokens-module.cfg
+++ b/tests/XRootD/scitokens-module.cfg
@@ -3,4 +3,10 @@ audience = https://localhost:7095
 
 [Issuer test]
 issuer = https://localhost:7095/issuer/one
-base_path = /protected
+base_path = /protected, /dual
+
+[Issuer test2]
+issuer = https://localhost:7095/issuer/two
+base_path = /dual
+required_authorization = all
+acceptable_authorization = none
diff --git a/tests/XRootD/scitokens.sh b/tests/XRootD/scitokens.sh
index e0bc4bd5a..0fa4b8599 100755
--- a/tests/XRootD/scitokens.sh
+++ b/tests/XRootD/scitokens.sh
@@ -9,6 +9,8 @@ function setup_scitokens() {
 	echo 'Hello, World' > scitokens/xrootd/protected/hello_world.txt
 	mkdir -p scitokens/xrootd/localhost
 	echo 'Hello, World' > scitokens/xrootd/localhost/hello_world.txt
+	mkdir -p "$PWD/scitokens/xrootd/dual"
+	echo 'Hello, World' > "$PWD/scitokens/xrootd/dual/hello_world.txt"
 
 	# Override the scitoken cache location; otherwise, contents of prior test runs may be cached
 	XDG_CACHE_HOME="${NAME}/cache"
@@ -41,6 +43,13 @@ function setup_scitokens() {
 	fi
 	chmod 0600 "$OUTPUTDIR/token_modify"
 
+	# Create an issuer-two read token
+	if ! xrdscitokens-create-token issuer_pub_2.pem issuer_key_2.pem test_2 \
+		"https://localhost:7095/issuer/two" storage.read:/ > "$OUTPUTDIR/token_two"; then
+		echo "Failed to create second 'storage.read' token from issuer two"
+		exit 1
+	fi
+
 	popd || exit 1
 }
 
@@ -139,4 +148,16 @@ function test_scitokens() {
 	# Re-uploading $HOST/protected/subdir_modify/hello_world.txt with modify token (expected 201)
 	execute_curl "$HOST/protected/subdir_modify/hello_world.txt" 201 'hello, world' scitokens/token_modify PUT
 	execute_curl "$HOST/protected/subdir_modify/hello_world.txt" 200 'hello, world' scitokens/token
+
+	###
+	## Tests for requiring multiple tokens to authorize an operation
+	###
+	execute_curl "$HOST/dual/hello_world.txt" 403 "" scitokens/token
+	execute_curl "$HOST/dual/hello_world.txt" 403 "" scitokens/token_two
+	execute_curl "$HOST/dual/hello_world.txt?access_token=$(cat scitokens/token)" 200 "" scitokens/token_two
+
+	HOST="roots://localhost:${XRD_PORT}/"
+	export BEARER_TOKEN_FILE=scitokens/token
+	assert xrdcp -f "$HOST/dual/hello_world.txt?authz=$(cat scitokens/token_two)" .
+	assert_eq "Hello, World" "$(cat hello_world.txt)"
 }
diff --git a/tests/XrdOucTests/CMakeLists.txt b/tests/XrdOucTests/CMakeLists.txt
index b7f3e09e2..4a5a33ce3 100644
--- a/tests/XrdOucTests/CMakeLists.txt
+++ b/tests/XrdOucTests/CMakeLists.txt
@@ -1,4 +1,4 @@
-add_executable(xrdoucutils-unit-tests XrdOucUtilsTests.cc)
+add_executable(xrdoucutils-unit-tests XrdOucUtilsTests.cc XrdOucEnvTests.cc)
 
 target_link_libraries(xrdoucutils-unit-tests XrdUtils GTest::GTest GTest::Main)
 
diff --git a/tests/XrdOucTests/XrdOucEnvTests.cc b/tests/XrdOucTests/XrdOucEnvTests.cc
new file mode 100644
index 000000000..ac8fe6da6
--- /dev/null
+++ b/tests/XrdOucTests/XrdOucEnvTests.cc
@@ -0,0 +1,28 @@
+
+#include "XrdOuc/XrdOucEnv.hh"
+
+#include <gtest/gtest.h>
+
+static const std::pair<std::string, std::string> env_tests[] = {
+    {"foo=bar", "&foo=bar"},
+    {"authz=bar", "&"},
+    {"authz=bar&foo=1", "&foo=1"},
+    {"&authz=bar&authz=1", "&"},
+    {"authz=bar&authz=1", "&"},
+    {"&authz=bar", "&"},
+    {"&access_token=bar", "&"},
+    {"foo=1&authz=bar", "&foo=1"},
+    {"foo=1&authz=foo&access_token=bar", "&foo=1"},
+    {"authz=foo&access_token=bar", "&"},
+    {"authz=foo&foo=bar", "&foo=bar"},
+    {"authz=foo&foo=bar&access_token=3", "&foo=bar"},
+    {"authz=1&access_token=2&authz=3&access_token=4", "&"},
+};
+
+TEST(XrdOucEnv, EnvTidy) {
+    for (const auto &env_str : env_tests) {
+        int envlen;
+        XrdOucEnv env(env_str.first.c_str(), env_str.first.size());
+        ASSERT_STREQ(env_str.second.c_str(), env.EnvTidy(envlen)) << "Testing tidy of " << env_str.first;
+    }	    
+}
diff --git a/tests/XrdOucTests/XrdOucUtilsTests.cc b/tests/XrdOucTests/XrdOucUtilsTests.cc
index 5d0311156..bc614c5af 100644
--- a/tests/XrdOucTests/XrdOucUtilsTests.cc
+++ b/tests/XrdOucTests/XrdOucUtilsTests.cc
@@ -99,13 +99,16 @@ static const std::string plain_urls[] = {
 
 static const std::string authz_strings[] = {
   "authz=REDACTED",
+  "access_token=REDACTED",
   " authz=REDACTED ",
   " 'authz=REDACTED' ",
   " \"authz=REDACTED\" ",
   "authz=REDACTED&scitag.flow=144&test=abcd",
+  "access_token=REDACTED&scitag.flow=144&test=abcd",
   "scitag.flow=144&authz=REDACTED&test=abcd",
   "scitag.flow=144&test=abcd&authz=REDACTED",
   "authz=REDACTED&test=test2&authz=REDACTED",
+  "authz=REDACTED&test=test2&access_token=REDACTED",
   "authz=REDACTED&test=test2&authz=REDACTED&authz=REDACTED&test=test2&authz=REDACTED",
   "/path/test.txt?scitag.flow=44&authz=REDACTED done close.",
   "/path/test.txt?authz=REDACTED&scitag.flow=44 done close.",
diff --git a/tests/scitokens/CMakeLists.txt b/tests/scitokens/CMakeLists.txt
index 733c275cd..16d2ef56d 100644
--- a/tests/scitokens/CMakeLists.txt
+++ b/tests/scitokens/CMakeLists.txt
@@ -6,6 +6,15 @@ add_executable(xrdscitokens-create-token XrdScitokensCreateToken.cc)
 target_link_libraries(xrdscitokens-create-token PRIVATE ${SCITOKENS_CPP_LIBRARIES})
 target_include_directories(xrdscitokens-create-token PRIVATE ${SCITOKENS_CPP_INCLUDE_DIR})
 
+add_executable(xrdscitokens-unit-tests
+  XrdSciTokens.cc
+)
+
+target_link_libraries(xrdscitokens-unit-tests
+  XrdSciTokensObj GTest::GTest GTest::Main)
+
+gtest_discover_tests(xrdscitokens-unit-tests)
+
 add_test(NAME SciTokens::setup
   COMMAND sh -c "${CMAKE_CURRENT_SOURCE_DIR}/setup.sh ${CMAKE_BINARY_DIR}/tests/issuer")
 
diff --git a/tests/scitokens/XrdSciTokens.cc b/tests/scitokens/XrdSciTokens.cc
new file mode 100644
index 000000000..9f85263c4
--- /dev/null
+++ b/tests/scitokens/XrdSciTokens.cc
@@ -0,0 +1,73 @@
+
+#include "XrdSciTokens/XrdSciTokensAccess.hh"
+
+#include <gtest/gtest.h>
+
+TEST(XrdSciTokens, MapRule) {
+  MapRule rule("subject", "user", "/prefix", "group", "result");
+  ASSERT_EQ("", rule.match("not subject", "not user", "/foo", {"not group"}));
+  ASSERT_EQ("", rule.match("subject", "not user", "/foo", {"not group"}));
+  ASSERT_EQ("", rule.match("subject", "not user", "/foo", {"not group"}));
+  ASSERT_EQ("", rule.match("not subject", "user", "/foo", {"not group"}));
+  ASSERT_EQ("", rule.match("not subject", "not user", "/prefix/baz", {"not group"}));
+  ASSERT_EQ("", rule.match("not subject", "not user", "/foo", {"group"}));
+  ASSERT_EQ("result", rule.match("subject", "user", "/prefix/foo", {"group"}));
+  ASSERT_EQ("result", rule.match("subject", "user", "/prefix/foo", {"not group", "group"}));
+}
+
+TEST(XrdSciTokens, SubpathMatch) {
+  SubpathMatch matcher({{AOP_Read, "/prefix"}});
+  ASSERT_EQ(false, matcher.apply(AOP_Read, "/prefix1"));
+  ASSERT_EQ(false, matcher.apply(AOP_Create, "/prefix"));
+  ASSERT_EQ(true, matcher.apply(AOP_Read, "/prefix"));
+  ASSERT_EQ(true, matcher.apply(AOP_Read, "/prefix/foo"));
+
+  // Test handling of root paths
+  matcher = SubpathMatch({{AOP_Create, "/"}});
+  ASSERT_EQ(true, matcher.apply(AOP_Create, "/bar/baz"));
+  ASSERT_EQ(false, matcher.apply(AOP_Stat, "/bar/baz"));
+
+  // Test special handling of parent prefixes
+  matcher = SubpathMatch({{AOP_Stat, "/foo/bar"}});
+  ASSERT_EQ(true, matcher.apply(AOP_Stat, "/foo"));
+  ASSERT_EQ(false, matcher.apply(AOP_Read, "/foo"));
+  matcher = SubpathMatch({{AOP_Mkdir, "/foo/bar"}});
+  ASSERT_EQ(true, matcher.apply(AOP_Mkdir, "/foo"));
+  ASSERT_EQ(1, matcher.size());
+  ASSERT_FALSE(matcher.empty());
+  ASSERT_EQ("/foo/bar:mkdir", matcher.str());
+
+  matcher = SubpathMatch();
+  ASSERT_EQ(0, matcher.size());
+  ASSERT_TRUE(matcher.empty());
+}
+
+
+TEST(XrdSciTokens, AuthorizesRequiredIssuers) {
+  AccessRulesRaw rules{{AOP_Read, "/prefix"}, {AOP_Mkdir, "/prefix2/nested"}};
+  auto matcher = std::make_unique<SubpathMatch>(rules);
+  std::vector<std::pair<std::unique_ptr<SubpathMatch>, std::string>> required_issuers;
+  required_issuers.emplace_back(std::move(matcher), "https://example.com");
+
+  auto access_rule_entry_ptr = new XrdAccRules(0, "username", "token_sub", "https://example.com", {}, {}, IssuerAuthz::Capability, AuthzSetting::None);
+  std::shared_ptr<XrdAccRules> access_rule_entry(access_rule_entry_ptr);
+  access_rule_entry->parse({{AOP_Read, "/prefix"}});
+
+  access_rule_entry_ptr = new XrdAccRules(0, "username", "token_sub", "https://example-other.com", {}, {}, IssuerAuthz::Capability, AuthzSetting::None);
+  std::shared_ptr<XrdAccRules> access_rule_entry_other(access_rule_entry_ptr);
+  access_rule_entry_other->parse({{AOP_Read, "/prefix"}});
+
+  ASSERT_EQ(true, AuthorizesRequiredIssuers(AOP_Read, "/prefix/foo", required_issuers, {access_rule_entry}));
+  ASSERT_EQ(true, AuthorizesRequiredIssuers(AOP_Read, "/foo", required_issuers, {access_rule_entry}));
+  ASSERT_EQ(false, AuthorizesRequiredIssuers(AOP_Read, "/prefix/foo", required_issuers, {access_rule_entry_other}));
+  ASSERT_EQ(false, AuthorizesRequiredIssuers(AOP_Read, "/prefix", required_issuers, {access_rule_entry_other}));
+  ASSERT_EQ(true, AuthorizesRequiredIssuers(AOP_Read, "/prefix2", required_issuers, {access_rule_entry_other}));
+  ASSERT_EQ(true, AuthorizesRequiredIssuers(AOP_Create, "/prefix/foo", required_issuers, {access_rule_entry_other}));
+  ASSERT_EQ(true, AuthorizesRequiredIssuers(AOP_Mkdir, "/prefix", required_issuers, {access_rule_entry_other}));
+  ASSERT_EQ(true, AuthorizesRequiredIssuers(AOP_Mkdir, "/prefix", required_issuers, {access_rule_entry}));
+  ASSERT_EQ(false, AuthorizesRequiredIssuers(AOP_Mkdir, "/prefix2", required_issuers, {access_rule_entry}));
+
+  required_issuers.emplace_back(std::make_unique<SubpathMatch>(rules), "https://example-other.com");
+  ASSERT_EQ(false, AuthorizesRequiredIssuers(AOP_Read, "/prefix/foo", required_issuers, {access_rule_entry}));
+  ASSERT_EQ(true, AuthorizesRequiredIssuers(AOP_Read, "/prefix/foo", required_issuers, {access_rule_entry, access_rule_entry_other}));
+}
\ No newline at end of file
-- 
2.34.1

