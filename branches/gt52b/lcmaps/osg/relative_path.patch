diff -ur lcmaps-1.4.31/configure.ac lcmaps-1.4.33/configure.ac
--- lcmaps-1.4.31/configure.ac	2011-09-08 05:19:33.000000000 -0500
+++ lcmaps-1.4.33/configure.ac	2011-09-20 02:30:52.000000000 -0500
@@ -511,6 +511,19 @@
 AC_SUBST([LCMAPS_ETC_HOME], [${sysconfdir}/lcmaps])
 AC_SUBST([LCMAPS_LIB_HOME], [$libdir])
 
+dnl allow the setting of a different path for the LCMAPS plug-ins
+dnl Makefiles should set the plugindir to $MODULEDIR.
+AC_ARG_WITH([lcmaps_moduledir],
+    [AS_HELP_STRING([--with-lcmaps-moduledir=DIR],
+                    [Specify the default install location of the LCMAPS plug-ins, when relative: prefix with LIBDIR [default=LIBDIR/lcmaps]])],
+    [AS_IF([test "x`echo $withval|cut -c1`" = "x/" ],
+	[AC_SUBST([LCMAPS_MOD_HOME], [$withval])], dnl Absolute path
+	[AC_SUBST([LCMAPS_MOD_HOME], [$LCMAPS_LIB_HOME/$withval])])
+    ],
+    [AC_SUBST([LCMAPS_MOD_HOME], [$LCMAPS_LIB_HOME/lcmaps])]
+)
+AC_MSG_RESULT([LCMAPS_MOD_HOME set to $LCMAPS_MOD_HOME])
+
 # Configuration items
 AC_CONFIG_FILES([Makefile])
 AC_CONFIG_FILES([doc/Makefile])
diff -ur lcmaps-1.4.31/src/Makefile.am lcmaps-1.4.33/src/Makefile.am
--- lcmaps-1.4.31/src/Makefile.am	2011-09-08 05:19:30.000000000 -0500
+++ lcmaps-1.4.33/src/Makefile.am	2011-09-20 02:30:49.000000000 -0500
@@ -25,7 +25,8 @@
 
 DEFINESCOMPILEFLAGS = \
 	-D'LCMAPS_ETC_HOME="@LCMAPS_ETC_HOME@"' \
-	-D'LCMAPS_LIB_HOME="@LCMAPS_LIB_HOME@"'
+	-D'LCMAPS_LIB_HOME="@LCMAPS_LIB_HOME@"' \
+	-D'LCMAPS_MOD_HOME="@LCMAPS_MOD_HOME@"'
 
 AM_YFLAGS=-d
 
diff -ur lcmaps-1.4.31/src/evaluationmanager/evaluationmanager.c lcmaps-1.4.33/src/evaluationmanager/evaluationmanager.c
--- lcmaps-1.4.31/src/evaluationmanager/evaluationmanager.c	2011-09-08 05:19:30.000000000 -0500
+++ lcmaps-1.4.33/src/evaluationmanager/evaluationmanager.c	2011-09-20 02:30:49.000000000 -0500
@@ -148,8 +148,6 @@
 {
   const plugin_t* p_list, *tmp_p_list;
   lcmaps_db_entry_t* p=0;
-  int path_length;
-  char* path;
   BOOL string_too_long;
 
   string_too_long = FALSE;
@@ -163,22 +161,6 @@
   /*  Set to a safe default value.  */
   *plugins = 0;
 
-  if (!lcmaps_pdl_path()) {
-    lcmaps_log(1, "Initialization of the EvaluationManager either failed or was not done.\n");
-    return -1; 
-  }
-
-  path = strdup(lcmaps_pdl_path());
-  path_length = strlen(path);
-
-  if (path_length>0 && path[path_length-1] != '/') {
-    path = (char *)realloc(path, path_length+2);
-    path[path_length] = '/';
-    path[path_length+1] = '\0';
-
-    path_length = strlen(path);
-  }
-
   p_list = lcmaps_get_plugins();
 
   while (p_list) {
@@ -191,10 +173,8 @@
     }
 
     /*  Copy the name and arguments while respecting max. lengths.  */
-    strncpy(p->pluginname, path, LCMAPS_MAXPATHLEN);
-    strncpy(p->pluginname+path_length, p_list->name, LCMAPS_MAXPATHLEN-path_length);
-
-    if ((strlen(path) + strlen(p_list->name))>=LCMAPS_MAXPATHLEN) {
+    strncpy(p->pluginname, p_list->name, LCMAPS_MAXPATHLEN);
+    if (strlen(p_list->name)>=LCMAPS_MAXPATHLEN) {
       lcmaps_log(1, "String too long to copy. Max length = %d\n", LCMAPS_MAXPATHLEN);
       string_too_long = TRUE;
     }
@@ -223,8 +203,6 @@
     lcmaps_log_debug(1, "%s\n", p->pluginargs);
   }
 
-  free(path);
-
   global_plugin_list = *plugins;
 
   return string_too_long ? -1 : 0;
@@ -250,6 +228,8 @@
     int rc = 0;
 
     result = EVALUATION_START;
+    /* Note: lcmaps_pdl_next_plugin nowadays returns the short pluginname,
+     * lcmaps_runPlugin will figure out the long one */
     while ((plugin_name = lcmaps_pdl_next_plugin(result)))
     {
         /* get active policy */
diff -ur lcmaps-1.4.31/src/evaluationmanager/pdl_lex.l lcmaps-1.4.33/src/evaluationmanager/pdl_lex.l
--- lcmaps-1.4.31/src/evaluationmanager/pdl_lex.l	2011-09-08 05:19:30.000000000 -0500
+++ lcmaps-1.4.33/src/evaluationmanager/pdl_lex.l	2011-09-20 02:30:49.000000000 -0500
@@ -31,40 +31,40 @@
 
 /*static int no_valid_rule=0;*/
 
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) \
+    lcmaps_warning(PDL_ERROR, "Fatal parsing error: %s", (msg));
+#endif
 %}
 
 ws           [\t ]+
 nl           \n
-term         [a-zA-Z_.0-9]+
-label        {term}:
+term         [a-zA-Z_\.0-9/]+
+label        ^[ \t]*[a-zA-Z_\.0-9/]+:
 trans        "->"
-comment      #
+comment      #[^\n]*\n
 tokens       [\~=\|]
 pvar         "path"
-%{
-/* subpath matches 0 or more . followed by / and non-whitespace, this matches
- * ./aap as ./ 
- * Under 'term' it would only match . so path gets precedence. Note further that
- * the original [\/\.][^\/ \t\n]* is not the same as that would only match the
- * single . at the beginning, like term, in which case 'term' gets precendence */
-%}
-path         \.*\/[^\/ \t\n]*
 pdlstr       \"[^\"\n]*[\"\n]
 
 
-%x linecom path pathcom mq
+%x path pathcom linecom mq
 %%
 
 {ws}         ;
-{pvar}       { return PVAR; }
-{term}       { if ((yylval.record = (record_t*)malloc(sizeof(record_t))))
-                 if (((yylval.record)->string = strdup(yytext))) {
-                   (yylval.record)->lineno = lineno;
-                   return TERM;
-                 }
-               lcmaps_warning(PDL_ERROR, "out of memory.");
-               return 0;
-             }
+{pvar}       { BEGIN path; return PVAR; }
+<path>{tokens}  { return yytext[0]; }
+<path>{ws}      ;
+<path>{term}    { if ((yylval.record = (record_t*)malloc(sizeof(record_t))))
+                     if (((yylval.record)->string = strdup(yytext))) {
+                        (yylval.record)->lineno = lineno;
+                       return PATH;
+                     }
+                  lcmaps_warning(PDL_ERROR, "out of memory.");
+                  return 0;
+                }
+<path>\n        { ++lineno; BEGIN INITIAL; }
+<path>{comment} { ++lineno; BEGIN INITIAL; }
 {label}      { yytext[yyleng-1] = '\0';   /* remove trailing ':' */
 
                /*  Check if this policy rule is allowed or not. */
@@ -83,35 +83,18 @@
                lcmaps_warning(PDL_ERROR, "out of memory.");
                return 0; 
              }
-{path}       { if ((yylval.record = (record_t *)malloc(sizeof(record_t))))
-                 if (((yylval.record)->string = strdup(yytext))) {
-                   (yylval.record)->lineno = lineno;
-                   BEGIN path;
-                   return PATH;
-                 }
-               lcmaps_warning(PDL_ERROR, "out of memory.");
-               return 0; 
-             }
-<path>{path} { if ((yylval.record = (record_t *)malloc(sizeof(record_t))))
+{term}       { if ((yylval.record = (record_t*)malloc(sizeof(record_t))))
                  if (((yylval.record)->string = strdup(yytext))) {
                    (yylval.record)->lineno = lineno;
-                   return PATH;
+                   return TERM;
                  }
                lcmaps_warning(PDL_ERROR, "out of memory.");
-               return 0; 
+               return 0;
              }
-<path>#      { BEGIN pathcom; }
-<path>[ \t]* ;
-<path>\n     { BEGIN INITIAL; yyless(0); return '\n'; }
-<path>.      { lcmaps_warning(PDL_ERROR, "unrecognized tokens in path name."); }
-<pathcom>.   ;
-<pathcom>\n  { BEGIN INITIAL; yyless(0); return '\n'; }
 {nl}         { ++lineno;          }
 {tokens}     { return yytext[0];  }
 {trans}      { return TRANS;      }
-{comment}    { BEGIN linecom;     }
-<linecom>.   ;
-<linecom>\n  { ++lineno; BEGIN INITIAL; }
+{comment}    { ++lineno;	  }
 {pdlstr}     { if ((yylval.record = (record_t*)malloc(sizeof(record_t)))) {
                  if (yytext[yyleng-2] == '\\') {
                    if (((yylval.record)->string = strdup(yytext+1))) {
diff -ur lcmaps-1.4.31/src/evaluationmanager/pdl_main.c lcmaps-1.4.33/src/evaluationmanager/pdl_main.c
--- lcmaps-1.4.31/src/evaluationmanager/pdl_main.c	2011-09-08 05:19:30.000000000 -0500
+++ lcmaps-1.4.33/src/evaluationmanager/pdl_main.c	2011-09-20 02:30:49.000000000 -0500
@@ -69,14 +69,10 @@
 #include "pdl_rule.h"
 
 static char* script_name        = NULL;           //!<  If non NULL, the name of the configuration script.
-/*static const char* d_path       = "/usr/lib";     //!<  Default path where plugins can be found.*/
-/* Don't use any default dir, it will be figured out using lcmaps_findfile() */
-static const char* d_path       = "";     //!<  Default path where plugins can be found.*/
 static char* path               = NULL;           //!<  Path where plugins can be found.
 static const char* undefined	= "(empty string)"; //!< String printed instead of (null)
 static int path_lineno          = 0;              //!<  Path line number.
 static plugin_t* top_plugin     = NULL;           //!<  First node of the list.
-static BOOL default_path        = TRUE;           //!<  Has the default value of the path been changed.
 static BOOL parse_error         = FALSE;          //!<  Tell if there have been any error during parsing.
 static char* level_str[PDL_SAME];                 //!<  When a message is printed, how do we spell warning in a given language.
 
@@ -143,12 +139,7 @@
   }
 
   /*  Set the default path  */
-  path = strdup(d_path);
-  if (path==NULL)   {
-      lcmaps_warning(PDL_ERROR, "Out of memory when setting path.");
-      return -1;
-  }
-  default_path = TRUE;
+  path = NULL;
 
   /*
    *  Check if there are plugins, if so clear top_plugin and free
@@ -434,15 +425,16 @@
 {
   _lcmaps_set_path(mypath);
 
-  free(mypath->string);
-  free(mypath);
+  if (mypath)	{
+    free(mypath->string);
+    free(mypath);
+  }
 }
 
 
 /*!
- *  Overwrite the default path with the new value. If this function is
- *  called more than once, a warning message is displayed for each
- *  occurent.
+ *  Set the path with the new value. If this function is called more than once,
+ *  a warning message is displayed for each occurent.
  *
  *  \param _path The new path.
  *
@@ -451,18 +443,28 @@
 {
   /* lcmaps_log_debug(1, "lcmaps_set_path: '%s'.\n", _path); */
 
-  if (!default_path) {
-    lcmaps_warning(PDL_ERROR, "path already defined in: %d; ignoring this instance.", path_lineno);
+  if (path!=NULL) {
+    lcmaps_warning(PDL_WARNING, "path already defined as %s in line: %d; ignoring this instance.", path, path_lineno);
     return;
   }
-
-  default_path = FALSE;
-  path_lineno  = _path->lineno;
-  path         = strdup(_path->string);
-  if (path==NULL)   {
-      lcmaps_warning(PDL_ERROR, "Out of memory when setting path.");
-      return;
-  }
+  if (_path!=NULL)  {  /* Only act when value is provided */
+      path_lineno  = _path->lineno;
+      if ((_path->string)[0]!='/') {	/* Relative path: prefix LCMAPS_LIB_HOME */
+	  path=calloc(strlen(LCMAPS_LIB_HOME)+strlen(_path->string)+2,sizeof(char));
+	  if (path==NULL)   {
+	      lcmaps_warning(PDL_ERROR, "Out of memory when setting path.");
+	      return;
+	  }
+	  sprintf(path,"%s/%s",LCMAPS_LIB_HOME,_path->string);
+      } else {
+	  path = strdup(_path->string);
+	  if (path==NULL)   {
+	     lcmaps_warning(PDL_ERROR, "Out of memory when setting path.");
+	     return;
+	  }
+      }
+      lcmaps_log_debug(LOG_DEBUG, "Modules search path is set to %s (line %d).\n", path, path_lineno);
+   }
 }
 
 
@@ -472,11 +474,8 @@
  */
 void lcmaps_free_path(void)
 {
-  if (!default_path && path) {
     free(path);
-    default_path = TRUE;
     path = NULL;
-  }
 }
 
 
@@ -602,6 +601,7 @@
   /* int rc       = 0; */
   char* string = NULL;
   char* state  = NULL;
+  char* tmp    = NULL;
 
   switch (status) {
   case EVALUATION_START:
@@ -681,37 +681,19 @@
   }
 
   /*
-   *  Create the full plugin name, i.e. including the path. The rules
-   *  do not specify the path, this must be added so that a single
-   *  string can be returned. State holde the current plugin name.
-   *
+   *  Create the plugin name from the plugin name+arguments as contained in
+   *  state. The absolute pluginname is contained in the absname and is
+   *  initialized in PluginInit via lcmaps_findplugin(). The part duplicates the
+   *  string and strips everything following the first space (i.e. arguments).
    */
   if (state) {
-    char* tmp;
-    int state_length, path_length;
-
-    tmp = state;
-    state_length = path_length = 0;
-
-    while (*tmp!=' ' && *tmp++!='\0') {
-      ++state_length;
-    }
-    path_length = strlen(lcmaps_pdl_path());
-
-    /*  Allocate memory and initialize the string.  */
-    string = (char*)malloc(state_length + path_length + 2);
-    if (string == NULL) {
-        lcmaps_warning(PDL_ERROR, "Out of memory.");
-        return NULL;
+    string=strdup(state);
+    if (string==NULL)   {
+	lcmaps_warning(PDL_ERROR, "Out of memory.");
+	return NULL;
     }
-
-    strcpy(string, lcmaps_pdl_path());
-
-    /*  Make sure the path ends in '/'.  */
-    if (path_length>0 && string[path_length-1] != '/')
-      string[path_length++] = '/';
-    strncpy(string + path_length, state, state_length);
-    string[path_length + state_length] = '\0';
+    tmp = strchr(string,' ');
+    if (tmp) *tmp='\0';
 
     lcmaps_log_debug(1, "evaluationmanager: found plugin: %s\n", string);
   }
diff -ur lcmaps-1.4.31/src/evaluationmanager/pdl_yacc.y lcmaps-1.4.33/src/evaluationmanager/pdl_yacc.y
--- lcmaps-1.4.31/src/evaluationmanager/pdl_yacc.y	2011-09-08 05:19:30.000000000 -0500
+++ lcmaps-1.4.33/src/evaluationmanager/pdl_yacc.y	2011-09-20 02:30:49.000000000 -0500
@@ -51,8 +51,8 @@
   rule_t*   rule;
 };
 
-%token<record> LABEL TERM TRANS EMPTYLINE COMMENT PVAR PATH STRING
-%type<record>  config var_list var path policy_list string
+%token<record> LABEL PATH TERM TRANS EMPTYLINE COMMENT PVAR STRING
+%type<record>  config var_list var policy_list string
 %type<rule> policy rule;
 
 %token_table
@@ -71,24 +71,17 @@
           | var_list var
 ;
 
-var:   TERM  '=' string                   { lcmaps_add_variable($1, $3); }
-     | TERM  '=' TERM                     { lcmaps_add_variable($1, $3); }
-     | PVAR '=' path '\n'                 { lcmaps_set_path($3);         }
-     | PVAR '='                           { lcmaps_warning(PDL_ERROR, "No value assigned to path. Using %s as path instead.", lcmaps_pdl_path()); }
-/*
-     | TERM  '='                          { lcmaps_warning(PDL_ERROR, "No value assigned to %s.", $1->string); }
-     | TERM                               { lcmaps_warning(PDL_ERROR, "Found a non classified term: %s.", $1->string); }
-*/
+var:   PVAR '=' PATH                      { lcmaps_set_path($3);         }
+     | PVAR '='                           { lcmaps_warning(PDL_INFO, "Empty value assigned to path: ignoring this line.");
+                                            lcmaps_set_path(NULL);       }
+     | TERM '=' string                    { lcmaps_add_variable($1, $3); }
+     | TERM '=' TERM                      { lcmaps_add_variable($1, $3); }
 ;
 
 string:   STRING                          { $$ = $1;                     }
         | string STRING                   { $$ = lcmaps_concat_strings_with_space($1, $2); }
 ;
 
-path:   PATH                              { $$ = $1;                     }
-      | path PATH                         { $$ = lcmaps_concat_strings($1, $2); }
-;
-
 policy_list:   LABEL policy               { lcmaps_add_policy($1, $2); }
              | policy_list LABEL policy   { lcmaps_add_policy($2, $3); }
              | policy_list LABEL          { lcmaps_warning(PDL_WARNING, "expecting rule definitions.");
diff -ur lcmaps-1.4.31/src/pluginmanager/lcmaps_pluginmanager.c lcmaps-1.4.33/src/pluginmanager/lcmaps_pluginmanager.c
--- lcmaps-1.4.31/src/pluginmanager/lcmaps_pluginmanager.c	2011-09-08 05:19:29.000000000 -0500
+++ lcmaps-1.4.33/src/pluginmanager/lcmaps_pluginmanager.c	2011-09-20 02:30:48.000000000 -0500
@@ -163,6 +163,8 @@
 static int                 lcmaps_set_sigpipe_handler(void);
 static int                 lcmaps_reset_sigpipe_handler(void);
 static void                lcmaps_sigpipe_handler(int sig);
+static int    fexist(char *);
+static char * lcmaps_findplugin(char *);
 
 /******************************************************************************
                        Define module specific variables
@@ -173,6 +175,122 @@
 static lcmaps_plugindl_t *  plugin_list                    = NULL; /*!< \internal */
 static void *               lcmaps_stored_sigpipe_handler  = NULL; /*!< \internal */
 
+/******************************************************************************
+Function:       fexist()
+Description:    check the existence of file corresponding to <path>
+Parameters:     path
+Returns:        1, if file exists
+******************************************************************************/
+/*!
+    \fn fexist(
+        char * path
+        )
+    \brief check the existence of file corresponding to \<path\>
+    \param path absolute filename to be checked.
+    \retval 1 file exists.
+    \retval 0 failure.
+*/
+static int fexist(
+        char * path
+)
+{
+  struct stat sbuf;
+  int res;
+  
+  if(!path || !*path) return 0;
+
+  res=stat(path,&sbuf);
+  if (res)
+  {
+      if (errno==ENOENT)
+      {
+          return 0;
+      }
+      else
+      {
+          return -1;
+      }
+  }
+  return 1;
+}
+
+
+/******************************************************************************
+Function:       lcmaps_findplugin()
+Description:    Checks for file in standard directories
+Parameters:     name
+Returns:        returns filename found (should be freeed) or NULL
+******************************************************************************/
+/*!
+    \fn lcmaps_findplugin(
+        char * name
+        )
+    \brief Checks for file in standard directories
+
+    The directories that are checked are:
+    - current directory
+    - "modules"
+    - LCMAPS_ETC_HOME
+    - LCMAPS_MOD_HOME
+    - LCMAPS_LIB_HOME
+
+    \param name string containing the file name
+    \return pointer to a string containing the absolute path to the file, which has to
+    be freed or NULL.
+*/
+char * lcmaps_findplugin(
+        char * name
+)
+{
+    char *tmpname=NULL;
+    char *lcmaps_modules_dir=NULL;
+    char *pdl_path=NULL;
+
+    /* New format for db: either path is set in db file and plugins have an
+     * absolute path with respect to that (when path is relative, the eval
+     * manager prefixes with $libdir) or there isn't a path set and the plugin
+     * name is to be searched in either LCMAPS_MODULES_DIR if set, or in  */
+
+    pdl_path=lcmaps_pdl_path();
+    if (pdl_path)   {
+	/* Absolute path: test it */
+	tmpname=lcmaps_genfilename(pdl_path,name,NULL);
+	if (!tmpname)    { /* calloc error */
+	    lcmaps_log_time(0,"lcmaps_findplugin(): Cannot calloc\n");
+	    return NULL;
+	}
+	lcmaps_log_debug(LOG_DEBUG, "Looking for %s at %s...\n", name, tmpname);
+	if (fexist(tmpname)) return tmpname;
+	free(tmpname);
+    } else { /* relative path:
+		- do we have an LCMAPS_MODULES_DIR
+		- if so then test there first */
+	lcmaps_modules_dir=getenv("LCMAPS_MODULES_DIR");
+	if (lcmaps_modules_dir)	{
+	    /* test in and in LCMAPS_MODULES_DIR and build-time default
+	     * LCMAPS_MOD_HOME */
+	    tmpname=lcmaps_genfilename(lcmaps_modules_dir,name,NULL);
+	    if (!tmpname)    { /* calloc error */
+		lcmaps_log_time(0,"lcmaps_findplugin(): Cannot calloc\n");
+		return NULL;
+	    }
+	    lcmaps_log_debug(LOG_DEBUG, "Looking for %s at %s...\n", name, tmpname);
+	    if (fexist(tmpname)) return tmpname;
+	    free(tmpname);
+	}
+	/* No name so far: test default build-in location */
+	tmpname=lcmaps_genfilename(LCMAPS_MOD_HOME,name,NULL);
+	if (!tmpname)    { /* calloc error */
+	    lcmaps_log_time(0,"lcmaps_findplugin(): Cannot calloc\n");
+	    return NULL;
+	}
+	lcmaps_log_debug(LOG_DEBUG, "Looking for %s at %s...\n", name, tmpname);
+	if (fexist(tmpname)) return tmpname;
+	free(tmpname);
+    }
+    return NULL;
+}
+
 
 /******************************************************************************
 Function:   lcmaps_startPluginManager
@@ -424,7 +542,7 @@
     args = db_handle->pluginargs;
 
     /* Find plugin module */
-    pname = lcmaps_findfile(name);
+    pname = lcmaps_findplugin(name);
     if (pname == NULL)
     {
         lcmaps_log(0,
@@ -1070,7 +1188,8 @@
         print_lcmaps_plugin(2,plugin_entry);
         lcmaps_log_debug(2,"\n");
         lcmaps_log(0,"lcmaps.mod-lcmaps_runPluginManager(): running %s\n",plugin_entry->pluginabsname);
-        if (lcmaps_runPlugin(plugin_entry->pluginabsname)) {
+/*        if (lcmaps_runPlugin(plugin_entry->pluginabsname)) {*/
+        if (lcmaps_runPlugin(plugin_entry->pluginshortname)) {
             lcmaps_log(0,"lcmaps.mod-lcmaps_runPluginManager(): plugin %s failed\n",plugin_entry->pluginabsname);
         }
         plugin_entry=plugin_entry->next;
diff -ur lcmaps-1.4.31/src/pluginmanager/lcmaps_utils.c lcmaps-1.4.33/src/pluginmanager/lcmaps_utils.c
--- lcmaps-1.4.31/src/pluginmanager/lcmaps_utils.c	2011-09-08 05:19:29.000000000 -0500
+++ lcmaps-1.4.33/src/pluginmanager/lcmaps_utils.c	2011-09-20 02:30:48.000000000 -0500
@@ -62,20 +62,6 @@
 #include "lcmaps_log.h"
 #include "_lcmaps_utils.h"
 
-/******************************************************************************
-                             Define constants
-******************************************************************************/
-
-#define LCMAPS_MOD_HOME LCMAPS_LIB_HOME"/modules" /* default directory for the
-						     LCMAPS plugins/modules */
-
-/******************************************************************************
-                          Module specific prototypes
-******************************************************************************/
-static int    fexist(char *);
-/* char * lcmaps_getfexist(int, ...); */
-/* char * lcmaps_findfile(char *); */
-
 
 /******************************************************************************
 Function:       lcmaps_genfilename() (copied from GLOBUS gatekeeper.c)
@@ -147,138 +133,6 @@
 }
 
 /******************************************************************************
-Function:       fexist()
-Description:    check the existence of file corresponding to <path>
-Parameters:     path
-Returns:        1, if file exists
-******************************************************************************/
-/*!
-    \fn fexist(
-        char * path
-        )
-    \brief check the existence of file corresponding to \<path\>
-    \param path absolute filename to be checked.
-    \retval 1 file exists.
-    \retval 0 failure.
-*/
-static int fexist(
-        char * path
-)
-{
-  struct stat sbuf;
-  int res;
-  
-  if(!path || !*path) return 0;
-
-  res=stat(path,&sbuf);
-  if (res)
-  {
-      if (errno==ENOENT)
-      {
-          return 0;
-      }
-      else
-      {
-          return -1;
-      }
-  }
-  return 1;
-}
-
-/******************************************************************************
-Function:       lcmaps_getfexist()
-Description:    picks the first existing file in argument list
-Parameters:     n   : number of paths,
-                ... : list of paths
-Returns:        returns filename found or NULL
-******************************************************************************/
-/*!
-    \fn lcmaps_getfexist(
-        int n,
-        ...
-        )
-    \brief Picks the first existing file in argument list.
-
-    \param n   the number of paths presented in the following argument list.
-    \param ... variable argument list of paths.
-
-    \return filename found or NULL
-*/
-char * lcmaps_getfexist(
-        int n,
-        ...
-)
-{
-  va_list pvar;
-  int i;
-  char *cfilenm=NULL;
-
-  va_start(pvar, n);
-
-  for(i=0;i<n;i++) {
-    cfilenm=va_arg(pvar,char*);
-    if(*cfilenm) if(fexist(cfilenm)) return cfilenm;
-  }
-  va_end(pvar);
-  return NULL;
-}
-
-/******************************************************************************
-Function:       lcmaps_findfile()
-Description:    Checks for file in standard directories
-Parameters:     name
-Returns:        returns filename found (should be freeed) or NULL
-******************************************************************************/
-/*!
-    \fn lcmaps_findfile(
-        char * name
-        )
-    \brief Checks for file in standard directories
-
-    The directories that are checked are:
-    - current directory
-    - "modules"
-    - LCMAPS_ETC_HOME
-    - LCMAPS_MOD_HOME
-    - LCMAPS_LIB_HOME
-
-    \param name string containing the file name
-    \return pointer to a string containing the absolute path to the file, which has to
-    be freed or NULL.
-*/
-char * lcmaps_findfile(
-        char * name
-)
-{
-    char * newname=NULL;
-    char * tmpname=NULL;
-    char * names[6]={NULL,NULL,NULL,NULL,NULL,NULL};
-    int    i;
-
-    names[0]=lcmaps_genfilename(NULL,name,NULL);
-    names[1]=lcmaps_genfilename(getenv("LCMAPS_MODULES_DIR"),name,NULL);
-    names[2]=lcmaps_genfilename("modules",name,NULL);
-    names[3]=lcmaps_genfilename(LCMAPS_ETC_HOME,name,NULL);
-    names[4]=lcmaps_genfilename(LCMAPS_MOD_HOME,name,NULL);
-    names[5]=lcmaps_genfilename(LCMAPS_LIB_HOME,name,NULL);
-
-    tmpname=lcmaps_getfexist(6,names[0],
-                      names[1],names[2],
-                      names[3],names[4],names[5]);
-    if (tmpname != NULL)
-        newname=strdup(tmpname);
-    else
-        newname=NULL;
-
-    for (i=0; i < 6; i++)
-    {
-        if (names[i] != NULL) free(names[i]);
-    }
-
-    return newname;
-}
-
-/******************************************************************************
 Function:   lcmaps_tokenize() (in modified form from globus_gatekeeper_utils.c)
 
 Description:
