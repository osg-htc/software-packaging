commit 402b5f6f5945b6f53086eb03f25b4b4b51032b7f
Author: Greg Thain <gthain@cs.wisc.edu>
Date:   Wed Dec 5 21:30:04 2018 -0600

    Fix memory leak in schedd when it can't flock to foreign pools #6837
    
    Really a memory leak when any daemon is unable to send any ad to
    any collector.
    
    Happened when a non-blocking connect was pending to a collector.  Subsequenty
    updates before the connect timed out and failed would get queued up.  If
    updates were sent faster than the connect time out (which is common), we'd
    never catch up, and the daemon would queue up an arbritrary number of update
    ads.

diff --git a/src/condor_daemon_client/dc_collector.cpp b/src/condor_daemon_client/dc_collector.cpp
index b86cfcd..84926c5 100644
--- a/src/condor_daemon_client/dc_collector.cpp
+++ b/src/condor_daemon_client/dc_collector.cpp
@@ -365,11 +365,25 @@ public:
 			char const *who = "unknown";
 			if(sock) who = sock->get_sinful_peer();
 			dprintf(D_ALWAYS,"Failed to start non-blocking update to %s.\n",who);
+			if (dc_collector) {
+				while (!dc_collector->pending_update_list.empty()) {
+					// UpdateData's dtor removes this from the pending update list
+					delete(dc_collector->pending_update_list.front());
+				}
+				ud = 0;	
+			}
 		}
 		else if(sock && !DCCollector::finishUpdate(ud->dc_collector,sock,ud->ad1,ud->ad2)) {
 			char const *who = "unknown";
 			if(sock) who = sock->get_sinful_peer();
 			dprintf(D_ALWAYS,"Failed to send non-blocking update to %s.\n",who);
+			if (dc_collector) {
+				while (!dc_collector->pending_update_list.empty()) {
+					// UpdateData's dtor removes this from the pending update list
+					delete(dc_collector->pending_update_list.front());
+				}
+				ud = 0;	
+			}
 		}
 		else if(sock && sock->type() == Sock::reli_sock) {
 			// We keep the TCP socket around for sending more updates.
@@ -381,7 +395,9 @@ public:
 		if(sock) {
 			delete sock;
 		}
-		delete ud;
+		if (ud) {
+			delete ud;
+		}
 
 			// Now that we finished sending the update, we can start sequentially sending
 			// the pending updates.  We send these updates synchronously in sequence
