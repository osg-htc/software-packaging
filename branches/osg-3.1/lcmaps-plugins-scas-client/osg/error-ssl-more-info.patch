--- src/saml2-xacml2/io_handler/ssl/ssl-common.c.orig	2012-01-18 12:21:21.000000000 -0600
+++ src/saml2-xacml2/io_handler/ssl/ssl-common.c	2014-01-23 10:22:32.932586000 -0600
@@ -379,7 +379,10 @@
     /* The retries are local to the system mostly, hence you can try a lot per connected client */
     if ((rc = SSL_connect(ssl)) <= 0)
     {
-        lcmaps_log(LOG_ERR, "%s: Error connecting SSL client object\n", __func__);
+	/* Note: SSL_connect can end with -1 if it isn't finished yet, see
+	 * manpage. Error will be printed in print_ssl_error_msg() */
+	lcmaps_log(LOG_DEBUG, "%s: SSL_connect() ended with rc=%d\n",
+		__func__,rc);
         if (print_ssl_error_msg (ssl, rc, 1, NULL))
         {
             SSL_free(ssl);
@@ -911,10 +914,10 @@
 
     lcmaps_log_debug (3, "%s: - Re-Verify certificate at depth: %i\n", logstr, errdepth);
     X509_NAME_oneline(X509_get_issuer_name(curr_cert), issuer, 256);
-    lcmaps_log_debug (3, "%s:  issuer   = %s\n", logstr, issuer);
+    lcmaps_log_debug (3, "%s:   issuer   = %s\n", logstr, issuer);
     X509_NAME_oneline(X509_get_subject_name(curr_cert), subject, 256);
-    lcmaps_log_debug (3, "%s:  subject  = %s\n", logstr, subject);
-    lcmaps_log_debug (3, "%s:  errnum %d: %s\n", logstr, (int) errnum, X509_verify_cert_error_string(errnum));
+    lcmaps_log_debug (3, "%s:   subject  = %s\n", logstr, subject);
+    lcmaps_log_debug (3, "%s:   errnum %d: %s\n", logstr, errnum, X509_verify_cert_error_string(errnum));
 
 
     if (ok != 1)
@@ -938,12 +941,12 @@
             store_ctx -> error = errnum;
             if (errnum == X509_V_OK)
             {
-                lcmaps_log_debug (3,  "%s: \tgrid_X509_knownCriticalExts() returned X509_V_OK.\n", logstr);
+                lcmaps_log_debug (3,  "%s:   grid_X509_knownCriticalExts() returned X509_V_OK.\n", logstr);
                 ok=1;
             }
             else
             {
-                lcmaps_log_debug (3,  "%s: \tfailure: grid_X509_knownCriticalExts() returned: %d\n", logstr, errnum);
+                lcmaps_log_debug (3,  "%s:   failure: grid_X509_knownCriticalExts() returned: %d\n", logstr, errnum);
             }
         }
 
@@ -970,9 +973,9 @@
         if (ok != 1)
         {
             lcmaps_log(LOG_ERR, "%s: Verification failure at depth %d\n", logstr, errdepth);
-            lcmaps_log_debug (3, "%s: \tFailure still applies, no override performed for this error\n", logstr);
-            lcmaps_log (LOG_NOTICE, "%s:  \tissuer   = %s\n", logstr, issuer);
-            lcmaps_log (LOG_NOTICE, "%s:  \tsubject  = %s\n", logstr, subject);
+            lcmaps_log_debug (3, "%s:     Failure still applies, no override performed for this error\n", logstr);
+            lcmaps_log (LOG_NOTICE, "%s:      issuer   = %s\n", logstr, issuer);
+            lcmaps_log (LOG_NOTICE, "%s:      subject  = %s\n", logstr, subject);
         }
     }
 
@@ -1090,7 +1093,7 @@
     {
         if ((depth - amount_of_CAs) > 0)
         {
-            lcmaps_log(LOG_ERR, "%s: No proxy certificate in certificate stack to check.\n", logstr);
+            lcmaps_log(LOG_DEBUG, "%s: No proxy certificate in certificate stack to check.\n", logstr);
             return X509_V_OK;
         }
         else
@@ -1265,7 +1268,7 @@
     ret = X509_check_issued(issuer, x);
     if (ret == X509_V_OK)
     {
-        lcmaps_log_debug (3, "%s: \tX509_check_issued() == ok\n", logstr);
+        lcmaps_log_debug (3, "%s:  X509_check_issued() == ok\n", logstr);
         return 1;
     }
 
@@ -1276,7 +1279,7 @@
                        X509_get_subject_name(x)) != 0))
     {
         lcmaps_log_debug (3, "%s: X509_V_ERR_KEYUSAGE_NO_CERTSIGN && non-self-signed detected.\n", logstr);
-        lcmaps_log_debug (3, "%s: \tThese are ok if they pass the other checks inside X509_check_issued() (Is this enough?)\n", logstr);
+        lcmaps_log_debug (3, "%s:   These are ok if they pass the other checks inside X509_check_issued() (Is this enough?)\n", logstr);
         return 1;
     }
 
@@ -1481,94 +1484,107 @@
 
 Return:
     0 : Non lethal failure, should consider a retry of the SSL interaction
-    1 : Lethal failure, recoverable situation
+    1 : Lethal failure, non-recoverable situation
 ****************************************************/
 int print_ssl_error_msg (SSL * ssl, int ret, int printmsg, int * error_code )
 {
-    long rc = 0;
+    int rc = 0;
     int unrecoverable = 0;
+    int code;
 
     if (ssl)
     {
-        rc = SSL_get_error (ssl, ret);
-    }
+        rc = SSL_get_error (ssl, ret); /* returns int following openssl/ssl.h */
+	if (error_code)
+	    *error_code = rc;
+
+	switch (rc)
+	{
+	    case SSL_ERROR_NONE :
+	    {
+		/* No error */
+		if (printmsg)
+		    lcmaps_log_debug (5, "XACML SSL I/O: Got error trigger, but there's no error on the stack\n");
+		unrecoverable = 0;
+		break;
+	    }
+	    case SSL_ERROR_ZERO_RETURN :
+	    {
+		/* Shutdown given, possibly not shutdown yet in the underlying transport layer */
+		if (printmsg)
+		    lcmaps_log_debug (5, "XACML SSL I/O: Shutdown given, possibly not shutdown yet in the underlying transport layer\n");
+		unrecoverable = 0;
+		break;
+	    }
+	    case SSL_ERROR_WANT_READ:
+	    case SSL_ERROR_WANT_WRITE:
+	    {
+		if (printmsg)
+		    lcmaps_log_debug (5, "XACML SSL I/O: operation not completed, retry that last I/O operation\n");
+		unrecoverable = 0;
+		break;
+	    }
+	    case SSL_ERROR_WANT_CONNECT:
+	    case SSL_ERROR_WANT_ACCEPT:
+	    {
+		if (printmsg)
+		    lcmaps_log_debug (5, "XACML SSL I/O: operation not completed, underlying I/O not ready, retry that last accept/connect operation. Re-check select() or poll() logics\n");
+		unrecoverable = 0;
+		break;
+	    }
+	    case SSL_ERROR_WANT_X509_LOOKUP:
+	    {
+		if (printmsg)
+		    lcmaps_log_debug (5, "XACML SSL I/O: operation not completed, application callback was called again, should retry.\n");
+		unrecoverable = 0;
+		break;
+	    }
+	    case SSL_ERROR_SYSCALL:
+	    {
+		/* Some I/O error occurred. The OpenSSL error queue may contain more information on the error. If the error queue is empty (i.e. ERR_get_error() returns 0), ret can be used to find out more about the error: If ret == 0, an EOF was observed that violates the protocol. If ret == -1, the underlying BIO reported an I/O error (for socket I/O on Unix systems, consult errno for details). */
+		if (printmsg)
+		     lcmaps_log(LOG_ERR, "XACML SSL I/O: Some I/O error occurred. Unrecoverable\n");
+		unrecoverable = 1;
+		break;
+	    }
+	    case SSL_ERROR_SSL:
+	    {
+		/* Check ERR_get_error() for more information */
+		if (printmsg)
+		    lcmaps_log(LOG_ERR, "XACML SSL I/O: A failure in the SSL library occurred, usually a protocol error.\n");
+		unrecoverable = 1;
+		break;
+	    }
+
+	    default:
+	    {
+		if (printmsg)
+		    lcmaps_log(LOG_ERR, "XACML SSL I/O: Undefined error code 0x%x, not in OpenSSL specs\n",rc);
+		unrecoverable = 1;
+		break;
+	    }
+	} /* switch(rc) */
+    } /* if (ssl) */
     else
     {
-        rc = ERR_get_error();
+	/* No ssl object and cannot just convert the error from ERR_get_error()
+	 * as they don't match at all... */
+	lcmaps_log(LOG_ERR,"%s: No SSL object\n",__func__);
+	if (*error_code)
+	    *error_code = SSL_ERROR_SSL; /* No obvious error )-: */
+	unrecoverable = 1;
+    }
+
+    /* Print error queue */
+    if (printmsg)   {
+	while ((code=ERR_get_error())!=0)        {
+	    lcmaps_log(LOG_ERR,"   OpenSSL error queue: %s (function %s from %s)\n",
+		    ERR_reason_error_string(code),
+		    ERR_func_error_string(code),
+		    ERR_lib_error_string(code));
+	}
     }
 
-
-    switch (rc)
-    {
-        case SSL_ERROR_NONE :
-        {
-            /* No error */
-            if (printmsg)
-                lcmaps_log_debug (5, "XACML SSL I/O: Got error trigger, but there's no error on the stack\n");
-            unrecoverable = 0;
-            break;
-        }
-        case SSL_ERROR_ZERO_RETURN :
-        {
-            /* Shutdown given, possibly not shutdown yet in the underlying transport layer */
-            if (printmsg)
-                lcmaps_log_debug (5, "XACML SSL I/O: Shutdown given, possibly not shutdown yet in the underlying transport layer\n");
-            unrecoverable = 0;
-            break;
-        }
-        case SSL_ERROR_WANT_READ:
-        case SSL_ERROR_WANT_WRITE:
-        {
-            if (printmsg)
-                lcmaps_log_debug (5, "XACML SSL I/O: operation not completed, retry that last I/O operation\n");
-            unrecoverable = 0;
-            break;
-        }
-        case SSL_ERROR_WANT_CONNECT:
-        case SSL_ERROR_WANT_ACCEPT:
-        {
-            if (printmsg)
-                lcmaps_log_debug (5, "XACML SSL I/O: operation not completed, underlying I/O not ready, retry that last accept/connect operation. Re-check select() or poll() logics\n");
-            unrecoverable = 0;
-            break;
-        }
-        case SSL_ERROR_WANT_X509_LOOKUP:
-        {
-            if (printmsg)
-                lcmaps_log_debug (5, "XACML SSL I/O: operation not completed, application callback was called again, should retry.\n");
-            unrecoverable = 0;
-            break;
-        }
-        case SSL_ERROR_SYSCALL:
-        {
-            /* Some I/O error occurred. The OpenSSL error queue may contain more information on the error. If the error queue is empty (i.e. ERR_get_error() returns 0), ret can be used to find out more about the error: If ret == 0, an EOF was observed that violates the protocol. If ret == -1, the underlying BIO reported an I/O error (for socket I/O on Unix systems, consult errno for details). */
-            if (printmsg)
-                 lcmaps_log(LOG_ERR, "XACML SSL I/O: Some I/O error occurred. Unrecoverable\n");
-            unrecoverable = 1;
-            break;
-        }
-        case SSL_ERROR_SSL:
-        {
-            /* Check ERR_get_error() for more information */
-            if (printmsg)
-                lcmaps_log(LOG_ERR, "XACML SSL I/O: A failure in the SSL library occurred, usually a protocol error.\n");
-            unrecoverable = 0;
-            break;
-        }
-
-        default:
-        {
-            if (printmsg)
-                lcmaps_log(LOG_ERR, "XACML SSL I/O: Undefined error code, not in OpenSSL specs\n");
-            unrecoverable = 1;
-            break;
-        }
-    }
-
-    if (error_code)
-        *error_code = rc;
-
-
     return unrecoverable;
 }
 
