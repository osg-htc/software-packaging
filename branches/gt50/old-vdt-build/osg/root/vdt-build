#!/usr/bin/env perl
#===============================================================================
#
#         FILE:  vdt-build
# in alpha condition.
# may be converted to python
#
#===============================================================================

use warnings;
no warnings qw(once);

#use warnings FATAL => qw(uninitialized);
use strict;
use Carp;

use Getopt::Long qw(:config auto_help);
use Pod::Usage;
use Cwd qw(getcwd abs_path);

use File::Spec;
use File::Temp;
use File::Basename;
use File::Copy;
use File::Path;

use LWP::Simple qw(getstore head);
use HTTP::Status qw(is_success);

use RPM::Toolbox::Spec;

our @ARG_PACKAGES;
our $TASK;
our $DEFAULT_LOCAL_CACHE_PREFIX  = 'file:///p/vdt/public/html/upstream';
our $DEFAULT_REMOTE_CACHE_PREFIX = 'http://vdt.cs.wisc.edu/upstream';
our $WD_UNPACKED                 = '_upstream_srpm_contents';
our $WD_UNPACKED_TARBALL         = '_upstream_tarball_contents';
our $WD_PREBUILD                 = '_final_srpm_contents';
our $WD_RESULTS                  = '_build_results';
our $ARG_CACHE_PREFIX;
our $ARG_YUM_REPO;
our $ARG_MOCK_CFG;
our $ARG_FULL_EXTRACT;
our $ARG_PUSH_TO_YUM;
our $ARG_WORKING_DIRECTORY;
our $ARG_INIT_REPO;
our $ARG_TARGET_ARCH;
our $ARG_QUIET;

sub say { local $\ = "\n"; print @_ }

sub info { my (undef, undef, undef, $calling_sub) = caller(1); if ($calling_sub) {$calling_sub.=": "} say($calling_sub||'', @_) unless $ARG_QUIET }

sub slurp { open my $fh, '<', $_[0]; local $/=undef; my $text = <$fh>; close $fh; return $text; }

sub get_rpmbuild_defines {
    my ($working_dir) = @_;

    my $results_dir = abs_path("$working_dir/$WD_RESULTS");
    my $prebuild_dir = abs_path("$working_dir/$WD_PREBUILD");
    ### $results_dir
    ### $prebuild_dir
    my @defines = (
                   qq(_topdir $results_dir),
                   qq(_srcrpmdir $prebuild_dir),
                   qq(_specdir $prebuild_dir),
                   qq(_sourcedir $prebuild_dir),
                   qq(_build_name_fmt %%{NAME}-%%{VERSION}-%%{RELEASE}.%%{ARCH}.rpm),
                   qq(_tmppath $prebuild_dir/tmp),
                   qq(dist .vdt),
    );
    ### get_rpmbuild_defines: @defines
    if (wantarray) {
        return @defines;
    }
    else {
        my $args = "";
        $args .= qq( "--define=$_" ) foreach (@defines);
        return $args;
    }
}

sub make_tempdir {
    return File::Temp::tempdir(File::Spec->tmpdir()."/vdt-build-XXXXXX");
}

#sub make_working_dir {
##    mkpath($_[0]);
##    return File::Temp::tempdir(getcwd()."/$_[0]/_workingXXXXXX");
#    mkpath("$_[0]/_working");
#    return getcwd()."/$_[0]/_working";
#}

sub make_rpmbuild_tree {
    my $parent = shift;

    mkpath("$parent/$_") for qw(BUILD RPMS SRPMS tmp);
    system("mkdir -p $parent/{BUILD,RPMS,SRPMS,tmp}");
}

sub unpack_rpm {
    for (@_) {
        my $command = "rpm2cpio $_ | cpio -ivd";
        ### $command
        system($command);
    }
}

sub super_unpack {
    for (@_) {
        /\.tar\.bz2$/ && do { system("tar xjf $_");             next };
        /\.tar\.gz$/  && do { system("tar xzf $_");             next };
        /\.bz2$/      && do { system("bunzip2 $_");             next };
        /\.rar$/      && do { system("unrar x $_");             next };
        /\.gz$/       && do { system("gunzip $_");              next };
        /\.tar$/      && do { system("tar xf $_");              next };
        /\.tbz2$/     && do { system("tar xjf $_");             next };
        /\.tgz$/      && do { system("tar xzf $_");             next };
        /\.zip$/      && do { system("unzip $_");               next };
        /\.Z$/        && do { system("uncompress $_");          next };
        /\.7z$/       && do { system("7z x $_");                next };
        /\.tar\.xz$/  && do { system("xz -d $_ -c | tar xf -"); next };
        /\.xz$/       && do { system("xz -d $_");               next };
        /\.rpm$/      && do { system("rpm2cpio $_ | cpio -id"); next };
    }
}

sub pushd {
    our @dir_stack;

    push @dir_stack, getcwd();
    chdir($_[0]);
}

sub popd {
    our @dir_stack;

    chdir(pop @dir_stack);
}

sub add_error {
    our @ERRORS;
    push @ERRORS, @_;
}

sub die_on_errors {
    our @ERRORS;
    if (@ERRORS) {
        croak "There were " . +@ERRORS . " fatal errors:\n". join("\n", @ERRORS) . "\n";
    }
}

sub get_options {

    GetOptions(
               'cache-prefix=s'         => \$ARG_CACHE_PREFIX,
               'full-extract!'          => \$ARG_FULL_EXTRACT,
               'mock-config=s'          => \$ARG_MOCK_CFG,
               'yum-base=s'             => \$ARG_YUM_REPO,
               'push-to-yum!'           => \$ARG_PUSH_TO_YUM,
               'working-directory=s'    => \$ARG_WORKING_DIRECTORY,
               'init-repo'              => \$ARG_INIT_REPO,
               'quiet'                  => \$ARG_QUIET,
               'target-arch=s'          => \$ARG_TARGET_ARCH,
    ) or pod2usage(2);

    $TASK = shift @ARGV;

    if (! $TASK) {
        pod2usage('No task given');
    }

    # get first task that starts with $TASK
    my @valid_tasks = qw/batlab prebuild mock push rpmbuild/;

    my @matching_tasks = grep { substr($_, 0, length($TASK)) eq $TASK } @valid_tasks;

    if (+@matching_tasks > 1) {
        pod2usage("Ambiguous task '$TASK'; could be:\n\t".join("\n\t",@matching_tasks));
    }
    elsif (!@matching_tasks) {
        pod2usage("No matching task for '$TASK'");
    }
    else {
        ($TASK) = @matching_tasks;
    }
    
    if (! $main::{"task_$TASK"}) {
        pod2usage("Invalid task $TASK");
    }

    if (! defined($ARG_PUSH_TO_YUM)) {
        if ($ARG_YUM_REPO) {
            $ARG_PUSH_TO_YUM = 1;
        }
        elsif ($TASK eq 'mock' or $TASK eq 'batlab') {
            $ARG_PUSH_TO_YUM = 1;
        }
        else {
            $ARG_PUSH_TO_YUM = 0;
        }
    }

    if ($TASK eq 'push') {
        $ARG_PUSH_TO_YUM = 1;
    }

    if (! @ARGV) {
        pod2usage("No packages specified");
    }
    @ARG_PACKAGES = @ARGV;

    $ARG_CACHE_PREFIX ||= ( -d $DEFAULT_LOCAL_CACHE_PREFIX ? $DEFAULT_LOCAL_CACHE_PREFIX : $DEFAULT_REMOTE_CACHE_PREFIX );
    if ($ARG_CACHE_PREFIX =~ m{^/}) {
        $ARG_CACHE_PREFIX = "file://$ARG_CACHE_PREFIX";
    }
    elsif ($ARG_CACHE_PREFIX !~ m{^(/|\w+://)}) { #relative path
        $ARG_CACHE_PREFIX = "file://" . abs_path($ARG_CACHE_PREFIX);
    }
}

sub make_srpm {
    my ($temp_dir, $spec_fn) = @_;

    return ! system(
qq(rpmbuild -bs --nodeps --define="_topdir $temp_dir" --define="_srcrpmdir $temp_dir" --define="_sourcedir $temp_dir" --define="_specdir $temp_dir" --define="dist .vdt" $spec_fn)
    );
}

sub process_dot_source {
    my ($sfile, $destdir) = @_;
    mkpath($destdir);
    my $scontents = slurp $sfile;
    my @downloaded;
    info("Processing $sfile");
    foreach my $line (split /\n/, $scontents) {
        chomp $line;
        $line =~ s/#.*$//; # strip comments,
        $line =~ s/^\s+//; # leading whitespace,
        $line =~ s/\s+$//; # and trailing whitespace
        next if $line !~ /\w/; # empty line
        my $basename = basename($line);
        my $uri;
        if ($line =~ m{^/}) {
            $uri = "file://$line";
        }
        elsif ($line !~ m{^(/|\w+://)}) { #relative path
            $uri = "$ARG_CACHE_PREFIX/$line";
        }
        else {
            $uri = $line;
        }
        info("Downloading from $uri");
        my $ret = getstore($uri, "$destdir/".$basename);
        if (! is_success($ret)) {
            say "Unable to download $uri: $ret";
        }
        else {
            push @downloaded, "$destdir/$basename";
        }
    }
    return @downloaded;
}

# You know what function would really benefit from exception handling? This one.
sub prebuild {
    my ($package, $working_dir) = @_;
    info("Prebuilding $package");
    my $package_dir = abs_path($package);
    mkpath($working_dir);
    my $prebuild_dir = abs_path("$working_dir/$WD_PREBUILD");
    my $unpacked_dir = abs_path("$working_dir/$WD_UNPACKED");
    my $unpacked_tarball_dir = abs_path("$working_dir/$WD_UNPACKED_TARBALL");
    mkpath("$prebuild_dir/tmp");

    pushd($package);

    # There are 2 types of packages:
    # (1) Those that get laid down as-is, with minimal "building", generally
    #     used for our scripts.
    #     Layout:
    #       $package/osg/root/{usr,etc}/*   - the files to include
    #       $package/osg/$package.spec      - the spec file
    # (2a) A pointer to an SRPM plus modifications
    #     Layout:
    #       $package/upstream/*.source      - the address of the srpm
    #       $package/osg/*                  - modifications. (optional)
    #   SRPM will be unpacked and our modifications copied over it.
    # (2b) A pointer to a source tarball plus our spec file and modifications
    #     Layout:
    #       $package/upstream/*.source      - the address of the source files
    #       $package/osg/*.spec             - our spec file
    #       $package/osg/*                  - any other additions

    if (-d "osg/root") {
        # Case 1
        my ($spec_fn) = glob("osg/*.spec");
        if (! $spec_fn) {
            die "Cannot find a specfile for package $package";
        }
        if (! glob("osg/root/*")) {
            die "osg/root empty for package $package";
        }
        info("Parsing spec file $spec_fn");
        my $spec = RPM::Toolbox::Spec->parse_file($spec_fn, defines => [get_rpmbuild_defines($working_dir)]);

        my $fullversion = $spec->fullversion;
        say "Full version is $fullversion";
        my ($tarball_fn) = $spec->sources;
        say "Tarball is $tarball_fn";

        pushd('osg/root');
        my $tar_cmd;
        if ($tarball_fn =~ /\.tar\.gz|\.tgz/) {
            $tar_cmd = "tar czf ";
        }
        elsif ($tarball_fn =~ /\.tar\.bz2|\.tbz2/) {
            $tar_cmd = "tar cjf ";
        }
        else {
            die ".tar.gz/.tgz or .tar.bz2/.tbz2 expected for source 0, got: $tarball_fn";
        }
        $tar_cmd .= " $prebuild_dir/$tarball_fn --exclude '*/.svn/*' *";
        info("Creating tarball: $tar_cmd");
        system($tar_cmd) and die "Making tarball $prebuild_dir/$tarball_fn failed";
        popd();

        copy($spec_fn, $prebuild_dir);

        my $ret;
        info('Making srpm');
        if (make_srpm($prebuild_dir, $spec_fn)) {
            say "Files have been prepared in $prebuild_dir";
            $ret = $spec;
        }
        else {
            say "Error making SRPM";

            $ret = undef;
        }

        popd();
        return $ret;
    }
    elsif (-d 'upstream/') {
        # Case 2
        my @dot_sources = glob('upstream/*.source');
        my @downloaded;
        mkpath($prebuild_dir);
        foreach (@dot_sources) {
            push @downloaded, process_dot_source($_, $prebuild_dir);
        }
        my @srpms = map { abs_path($_) } grep { $_ =~ /\.src\.rpm$/ } @downloaded;
        ### @srpms
        if (@srpms) {
            mkpath($unpacked_dir);
            move($_, $unpacked_dir) for @srpms;
            pushd($unpacked_dir);
            for (@srpms) {
                info("Unpacking SRPM $_");
                unpack_rpm(basename($_));
                unlink(basename($_));
            }
            popd;
            copy($_, $prebuild_dir) for glob("$unpacked_dir/*");
        }
        if ($ARG_FULL_EXTRACT) {
            if (-d $unpacked_dir) {
                push @downloaded, grep { -f $_ && $_ !~ /\.src\.rpm$/ } glob("$unpacked_dir/*");
                @downloaded = grep { -f $_ } @downloaded;
            }
            mkpath($unpacked_tarball_dir);
            my @abs_downloaded = map { abs_path($_) } @downloaded;
            pushd $unpacked_tarball_dir;
            for (@abs_downloaded) {
                info("Extracting $_");
                super_unpack($_);
            }
            popd;
            say "Extracted files to $unpacked_tarball_dir";
        }
        if (-d "osg") {
            foreach (glob('osg/*')) {
                copy($_, $prebuild_dir);
            }
        }
        my $spec_fn = glob("$prebuild_dir/*.spec");
        die "Couldn't find a spec file in $prebuild_dir" if ! $spec_fn || ! -f $spec_fn;
        info("Parsing spec file $spec_fn");
        my $spec = RPM::Toolbox::Spec->parse_file($spec_fn, defines => [get_rpmbuild_defines($working_dir)]);
        info("Making SRPM");
        if (make_srpm($prebuild_dir, $spec_fn)) {
            popd;
            return $spec;
        }
        else {
            popd;
            return;
        }
    }
    else {
        die "Don't know what kind of package this is";
    }

}

sub verify_packages {
    my @packages = @_;

    foreach my $pkg (@packages) {
        if (! -d $pkg) {
            add_error "Package directory $pkg not found";
            next;
        }
        if (! (-d "$pkg/osg/root" || -d "$pkg/upstream")) {
            add_error "Unable to determine package type for $pkg, since the package directory contains neither osg/root/ nor upstream/";
            next;
        }
    }

    die_on_errors();
}

sub task_batlab {
    print "Unimplemented\n";
}

sub task_prebuild {
    unless (prebuild($_[0], "$_[1]/$_[0]")) {
        die "Making SRPM for $_[0] failed!\n";
    }
}

sub task_mock {
    my $package = $_[0];
    my $wd_root = $_[1];
    my $working_dir = "$wd_root/$package";
    my $spec = prebuild($package, $working_dir);
    my $results_dir = abs_path("$working_dir/$WD_RESULTS");
    my $prebuild_dir = abs_path("$working_dir/$WD_PREBUILD");
    my $srcrpm = $spec->sourcerpmfile;
    ### $srcrpm
    die "Making SRPM failed" if ! -e $srcrpm;

    say "The SRPM is $srcrpm";
    
    make_rpmbuild_tree($results_dir);
    my $cmdline = "mock";
    if ($ARG_MOCK_CFG) {
        if ($ARG_MOCK_CFG =~ m{/}) {
            my $cfgname = basename($ARG_MOCK_CFG);
            my $cfgdir1 = dirname($ARG_MOCK_CFG);
            my $cfgdir2 = dirname("/etc/mock/$ARG_MOCK_CFG");
            my $cfgdir;
            if (-r "$cfgdir1/$cfgname") {
                $cfgdir = $cfgdir1;
            }
            elsif (-r "$cfgdir2/$cfgname") {
                $cfgdir = $cfgdir2;
            }
            else {
                die "Couldn't find mock config file $ARG_MOCK_CFG\n".
                    "Looked in $cfgdir1/$cfgname and $cfgdir2/$cfgname\n";
            }
            $cmdline .= " --configdir=$cfgdir -r $cfgname ";
        }
        else {
            $cmdline .= " -r $ARG_MOCK_CFG";
        }
    }
    $cmdline .= " --resultdir=$results_dir rebuild $srcrpm";
    info("Running mock: $cmdline");
    my $err = system($cmdline);

    die "Mock build failed" if $err;

    info("Copying results");
    system("mv $results_dir/*.src.rpm $results_dir/SRPMS");
    system("mv $results_dir/*.rpm $results_dir/RPMS");

    if ($ARG_PUSH_TO_YUM && $ARG_YUM_REPO) {
        copy_to_repo($ARG_YUM_REPO, $spec->rpmfiles);
    }
}

sub task_rpmbuild {
    my $package = $_[0];
    my $wd_root = $_[1];
    my $working_dir = "$wd_root/$package";
    my $spec = prebuild($package, $working_dir);
    my $prebuild_dir = abs_path("$working_dir/$WD_PREBUILD");
    my $results_dir = abs_path("$working_dir/$WD_RESULTS");
    my $srcrpm = $spec->sourcerpmfile;
    ### $srcrpm
    die "Making SRPM failed" if ! -e $srcrpm;

    say "The SRPM is $srcrpm";
    
    make_rpmbuild_tree($results_dir);
    my $cmd = "rpmbuild " . get_rpmbuild_defines($working_dir) . " --rebuild $srcrpm";
    if ($ARG_TARGET_ARCH) {
        $cmd .= " --target $ARG_TARGET_ARCH ";
    }
    info("Running rpmbuild: $cmd");
    my $err = system($cmd);

    die "Making RPM failed" if $err;

    say "Rpms are:\n".join("\n", $spec->rpmfiles);
    
    if ($ARG_PUSH_TO_YUM && $ARG_YUM_REPO) {
        copy_to_repo($ARG_YUM_REPO, $spec->rpmfiles, $spec->sourcerpmfile);
    }
}

sub verify_yum_repos {
    my ($base_repo) = @_;

    my $repo32bit = "$base_repo/i386";
    my $reponoarch = "$base_repo/noarch";
    my $repo64bit = "$base_repo/x86_64";
    my $reposource = "$base_repo/src";
    unless ($ARG_INIT_REPO) {
        if (! -d $base_repo) { die "Yum repository base directory $base_repo doesn't exist" }
        if (! -d $repo32bit) { die "32-bit repository dir $repo32bit doesn't exist" }
        if (! -d $repo64bit) { die "64-bit repository dir $repo64bit doesn't exist" }
        if (! -d $reposource) { die "Source repository dir $reposource doesn't exist" }
        if (! -d $reponoarch) { die "Noarch repository dir $reponoarch doesn't exist" }
    }
    else {
        mkpath([$repo32bit, $repo64bit, $reposource, $reponoarch]);
    }
}

sub copy_to_repo {
    my ($base_repo, @rpms) = @_;
    ### copy_to_repo: ($base_repo, @rpms)

    my $repo32bit = "$base_repo/i386";
    my $reponoarch = "$base_repo/noarch";
    my $repo64bit = "$base_repo/x86_64";
    my $reposource = "$base_repo/src";
    
    foreach my $rpm (@rpms) {
        next if ! -f $rpm; # sometimes the spec file parser gives back nonexistant rpm names, ignore if they don't exist
        my $bn = basename($rpm);

        info("Copying $bn to repos in $base_repo");

        if ($rpm =~ /\.i[3-6]86\.rpm/) { # 32-bit
            copy($rpm, $repo32bit);
        }
        elsif ($rpm =~ /\.x86_64\.rpm/) { # 64-bit
            copy($rpm, $repo64bit);
        }
        elsif ($rpm =~ /\.noarch\.rpm/) {
            copy($rpm, $reponoarch);
            system("ln -snf ../noarch/$bn $repo32bit");
            system("ln -snf ../noarch/$bn $repo64bit");
        }
        elsif ($rpm =~ /\.src\.rpm/) {
            copy($rpm, $reposource);
        }
    }

    info("Updating repos");
    system("createrepo -p --update $_") for ($repo32bit, $reposource, $repo64bit);
}

sub task_push {
    my (@packages) = @_;

    my @rpms;

    foreach my $pkg (@packages) {
        if (-d $pkg) {
            my $package_dir = abs_path($pkg);
            my $results_dir = "$package_dir/$WD_RESULTS";
            if (-d $results_dir) {
                push @rpms, glob("$results_dir/SRPMS/*.rpm"), glob("$results_dir/RPMS/*.rpm");
            }
        }
        elsif ($pkg =~ /\.rpm$/) {
            push @rpms, $pkg;
        }
    }

    if (! @rpms) {
        die "Couldn't find rpms to push!";
    }
    copy_to_repo($ARG_YUM_REPO, @rpms);
}

# MAIN EXECUTION BEGINS HERE
get_options();
if ($ARG_PUSH_TO_YUM && $ARG_YUM_REPO) {
    verify_yum_repos($ARG_YUM_REPO);
}
if ($TASK eq 'push') {
    die "No yum repo specified" if ! $ARG_YUM_REPO;
    task_push(@ARG_PACKAGES);
    exit(0);
}
verify_packages(@ARG_PACKAGES);
my $working_dir_root;
if ($ARG_WORKING_DIRECTORY) {
    if ($ARG_WORKING_DIRECTORY eq 'TEMP') {
        $working_dir_root = make_tempdir;
    }
    else {
        $working_dir_root = $ARG_WORKING_DIRECTORY;
    }
}
else {
    $working_dir_root = getcwd();
}
foreach (@ARG_PACKAGES) {
    $main::{"task_$TASK"}($_, $working_dir_root);
}

__END__

=head1 NAME

vdt-build

=head1 SYNOPSIS

vdt-build <task> [options] <package1> [<package2> ...]

 Tasks:
    batlab
    prebuild
    mock
    rpmbuild
    push <rpm1> [<rpm2>]

 Options:
    -help
    -cache-prefix <url>         The location of the software cache to get source files from
    -full-extract               Extract tarballs too
    -init-repo                  Create the yum repositories tree if it doesn't exist (see -yum-base)
    -mock-config <cfg>          The mock config file to use with the mock task
    -[no-]push-to-yum           Copy built RPMs into YUM
    -target-arch <arch>         Specifies the architecture to build RPMs for (rpmbuild task only)
    -working-directory <dir>    Where to put extracted and built files. Defaults to the current directory. If <dir> is TEMP, use a randomly named directory in /tmp.
    -yum-base <repo>            The location of the tree of yum repositories to put software in. Specifying this implies -push-to-yum
    -quiet                      Display less information

=head1 TASKS

=over 8

=item B<prebuild>

Do not actually submit a build, merely preprocess the package and display
what would be submitted.

=item B<rpmbuild>

Build using L<rpmbuild(8)> on the local machine.

=item B<mock>

Build using L<mock(1)> on the local machine.

=item B<batlab>

Submit the build to the NMI Build and Test Lab. B<Unimplemented.>

=item B<push>

Push the given RPMs or packages to the yum repositories only.

=back

=head1 OPTIONS

=over 8

=back

=head1 DESCRIPTION

=cut


