# vim:ts=2:sts=2:sw=2:et

package RPM::Toolbox::Spec::Expander;
use warnings;
use strict;
use Carp;
use File::Spec::Functions;
use RPM::Toolbox::Spec::Util qw(:all);

sub _luaquote($) {
  my $s = shift;
  $s =~ s/([\\\n\r"'])/'\\' . sprintf ('%03d', ord ($1))/ge;
  return $s;
};

sub new {
  my ($class, $workdir) = @_;
  my $self = {
    expand_hash => {},
    expr_count => 1,
    lua_script => undef,
    lua_script_file => catfile ($workdir, "expand.lua"),
    lua_result_file => catfile ($workdir, "expand.lua.out"),
  };
  bless ($self, $class);
  return $self;
};

sub add_user_expand_hash {
  my ($self, $user_expand_hash) = @_;
  local $_;
  if ($user_expand_hash) {
    for my $key (keys (%{$user_expand_hash})) {
      my $expr = $user_expand_hash->{$key};
      defined ($expr) or croak qq(invalid undef expression in "expand" parameter);
      my $expand_expr;
      for ($expr) {
        /^:/o and do {
          $expand_expr = substr ($expr, 1);
          last;
        };
        /^\@/o and do {
          $expand_expr = read_file (substr ($expr, 1));
          last;
        };
        $expand_expr = $expr;
      };
      $self->_add_expr ("user:$key", $expand_expr);
    };
  };
};

sub add_expr {
  my ($self, $key, $expr) = @_;
  $self->_add_expr (":$key", $expr);
}

sub _add_expr {
  my ($self, $key, $expr) = @_;
  my $safe_key = $key;
  $safe_key =~ s/[^a-zA-Z0-9_-]/_/g;
  $safe_key .= '__' . $self->{expr_count};
  ++$self->{expr_count};
  $self->{expand_hash}->{$safe_key} = {
    expr => $expr,
    user_key => $key,
  };
}

sub finalize {
  my ($self) = @_;
  my $lua_package = _luaquote (__PACKAGE__);
  my $lua_expand_table = '';
  my $lua_xmarker = $X_MARKER;
  my $lua_result_file = _luaquote ($self->{lua_result_file});
  for my $safe_key (keys (%{$self->{expand_hash}})) {
    my $expr = $self->{expand_hash}->{$safe_key}->{expr};
    my $formatted_safe_key = sprintf ('%-20s', $safe_key);
    $lua_expand_table .= "\n    $formatted_safe_key = '" . _luaquote ($expr) . "',";
  };
  my $lua_script = <<_END
-- generated by $lua_package
do
  local expand_table = {$lua_expand_table
  };
  local key;
  local expr;
  local out = io.open ("$lua_result_file", "w");
  for key, expr in pairs(expand_table) do
    out:write ('$lua_xmarker:' .. key .. ':-->' .. rpm.expand (expr) .. '<--:$lua_xmarker');
  end
end
_END
  ;
  
  debug "creating LUA script ", $self->{lua_script_file};
  write_file ($lua_script, $self->{lua_script_file});
  my $expr = '%{lua: dofile "' . _luaquote ($self->{lua_script_file}) . '"}';
  return $expr;
}


sub parse_query_output {
  my ($self) = @_;
  debug "parsing LUA results from ", $self->{lua_script_file};
  my $buf = read_file ($self->{lua_result_file});
  my $result_hash = {};
  my $count;
  while ($buf =~ /\Q$X_MARKER\E:([^:]+):-->(.*?)<--:\Q$X_MARKER\E/gso) {
    my ($safe_key, $value) = ($1, $2);
    my $rec = $self->{expand_hash}->{$safe_key};
    $rec or confess "internal error: unexpected LUA output";
    debug qq(found macro expansion for key "$safe_key"); 
    my $key = $rec->{user_key};
    $result_hash->{$key} = $value;
    ++$count;
  };
  $count = scalar (keys (%{$self->{expand_hash}}))
    or confess "internal error: unexpected LUA output";
  return $result_hash;
};

1;

