Index: condor.pm
===================================================================
--- condor.pm.orig	2013-12-12 16:55:14.916832333 -0600
+++ condor.pm	2013-12-12 16:55:21.075908412 -0600
@@ -37,7 +37,7 @@
 
 @ISA = qw(Globus::GRAM::JobManager);
 
-my ($condor_submit, $condor_rm, $condor_config, $isNFSLite);
+my ($condor_submit, $condor_rm, $condor_config, $isNFSLite, $isManagedFork);
 
 BEGIN
 {
@@ -59,6 +59,7 @@
     }
 
     $isNFSLite = 0;
+    $isManagedFork = 0;
 }
 
 sub new
@@ -89,6 +90,12 @@
         }
     }
 
+    if ($description->servicetag() =~ m/^fork\./ ||
+         $description->servicetag() =~ m/^managedfork\./ )
+    {
+        $isManagedFork = 1;
+    }
+
     if (! exists($self->{condor_logfile}))
     {
         if(! exists($ENV{GLOBUS_SPOOL_DIR}))
@@ -146,14 +153,7 @@
     my ($condor_submit_out, $condor_submit_err);
     my $rc;
     my $scratch_isset = 0; # Flag if the SCRATCH_DIRECTORY environment variable is set indicating likely GRAM job
-
-    # Reject jobs that want streaming, if so configured
-    if ( $description->streamingrequested() &&
-	 $description->streamingdisabled() ) {
-
-	$self->log("Streaming is not allowed.");
-	return Globus::GRAM::Error::OPENING_STDOUT;
-    }
+    my $is_grid_monitor = 0;
 
     if($description->jobtype() eq 'single' ||
        $description->jobtype() eq 'multiple')
@@ -177,6 +177,10 @@
     {
 	return Globus::GRAM::Error::JOBTYPE_NOT_SUPPORTED();
     }
+    if ($isManagedFork)
+    {
+        $universe = 'local';
+    }
 
     # Validate some RSL parameters
     if(!defined($description->directory()))
@@ -219,6 +223,32 @@
 	}
     }
 
+    # Check if this is the Condor-G grid monitor
+    if ($isManagedFork)
+    {
+        my $exec = $description->executable();
+        my $file_out = `/usr/bin/file $exec`;
+        if ( $file_out =~ /script/ || $file_out =~ /text/ ||
+	     $file_out =~ m|/usr/bin/env| ) {
+	    open( EXEC, "<$exec" ) or
+ 	        return Globus::GRAM::Error::EXECUTABLE_PERMISSIONS();
+	    while( <EXEC> ) {
+	        if ( /Sends results from the grid_manager_monitor_agent back to a/ ) {
+		    $is_grid_monitor = 1;
+	        }
+ 	    }
+	    close( EXEC );
+        }
+    }
+
+    # Reject jobs that want streaming, if so configured
+    if ( $description->streamingrequested() &&
+         $description->streamingdisabled() && !$is_grid_monitor ) {
+    
+        $self->log("Streaming is not allowed.");
+        return Globus::GRAM::Error::OPENING_STDOUT;
+    }
+
     @environment = $description->environment();
 
     foreach my $tuple ($description->environment())
@@ -268,6 +298,13 @@
     }       
     # NFS Lite End
 
+    if ($isManagedFork)
+    {
+        append_path_array(\@environment, 'LD_LIBRARY_PATH', $ENV{LD_LIBRARY_PATH});
+        append_path_array(\@environment, 'PERL5LIB', $ENV{PERL5LIB});
+        append_path_array(\@environment, 'PATH', $ENV{PATH});
+    }
+
     $environment_string = join(';',
                                map {$_->[0] . "=" . $_->[1]} @environment);
 
@@ -410,6 +447,12 @@
         push(@requirements, " Memory >= " . $description->min_memory());
     }
 
+    if ($isManagedFork)
+    {
+        $requirements = ("True");
+    }
+ 
+
     if (scalar(@requirements) > 0)
     {
         $rc = print SCRIPT_FILE "Requirements = ", join(" && ", @requirements) ."\n";
@@ -501,6 +544,16 @@
             "print: $script_filename: $!",
             Globus::GRAM::Error::TEMP_SCRIPT_FILE_FAILED());
     }
+    if ( $is_grid_monitor ) {
+	$rc = print SCRIPT_FILE "+GridMonitorJob = True\n";
+        if (!$rc)
+        {
+            return $self->respond_with_failure_extension(
+                "print: $script_filename: $!",
+                Globus::GRAM::Error::TEMP_SCRIPT_FILE_FAILED());
+        }
+    }
+
     # NFS Lite mode
     if ($isNFSLite && !$isManagedFork) {
         print SCRIPT_FILE "should_transfer_files = YES\n";
@@ -955,4 +1008,17 @@
     return 1; # Should return a proper Globus success code
 }
 
+# Append to a path if it exists, create it if it does not
+sub append_path_array {
+    my ($arr_ref, $var, $path) = @_;
+    
+    foreach my $val (@$arr_ref) {
+        if($val->[0] eq "$var") {
+            $val->[1] .= ":$path";
+            return;
+        }
+    }
+    push @$arr_ref, [$var, $path];
+}
+
 1;
