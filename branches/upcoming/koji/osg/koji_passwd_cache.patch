From 3fdb6eb589b543a9a3c6c384c813017f630d08b5 Mon Sep 17 00:00:00 2001
From: Matyas Selmeci <matyas@cs.wisc.edu>
Date: Thu, 8 Sep 2016 10:55:53 -0500
Subject: [PATCH] koji_passwd_cache

Cache passwords to decrypt SSL key in memory.
---
 koji/ssl/SSLCommon.py | 20 ++++++++++++++++++++
 1 file changed, 20 insertions(+)

diff --git a/koji/ssl/SSLCommon.py b/koji/ssl/SSLCommon.py
index 345d4ea..364788e 100644
--- a/koji/ssl/SSLCommon.py
+++ b/koji/ssl/SSLCommon.py
@@ -18,18 +18,37 @@ import os, sys
 from OpenSSL import SSL
 import SSLConnection
 import httplib
 import socket
 import SocketServer
+import getpass
 
 def our_verify(connection, x509, errNum, errDepth, preverifyOK):
     # print "Verify: errNum = %s, errDepth = %s, preverifyOK = %s" % (errNum, errDepth, preverifyOK)
 
     # preverifyOK should tell us whether or not the client's certificate
     # correctly authenticates against the CA chain
     return preverifyOK
 
+cached_passwd = None
+def passwd_callback(max_length, ask_twice, userdata):
+    cpass = globals()['cached_passwd']
+    if cpass:
+        return cpass
+
+    typed_pass = getpass.getpass("Enter PEM pass phrase: ")
+    if len(typed_pass) > max_length:
+        print "Password is longer than what OpenSSL is able to handle"
+        return False
+
+    if ask_twice:
+        typed_pass2 = getpass.getpass("Please enter password again for verification: ")
+        if typed_pass != typed_pass2:
+            return False
+
+    globals()['cached_passwd'] = typed_pass
+    return typed_pass
 
 def is_cert_error(e):
     """Determine if an OpenSSL error is due to a bad cert"""
 
     if not isinstance(e, SSL.Error):
@@ -72,10 +91,11 @@ def CreateSSLContext(certs):
     for f in key_and_cert, peer_ca_cert:
         if f and not os.access(f, os.R_OK):
             raise StandardError, "%s does not exist or is not readable" % f
 
     ctx = SSL.Context(SSL.SSLv23_METHOD)   # Use best possible TLS Method
+    ctx.set_passwd_cb(passwd_callback, None)
     ctx.use_certificate_file(key_and_cert)
     ctx.use_privatekey_file(key_and_cert)
     ctx.load_verify_locations(peer_ca_cert)
     verify = SSL.VERIFY_PEER | SSL.VERIFY_FAIL_IF_NO_PEER_CERT
     ctx.set_verify(verify, our_verify)
-- 
2.6.3

