diff --git a/cvmfs/duplex_fuse.h b/cvmfs/duplex_fuse.h
index 25e1717..7ff51b6 100644
--- a/cvmfs/duplex_fuse.h
+++ b/cvmfs/duplex_fuse.h
@@ -13,11 +13,11 @@ extern "C" {
 // Empty structs have different sizes in C and C++, hence the dummy int
 struct fuse_chan { int dummy; };
 // Defined in t_fuse_evict.cc
-extern unsigned fuse_lowlevel_notify_inval_entry_cnt;
-static int __attribute__((used)) fuse_lowlevel_notify_inval_entry(
-  void *, unsigned long, const char *, size_t)  // NOLINT (ulong from fuse)
+extern unsigned fuse_lowlevel_notify_inval_inode_cnt;
+static int __attribute__((used)) fuse_lowlevel_notify_inval_inode(
+  void *, unsigned /*fuse_ino_t*/, off_t, off_t)  // NOLINT (ulong from fuse)
 {
-  fuse_lowlevel_notify_inval_entry_cnt++;
+  fuse_lowlevel_notify_inval_inode_cnt++;
   return -1;
 }
 }
@@ -32,6 +32,11 @@ static int __attribute__((used)) fuse_lowlevel_notify_inval_entry(
 {
   abort();
 }
+static int __attribute__((used)) fuse_lowlevel_notify_inval_inode(
+  void *, fuse_ino_t, off_t, off_t)  // NOLINT
+{
+  abort();
+}
 }
 #endif
 #endif
diff --git a/cvmfs/fuse_evict.cc b/cvmfs/fuse_evict.cc
index 5ee6836..67f89f4 100644
--- a/cvmfs/fuse_evict.cc
+++ b/cvmfs/fuse_evict.cc
@@ -88,7 +88,7 @@ FuseInvalidator::~FuseInvalidator() {
 }
 
 
-void FuseInvalidator::InvalidateDentries(Handle *handle) {
+void FuseInvalidator::InvalidateInodes(Handle *handle) {
   assert(handle != NULL);
   char c = 'I';
   WritePipe(pipe_ctrl_[1], &c, 1);
@@ -130,30 +130,25 @@ void *FuseInvalidator::MainInvalidator(void *data) {
 
     // We must not hold a lock when calling fuse_lowlevel_notify_inval_entry.
     // Therefore, we first copy all the inodes into a temporary data structure.
-    EvictableObject evictable_object;
     glue::InodeTracker::Cursor cursor(
       invalidator->inode_tracker_->BeginEnumerate());
-    while (invalidator->inode_tracker_->Next(
-             &cursor, &evictable_object.inode, &evictable_object.name))
+    uint64_t inode;
+    while (invalidator->inode_tracker_->NextInode(&cursor, &inode))
     {
-      invalidator->evict_list_.PushBack(evictable_object);
+      invalidator->evict_list_.PushBack(inode);
     }
     invalidator->inode_tracker_->EndEnumerate(&cursor);
 
     unsigned i = 0;
     unsigned N = invalidator->evict_list_.size();
     while (i < N) {
-      evictable_object = invalidator->evict_list_.At(i);
-      if (evictable_object.inode == 0)
-        evictable_object.inode = FUSE_ROOT_ID;
-      // Can return non-zero value if parent entry was already evicted
-      fuse_lowlevel_notify_inval_entry(
-        *invalidator->fuse_channel_,
-        evictable_object.inode,
-        evictable_object.name.GetChars(),
-        evictable_object.name.GetLength());
-      LogCvmfs(kLogCvmfs, kLogDebug, "evicting <%" PRIu64 ">/%s",
-               evictable_object.inode, evictable_object.name.c_str());
+      uint64_t inode = invalidator->evict_list_.At(i);
+      if (inode == 0)
+        inode = FUSE_ROOT_ID;
+      // Can fail, e.g. the inode might be already evicted
+      fuse_lowlevel_notify_inval_inode(
+        *invalidator->fuse_channel_, inode, 0, 0);
+      LogCvmfs(kLogCvmfs, kLogDebug, "evicting inode %" PRIu64, inode);
 
       if ((++i % kCheckTimeoutFreqOps) == 0) {
         if (platform_monotonic_time() >= deadline) {
diff --git a/cvmfs/fuse_evict.h b/cvmfs/fuse_evict.h
index d991d32..38c9d16 100644
--- a/cvmfs/fuse_evict.h
+++ b/cvmfs/fuse_evict.h
@@ -64,7 +64,7 @@ class FuseInvalidator : SingleCopy {
                   struct fuse_chan **fuse_channel);
   ~FuseInvalidator();
   void Spawn();
-  void InvalidateDentries(Handle *handle);
+  void InvalidateInodes(Handle *handle);
 
  private:
   /**
@@ -81,14 +81,6 @@ class FuseInvalidator : SingleCopy {
    */
   static const unsigned kCheckTimeoutFreqOps;  // = 256
 
-  /**
-   * The information given to fuse_lowlevel_notify_inval_entry
-   */
-  struct EvictableObject {
-    uint64_t inode;
-    NameString name;
-  };
-
   static void *MainInvalidator(void *data);
 
   glue::InodeTracker *inode_tracker_;
@@ -101,7 +93,7 @@ class FuseInvalidator : SingleCopy {
    * thread should be shut down.
    */
   atomic_int32 terminated_;
-  BigVector<EvictableObject> evict_list_;
+  BigVector<uint64_t> evict_list_;
 };  // class FuseInvalidator
 
 #endif  // CVMFS_FUSE_EVICT_H_
diff --git a/cvmfs/fuse_remount.cc b/cvmfs/fuse_remount.cc
index 5fba669..4a6e8ce 100644
--- a/cvmfs/fuse_remount.cc
+++ b/cvmfs/fuse_remount.cc
@@ -54,7 +54,7 @@ FuseRemounter::Status FuseRemounter::Check() {
                  "new catalog revision available, "
                  "draining out meta-data caches");
         invalidator_handle_.Reset();
-        invalidator_->InvalidateDentries(&invalidator_handle_);
+        invalidator_->InvalidateInodes(&invalidator_handle_);
         atomic_inc32(&drainout_mode_);
         // drainout_mode_ == 2, IsInDrainoutMode is now 'true'
       } else {
@@ -112,7 +112,7 @@ void FuseRemounter::EnterMaintenanceMode() {
 
   // Flush caches before reload of fuse module
   invalidator_handle_.Reset();
-  invalidator_->InvalidateDentries(&invalidator_handle_);
+  invalidator_->InvalidateInodes(&invalidator_handle_);
   invalidator_handle_.WaitFor();
 }
 
diff --git a/cvmfs/glue_buffer.h b/cvmfs/glue_buffer.h
index 3e7e60c..34d1a8f 100644
--- a/cvmfs/glue_buffer.h
+++ b/cvmfs/glue_buffer.h
@@ -394,6 +394,14 @@ class InodeMap {
 
 class InodeReferences {
  public:
+  /**
+   * Used to enumerate all inodes
+   */
+  struct Cursor {
+    Cursor() : idx(0) { }
+    uint32_t idx;
+  };
+
   InodeReferences() {
     map_.Init(16, 0, hasher_inode);
   }
@@ -425,6 +433,24 @@ class InodeReferences {
     map_.Clear();
   }
 
+  Cursor BeginEnumerate() {
+    return Cursor();
+  }
+
+  bool Next(Cursor *cursor, uint64_t *inode) {
+    uint64_t empty_key = map_.empty_key();
+    while (cursor->idx < map_.capacity()) {
+      if (map_.keys()[cursor->idx] == empty_key) {
+        cursor->idx++;
+        continue;
+      }
+      *inode = map_.keys()[cursor->idx];
+      cursor->idx++;
+      return true;
+    }
+    return false;
+  }
+
  private:
   SmallHashDynamic<uint64_t, uint32_t> map_;
 };
@@ -442,8 +468,14 @@ class InodeTracker {
    * Used to actively evict all known paths from kernel caches
    */
   struct Cursor {
-    explicit Cursor(const PathStore::Cursor &c) : csr_paths(c) { }
+    explicit Cursor(
+      const PathStore::Cursor &p,
+      const InodeReferences::Cursor &i)
+      : csr_paths(p)
+      , csr_inos(i)
+    { }
     PathStore::Cursor csr_paths;
+    InodeReferences::Cursor csr_inos;
   };
 
   // Cannot be moved to the statistics manager because it has to survive
@@ -540,10 +572,11 @@ class InodeTracker {
 
   Cursor BeginEnumerate() {
     Lock();
-    return Cursor(path_map_.path_store()->BeginEnumerate());
+    return Cursor(path_map_.path_store()->BeginEnumerate(),
+                  inode_references_.BeginEnumerate());
   }
 
-  bool Next(Cursor *cursor, uint64_t *inode_parent, NameString *name) {
+  bool NextEntry(Cursor *cursor, uint64_t *inode_parent, NameString *name) {
     shash::Md5 parent_md5;
     StringRef name_ref;
     bool result = path_map_.path_store()->Next(
@@ -558,6 +591,10 @@ class InodeTracker {
     return true;
   }
 
+  bool NextInode(Cursor *cursor, uint64_t *inode) {
+    return inode_references_.Next(&(cursor->csr_inos), inode);
+  }
+
   void EndEnumerate(Cursor *cursor) {
     Unlock();
   }
diff --git a/cvmfs/talk.cc b/cvmfs/talk.cc
index 10476c1..0fca878 100644
--- a/cvmfs/talk.cc
+++ b/cvmfs/talk.cc
@@ -587,6 +587,30 @@ void *TalkManager::MainResponder(void *data) {
           (*i)->so_version + ")\n";
       }
       talk_mgr->Answer(con_fd, history_str);
+    } else if (line == "vfs inodes") {
+      string result;
+      glue::InodeTracker::Cursor cursor(
+        mount_point->inode_tracker()->BeginEnumerate());
+      uint64_t inode;
+      while (mount_point->inode_tracker()->NextInode(&cursor, &inode)) {
+        result += StringifyInt(inode) + "\n";
+      }
+      mount_point->inode_tracker()->EndEnumerate(&cursor);
+      talk_mgr->Answer(con_fd, result);
+    } else if (line == "vfs entries") {
+      string result;
+      glue::InodeTracker::Cursor cursor(
+        mount_point->inode_tracker()->BeginEnumerate());
+      uint64_t inode_parent;
+      NameString name;
+      while (mount_point->inode_tracker()->NextEntry(
+        &cursor, &inode_parent, &name))
+      {
+        result += "<" + StringifyInt(inode_parent) + ">/" + name.ToString() +
+                  "\n";
+      }
+      mount_point->inode_tracker()->EndEnumerate(&cursor);
+      talk_mgr->Answer(con_fd, result);
     } else if (line == "version") {
       string version_str = string(VERSION) + " (CernVM-FS Fuse Module)\n" +
         cvmfs::loader_exports_->loader_version + " (Loader)\n";
diff --git a/test/src/076-mountover/main b/test/src/076-mountover/main
new file mode 100644
index 0000000..f9a8055
--- /dev/null
+++ b/test/src/076-mountover/main
@@ -0,0 +1,22 @@
+
+cvmfs_test_name="Mount over a directory in cvmfs and reload"
+
+cleanup() {
+  sudo umount /cvmfs/cvmfs-config.cern.ch/etc/cvmfs
+}
+
+cvmfs_run_test() {
+  logfile=$1
+
+  cvmfs_mount cvmfs-config.cern.ch || return 1
+  sudo mount -t proc none /cvmfs/cvmfs-config.cern.ch/etc/cvmfs || return 2
+  trap cleanup EXIT HUP INT TERM
+
+  ls /cvmfs/cvmfs-config.cern.ch/etc/cvmfs/self || return 10
+  sudo cvmfs_config reload cvmfs-config.cern.ch || return 11
+
+  ls /cvmfs/cvmfs-config.cern.ch/etc/cvmfs/self || return 20
+
+  return 0
+}
+
diff --git a/test/unittests/t_fuse_evict.cc b/test/unittests/t_fuse_evict.cc
index 605fba8..c33c035 100644
--- a/test/unittests/t_fuse_evict.cc
+++ b/test/unittests/t_fuse_evict.cc
@@ -9,7 +9,7 @@
 #include "util/string.h"
 
 extern "C" {
-unsigned fuse_lowlevel_notify_inval_entry_cnt = 0;
+unsigned fuse_lowlevel_notify_inval_inode_cnt = 0;
 }
 
 class T_FuseInvalidator : public ::testing::Test {
@@ -48,14 +48,14 @@ TEST_F(T_FuseInvalidator, StartStop) {
 TEST_F(T_FuseInvalidator, InvalidateTimeout) {
   FuseInvalidator::Handle handle(0);
   EXPECT_FALSE(handle.IsDone());
-  invalidator_->InvalidateDentries(&handle);
+  invalidator_->InvalidateInodes(&handle);
   handle.WaitFor();
   EXPECT_TRUE(handle.IsDone());
 
   invalidator_->terminated_ = 1;
   FuseInvalidator::Handle handle2(1000000);
   EXPECT_FALSE(handle2.IsDone());
-  invalidator_->InvalidateDentries(&handle2);
+  invalidator_->InvalidateInodes(&handle2);
   handle2.WaitFor();
   EXPECT_TRUE(handle2.IsDone());
 }
@@ -70,26 +70,26 @@ TEST_F(T_FuseInvalidator, InvalidateOps) {
 
   FuseInvalidator::Handle handle(0);
   EXPECT_FALSE(handle.IsDone());
-  invalidator_->InvalidateDentries(&handle);
+  invalidator_->InvalidateInodes(&handle);
   handle.WaitFor();
   EXPECT_TRUE(handle.IsDone());
   EXPECT_EQ(FuseInvalidator::kCheckTimeoutFreqOps,
-            fuse_lowlevel_notify_inval_entry_cnt);
+            fuse_lowlevel_notify_inval_inode_cnt);
 
   FuseInvalidator::Handle handle2(1000000);
   EXPECT_FALSE(handle2.IsDone());
-  invalidator_->InvalidateDentries(&handle2);
+  invalidator_->InvalidateInodes(&handle2);
   handle2.WaitFor();
   EXPECT_TRUE(handle2.IsDone());
   EXPECT_EQ(FuseInvalidator::kCheckTimeoutFreqOps + 1024,
-            fuse_lowlevel_notify_inval_entry_cnt);
+            fuse_lowlevel_notify_inval_inode_cnt);
 
   invalidator_->terminated_ = 1;
   handle2.Reset();
   EXPECT_FALSE(handle2.IsDone());
-  invalidator_->InvalidateDentries(&handle2);
+  invalidator_->InvalidateInodes(&handle2);
   handle2.WaitFor();
   EXPECT_TRUE(handle2.IsDone());
   EXPECT_EQ((2 * FuseInvalidator::kCheckTimeoutFreqOps) + 1024,
-            fuse_lowlevel_notify_inval_entry_cnt);
+            fuse_lowlevel_notify_inval_inode_cnt);
 }
diff --git a/test/unittests/t_glue_buffer.cc b/test/unittests/t_glue_buffer.cc
index 6c824d7..0d98284 100644
--- a/test/unittests/t_glue_buffer.cc
+++ b/test/unittests/t_glue_buffer.cc
@@ -20,39 +20,58 @@ class T_GlueBuffer : public ::testing::Test {
 
 
 TEST_F(T_GlueBuffer, InodeTracker) {
-  uint64_t inode = 0;
+  uint64_t inode_parent = 0;
   NameString name;
+  uint64_t inode = 0;
   InodeTracker::Cursor cursor = inode_tracker_.BeginEnumerate();
-  EXPECT_FALSE(inode_tracker_.Next(&cursor, &inode, &name));
-  EXPECT_FALSE(inode_tracker_.Next(&cursor, &inode, &name));
+  EXPECT_FALSE(inode_tracker_.NextEntry(&cursor, &inode_parent, &name));
+  EXPECT_FALSE(inode_tracker_.NextEntry(&cursor, &inode_parent, &name));
+  EXPECT_FALSE(inode_tracker_.NextInode(&cursor, &inode));
   inode_tracker_.EndEnumerate(&cursor);
 
   inode_tracker_.VfsGet(1, PathString(""));
   inode_tracker_.VfsGet(2, PathString("/foo"));
   inode_tracker_.VfsGet(4, PathString("/foo/bar"));
   cursor = inode_tracker_.BeginEnumerate();
-  int bitset = 0;
+  int bitset_entry = 0;
+  int bitset_inode = 0;
   for (unsigned i = 0; i < 3; ++i) {
-    EXPECT_TRUE(inode_tracker_.Next(&cursor, &inode, &name));
-    switch (inode) {
+    EXPECT_TRUE(inode_tracker_.NextEntry(&cursor, &inode_parent, &name));
+    EXPECT_TRUE(inode_tracker_.NextInode(&cursor, &inode));
+    switch (inode_parent) {
       case 0:
         EXPECT_EQ("", name.ToString());
-        bitset |= 1;
+        bitset_entry |= 1;
         break;
       case 1:
         EXPECT_EQ("foo", name.ToString());
-        bitset |= 2;
+        bitset_entry |= 2;
         break;
       case 2:
         EXPECT_EQ("bar", name.ToString());
-        bitset |= 4;
+        bitset_entry |= 4;
+        break;
+      default:
+        EXPECT_FALSE(true);
+    }
+    switch (inode) {
+      case 1:
+        bitset_inode |= 1;
+        break;
+      case 2:
+        bitset_inode |= 2;
+        break;
+      case 4:
+        bitset_inode |= 4;
         break;
       default:
         EXPECT_FALSE(true);
     }
   }
-  EXPECT_EQ(7, bitset);
-  EXPECT_FALSE(inode_tracker_.Next(&cursor, &inode, &name));
+  EXPECT_EQ(7, bitset_entry);
+  EXPECT_EQ(7, bitset_inode);
+  EXPECT_FALSE(inode_tracker_.NextEntry(&cursor, &inode_parent, &name));
+  EXPECT_FALSE(inode_tracker_.NextInode(&cursor, &inode));
   inode_tracker_.EndEnumerate(&cursor);
 }
 
