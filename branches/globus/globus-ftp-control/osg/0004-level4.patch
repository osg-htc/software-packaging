From d6bfd8e8b8e145f264022a979f443b9a72e403cd Mon Sep 17 00:00:00 2001
From: Matyas Selmeci <matyas@cs.wisc.edu>
Date: Fri, 12 Aug 2016 14:21:49 -0500
Subject: [PATCH 4/5] level4

---
 globus_ftp_control_data.c | 173 ++++++++++++++++++++++++++++++++++------------
 1 file changed, 128 insertions(+), 45 deletions(-)

diff --git a/globus_ftp_control_data.c b/globus_ftp_control_data.c
index 20f2a4e..6728a40 100644
--- a/globus_ftp_control_data.c
+++ b/globus_ftp_control_data.c
@@ -6732,10 +6732,17 @@ globus_l_ftp_data_eb_poll(
                               data_conn,
                               (globus_l_ftp_send_eof_entry_t *)tmp_ent);
                     globus_assert(res == GLOBUS_SUCCESS);
                 }
             }/* end while */
+            /* If there are leftover commands, add them back to the stripe's queue. */
+            while (!globus_fifo_empty(&remaining_command_q)) {
+                globus_fifo_enqueue(&stripe->command_q, globus_fifo_dequeue(&remaining_command_q));
+                globus_fifo_enqueue(&stripe->free_conn_q, globus_fifo_dequeue(&remaining_conn_q));
+            }
+            globus_fifo_destroy(&remaining_command_q);
+            globus_fifo_destroy(&remaining_conn_q);
         }
         else if(dc_handle->state == GLOBUS_FTP_DATA_STATE_CONNECT_READ
 		|| (dc_handle->state == GLOBUS_FTP_DATA_STATE_EOF &&
 		    transfer_handle->direction == GLOBUS_FTP_DATA_STATE_CONNECT_READ))
         {
@@ -6815,67 +6822,143 @@ globus_l_ftp_data_eb_poll(
                     entry = (globus_l_ftp_handle_table_entry_t *)
                                 globus_fifo_dequeue(&stripe->command_q);
 
                     data_conn = (globus_ftp_data_connection_t *)
                         globus_fifo_dequeue(&stripe->free_conn_q);
-                    /*
-                     *  set the entries offset to the offset on the
-                     *  data_conn.
-                     *  If user is requesting more bytes than are available
-                     *  on this connection set the length to bytes_ready
-                     */
-                    entry->whos_my_daddy = data_conn;
-                    entry->offset = data_conn->offset;
-                    if(entry->length > data_conn->bytes_ready)
+                    /* BB - See commentary in stream_stripe_poll above for general approach.
+                     *
+                     * Note, however, the approach to estimating the max_skip has changed.  This
+                     * is because the read-size for mode E (256KB) is different from the block
+                     * size used by the remote client.  Hence, we use a different heuristic to estimate
+                     * the block size -- we look for the minimum difference in initial offsets in the
+                     * connections.  If the initial offsets are 0MB, 10MB, 20MB, ..., we assume the
+                     * block size to be 10MB.  Now, there's no rule that the client will assign
+                     * initial blocks "nicely" like that example; however, looking at the minimum
+                     * observed difference, we'll always keep a conservative estimate and avoid
+                     * deadlocking the transfer.
+                    */
+                    globus_ftp_data_connection_t * tmp_conn;
+                    globus_off_t min_offset = data_conn->offset;
+                    globus_list_t * list;
+                    int conn_id = -1, conn_count = 0;
+                    for(list = stripe->all_conn_list;
+                        !globus_list_empty(list);
+                        list = globus_list_rest(list))
                     {
-                        entry->length = data_conn->bytes_ready;
+                        tmp_conn = (globus_ftp_data_connection_t *)globus_list_first(list);
+                        if ((tmp_conn->offset < min_offset) && (!tmp_conn->eod)) {
+                            min_offset = tmp_conn->offset;
+                        }
+                        if (conn_id < 0) {
+                            if (tmp_conn->offset == data_conn->offset) conn_id = conn_count;
+                            else conn_count++;
+                        }
+                        //printf("BB - Stripe %u, offset %u.\n", stripe_count, tmp_conn->offset);
                     }
 
-                    if(transfer_handle->order_data)
-                    {                        
-                        /* forcing ordered data */
-                        globus_off_t                     want_offset;
+                    if ((data_conn->smallest_offset < 0) || (data_conn->offset < data_conn->smallest_offset)) {
+                        data_conn->smallest_offset = data_conn->offset;
+                        //printf("BB - conn %d - smallest offset: %ld\n", conn_id, data_conn->smallest_offset);
+                        for (list = stripe->all_conn_list;
+                             !globus_list_empty(list);
+                             list = globus_list_rest(list))
+                        {
+                            tmp_conn = (globus_ftp_data_connection_t *)globus_list_first(list);
+                            if (tmp_conn->smallest_offset < 0) {continue;}
+                            globus_list_t *list2;
+                            for (list2 = stripe->all_conn_list;
+                                !globus_list_empty(list2);
+                                list2 = globus_list_rest(list2))
+                            {
+                                globus_ftp_data_connection_t * tmp_conn2 = (globus_ftp_data_connection_t *)globus_list_first(list2);
+                                if (tmp_conn2->smallest_offset < 0) {continue;}
+                                globus_off_t diff = (tmp_conn2->smallest_offset - tmp_conn->smallest_offset);
+                                if (diff < 0) {diff = -diff;}
+                                if (diff == 0) {continue;}
+                                if (diff < stripe->est_block_size) {stripe->est_block_size = diff;}
+                            }
+                        }
+                    }
+
+                    stripe->largest_entry = (entry->length > stripe->largest_entry) ? entry->length : stripe->largest_entry;
+                    if (stripe->est_block_size < stripe->largest_entry) {
+                        stripe->est_block_size = stripe->largest_entry;
+                    }
+                    stripe->largest_connection_count = (stripe->connection_count > stripe->largest_connection_count) ? stripe->connection_count : stripe->largest_connection_count;
+                    globus_off_t max_skip = 5*stripe->est_block_size;
+                    if (max_skip < (stripe->largest_connection_count+1)*stripe->est_block_size) {
+                        max_skip = (stripe->largest_connection_count+1)*stripe->est_block_size;
+                    }
+                    if (max_skip < 5*1024*1024) {max_skip = 5*1024*1024;}
+
+                    if ((stripe->connection_count < stripe->largest_connection_count) || (data_conn->offset - min_offset <= max_skip)) {
+
+                        /*
+                         *  set the entries offset to the offset on the
+                         *  data_conn.
+                         *  If user is requesting more bytes than are available
+                         *  on this connection set the length to bytes_ready
+                         */
+                        entry->whos_my_daddy = data_conn;
+                        entry->offset = data_conn->offset;
+                        if(entry->length > data_conn->bytes_ready)
+                        {
+                            entry->length = data_conn->bytes_ready;
+                        }
+
+                        if(transfer_handle->order_data)
+                        {
+                            /* forcing ordered data */
+                            globus_off_t                     want_offset;
+
+                            checked_order = GLOBUS_TRUE;
+                            /* min offset is the last read offset.  if no read
+                             * yet, set to user provided start offset. */
+                            want_offset = ((transfer_handle->order_next_offset == 0) ?
+                                transfer_handle->order_start_offset : transfer_handle->order_next_offset);
 
-                        checked_order = GLOBUS_TRUE;
-                        /* min offset is the last read offset.  if no read 
-                         * yet, set to user provided start offset. */
-                        want_offset = ((transfer_handle->order_next_offset == 0) ? 
-                            transfer_handle->order_start_offset : transfer_handle->order_next_offset);
-                        
-                        /* if this stream has the offset we want, read from it, 
-                         * otherwise queue up the read */
-                        if(data_conn->offset == want_offset)
+                            /* if this stream has the offset we want, read from it,
+                             * otherwise queue up the read */
+                            if(data_conn->offset == want_offset)
+                            {
+                                do_read = GLOBUS_TRUE;
+                            }
+                            else
+                            {
+                                do_read = GLOBUS_FALSE;
+                                globus_fifo_enqueue(&remaining_command_q, entry);
+                                globus_fifo_enqueue(&remaining_conn_q, data_conn);
+                            }
+                        }
+                        else
                         {
                             do_read = GLOBUS_TRUE;
                         }
-                        else
+
+                        if(do_read)
                         {
-                            do_read = GLOBUS_FALSE;
-                            globus_fifo_enqueue(&remaining_command_q, entry);
-                            globus_fifo_enqueue(&remaining_conn_q, data_conn);
+                            /*
+                             *  register a read
+                             */
+                            res = globus_io_register_read(
+                                      &data_conn->io_handle,
+                                      entry->buffer,
+                                      entry->length,
+                                      entry->length,
+                                      globus_l_ftp_eb_read_callback,
+                                      (void *)entry);
+                            globus_assert(res == GLOBUS_SUCCESS);
+                            none_read = GLOBUS_FALSE;
+                            transfer_handle->order_waiting = 0;
                         }
                     }
                     else
                     {
-                        do_read = GLOBUS_TRUE;
-                    }
-
-                    if(do_read)
-                    {
-                        /*
-                         *  register a read
-                         */
-                        res = globus_io_register_read(
-                                  &data_conn->io_handle,
-                                  entry->buffer,
-                                  entry->length,
-                                  entry->length,
-                                  globus_l_ftp_eb_read_callback,
-                                  (void *)entry);
-                        globus_assert(res == GLOBUS_SUCCESS);
-                        none_read = GLOBUS_FALSE;
-                        transfer_handle->order_waiting = 0;
+                        //printf("BB - mode E - conn id %d, offset: %lu, min_offset: %lu, diff: %lu, max diff: %lu outstanding connections: %d est block size: %d.\n", conn_id, data_conn->offset, min_offset, data_conn->offset - min_offset, max_skip, stripe->connection_count, stripe->est_block_size);
+                        //printf("BB - Adding entry to remaining queue.\n");
+                        globus_fifo_enqueue(&remaining_command_q, entry);
+                        globus_fifo_enqueue(&remaining_conn_q, data_conn);
                     }
                 }
                 /*
                  *  if we have not hit EOF and there are no available data
                  *  connections
-- 
2.6.3

