From 62fa23c017d4e623086fa7682eaec6caa40bf0c5 Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelman@morgridge.org>
Date: Sat, 11 Dec 2021 21:12:39 -0600
Subject: [PATCH 01/11] Add mapfile support as a separate class to the XrdVoms
 code.

---
 src/XrdVoms.cmake             |   1 +
 src/XrdVoms/XrdVomsHttp.cc    |   5 +-
 src/XrdVoms/XrdVomsMapfile.cc | 359 ++++++++++++++++++++++++++++++++++
 src/XrdVoms/XrdVomsMapfile.hh |  86 ++++++++
 src/XrdVoms/XrdVomsgsi.cc     |  10 +-
 5 files changed, 459 insertions(+), 2 deletions(-)
 create mode 100644 src/XrdVoms/XrdVomsMapfile.cc
 create mode 100644 src/XrdVoms/XrdVomsMapfile.hh

diff --git a/src/XrdVoms.cmake b/src/XrdVoms.cmake
index bc4a4229c7d..1951a376eb0 100644
--- a/src/XrdVoms.cmake
+++ b/src/XrdVoms.cmake
@@ -13,6 +13,7 @@ add_library(
    ${LIB_XRD_VOMS}
    MODULE
    ${CMAKE_SOURCE_DIR}/src/XrdVoms/XrdVomsFun.cc
+   ${CMAKE_SOURCE_DIR}/src/XrdVoms/XrdVomsMapfile.cc
    ${CMAKE_SOURCE_DIR}/src/XrdVoms/XrdVomsgsi.cc
    ${CMAKE_SOURCE_DIR}/src/XrdVoms/XrdVomsHttp.cc )
 
diff --git a/src/XrdVoms/XrdVomsHttp.cc b/src/XrdVoms/XrdVomsHttp.cc
index 4e7131bc363..5c2532707df 100644
--- a/src/XrdVoms/XrdVomsHttp.cc
+++ b/src/XrdVoms/XrdVomsHttp.cc
@@ -29,6 +29,7 @@
 
 // This code is based on
 
+#include "XrdVomsMapfile.hh"
 #include "XrdVomsFun.hh"
 
 /** @brief This code is based on the basic architecture shown in
@@ -142,7 +143,9 @@ XrdHttpSecXtractor *XrdHttpGetSecXtractor(XrdHttpSecXtractorArgs)
 
 // Now return the interface object
 //
-   return (XrdHttpSecXtractor *)new XrdVomsHttp(eDest, *vomsFun);
+   auto base = static_cast<XrdHttpSecXtractor *>(new XrdVomsHttp(eDest, *vomsFun));
+   auto wrapper = static_cast<XrdHttpSecXtractor *>(XrdVomsMapfile::Configure(eDest, base));
+   return wrapper ? wrapper : base;
 }
 
 /******************************************************************************/
diff --git a/src/XrdVoms/XrdVomsMapfile.cc b/src/XrdVoms/XrdVomsMapfile.cc
new file mode 100644
index 00000000000..f118dee63c5
--- /dev/null
+++ b/src/XrdVoms/XrdVomsMapfile.cc
@@ -0,0 +1,359 @@
+/******************************************************************************/
+/*                                                                            */
+/*                        X r d V o m s M a p f i l e . c c                   */
+/*                                                                            */
+/* This file is part of the XRootD software suite.                            */
+/*                                                                            */
+/* XRootD is free software: you can redistribute it and/or modify it under    */
+/* the terms of the GNU Lesser General Public License as published by the     */
+/* Free Software Foundation, either version 3 of the License, or (at your     */
+/* option) any later version.                                                 */
+/*                                                                            */
+/* XRootD is distributed in the hope that it will be useful, but WITHOUT      */
+/* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or      */
+/* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public       */
+/* License for more details.                                                  */
+/*                                                                            */
+/* You should have received a copy of the GNU Lesser General Public License   */
+/* along with XRootD in a file called COPYING.LESSER (LGPL license) and file  */
+/* COPYING (GPL license).  If not, see <http://www.gnu.org/licenses/>.        */
+/*                                                                            */
+/* The copyright holder's institutional names and contributor's names may not */
+/* be used to endorse or promote products derived from this software without  */
+/* specific prior written permission of the institution or contributor.       */
+/******************************************************************************/
+
+#include "XrdVoms/XrdVomsMapfile.hh"
+
+#include "XrdOuc/XrdOucEnv.hh"
+#include "XrdOuc/XrdOucString.hh"
+#include "XrdOuc/XrdOucStream.hh"
+#include "XrdSec/XrdSecEntity.hh"
+#include "XrdSys/XrdSysError.hh"
+
+#include <memory>
+#include <fstream>
+#include <sstream>
+#include <vector>
+#include <string>
+#include <fcntl.h>
+
+
+bool XrdVomsMapfile::tried_configure = false;
+std::unique_ptr<XrdVomsMapfile> XrdVomsMapfile::mapper;
+
+namespace {
+
+std::string
+PathToString(const std::vector<std::string> &path)
+{
+    if (path.empty()) {return "/";}
+    std::stringstream ss;
+    for (const auto &entry : path) {
+        ss << "/" << entry;
+    }
+
+    return ss.str();
+}
+
+}
+
+
+XrdVomsMapfile::XrdVomsMapfile(XrdSysError *erp, XrdHttpSecXtractor *xrdvoms,
+    const std::string &mapfile)
+    : m_mapfile(mapfile), m_xrdvoms(xrdvoms), m_edest(erp)
+{
+    m_last_update.store(0, std::memory_order_relaxed);
+}
+
+
+bool
+XrdVomsMapfile::ParseMapfile(const std::string &mapfile)
+{
+    std::ifstream fstr(mapfile);
+    if (!fstr.is_open()) {
+        m_edest->Emsg("ParseMapfile", "Failed to open file", mapfile.c_str(), strerror(errno));
+        return false;
+    }
+    std::shared_ptr<std::vector<MapfileEntry>> entries(new std::vector<MapfileEntry>());
+    for (std::string line; std::getline(fstr, line); ) {
+        MapfileEntry entry;
+        if (ParseLine(line, entry.m_path, entry.m_target) && !entry.m_path.empty()) {
+            if (m_edest->getMsgMask() & LogMask::Debug) {
+                m_edest->Log(LogMask::Debug, "ParseMapfile", PathToString(entry.m_path).c_str(), "->", entry.m_target.c_str());
+            }
+            entries->emplace_back(entry);
+        }
+    }
+    m_entries = entries;
+    return true;
+}
+
+
+bool
+XrdVomsMapfile::Reconfigure() {
+    auto now = time(NULL);
+    auto retval = true;
+    std::stringstream ss;
+    ss << "Last update " << m_last_update.load(std::memory_order_relaxed) << ", " << now;
+    m_edest->Log(LogMask::Debug, "VOMS Mapfile", ss.str().c_str());
+    if (now > m_last_update.load(std::memory_order_relaxed) + 30) {
+        retval = ParseMapfile(m_mapfile);
+        m_last_update.store(now, std::memory_order_relaxed);
+    }
+    return retval;
+}
+
+
+bool
+XrdVomsMapfile::ParseLine(const std::string &line, std::vector<std::string> &entry, std::string &target)
+{
+    bool began_entry = false;
+    bool finish_entry = false;
+    bool began_target = false;
+    std::string element;
+    element.reserve(16);
+    for (size_t idx=0; idx<line.size(); idx++) {
+        auto txt = line[idx];
+        if (!began_entry && !finish_entry) {
+            if (txt == '#') {return false;}
+            else if (txt == '"') {began_entry = true;}
+            else if (!isspace(txt)) {return false;}
+            continue;
+        } else if (began_entry && !finish_entry) {
+            if (txt == '\\') {
+                if (idx + 1 == line.size()) {return false;}
+                idx++;
+                auto escaped_char = line[idx];
+                switch (escaped_char) {
+                case '\'':
+                    element += "'";
+                    break;
+                case '\"':
+                    element += "\"";
+                    break;
+                case '/':
+                    element += "/";
+                    break;
+                case 'f':
+                    element += "\f";
+                    break;
+                case 'n':
+                    element += "\n";
+                    break;
+                case 'r':
+                    element += "\r";
+                    break;
+                case 't':
+                    element += "\t";
+                    break;
+                default:
+                    return false;
+                };
+            } else if (txt == '"') {
+                if (!element.empty()) entry.push_back(element);
+                finish_entry = true;
+            } else if (txt == '/') {
+                if (!element.empty()) entry.push_back(element);
+                element.clear();
+            } else if (isprint(txt)) {
+                element += txt;
+            } else {
+                return false;
+            }
+        } else if (!began_target) {
+            if (isspace(txt)) {continue;}
+            began_target = true;
+        }
+        if (began_target) {
+            if (isprint(txt)) {
+                target += txt;
+            } else if (isspace(txt)) {
+                return true;
+            } else {
+                return false;
+            }
+        }
+    }
+    return true;
+}
+
+
+std::string
+XrdVomsMapfile::Map(const std::vector<string> &fqan)
+{
+    decltype(m_entries) entries = m_entries;
+    if (!entries) {return "";}
+
+    if (m_edest && (m_edest->getMsgMask() & LogMask::Debug)) {
+        m_edest->Log(LogMask::Debug, "VOMSMapfile", "Mapping VOMS FQAN", PathToString(fqan).c_str());
+    }
+
+    for (const auto &entry : *entries) {
+        if (Compare(entry, fqan)) {
+            if (m_edest && (m_edest->getMsgMask() & LogMask::Debug)) {
+                m_edest->Log(LogMask::Debug, "VOMSMapfile", "Mapped FQAN to target", entry.m_target.c_str());
+            }
+            return entry.m_target;
+        }
+    }
+    return "";
+}
+
+
+bool
+XrdVomsMapfile::Compare(const MapfileEntry &entry, const std::vector<std::string> &fqan)
+{
+    if (entry.m_path.empty()) {return false;}
+
+    // A more specific mapfile entry cannot match a generic FQAN
+    if (fqan.size() < entry.m_path.size()) {return false;}
+
+    XrdOucString fqan_element;
+    for (size_t idx=0; idx<entry.m_path.size(); idx++) {
+        fqan_element.assign(fqan[idx].c_str(), 0);
+        const auto &path_element = entry.m_path[idx];
+        if (!fqan_element.matches(path_element.c_str())) {return false;}
+    }
+    if (fqan.size() == entry.m_path.size()) {return true;}
+    if (entry.m_path.back() == "*") {return true;}
+    return false;
+}
+
+
+std::vector<std::string>
+XrdVomsMapfile::MakePath(const XrdOucString &group)
+{
+    int from = 0;
+    XrdOucString entry;
+    std::vector<std::string> path;
+    path.reserve(4);
+    while ((from = group.tokenize(entry, from, '/')) != -1) {
+        if (entry.empty()) continue;
+        path.emplace_back(entry.c_str());
+    }
+    return path;
+}
+
+
+int
+XrdVomsMapfile::GetSecData(XrdLink * lnk, XrdSecEntity &entity, SSL *ssl)
+{
+    if (!m_xrdvoms) return -1;
+
+    auto retval = m_xrdvoms->GetSecData(lnk, entity, ssl);
+    if (retval) return retval;
+
+    return Apply(entity);
+}
+
+
+int
+XrdVomsMapfile::Apply(XrdSecEntity &entity)
+{
+    Reconfigure();
+
+    int from_vorg = 0, from_role = 0, from_grps = 0;
+    XrdOucString vorg = entity.vorg, entry_vorg;
+    XrdOucString role = entity.role, entry_role;
+    XrdOucString grps = entity.grps, entry_grps;
+    if (m_edest) m_edest->Log(LogMask::Debug, "VOMSMapfile", "Applying VOMS mapfile to incoming credential");
+    while (((from_vorg = vorg.tokenize(entry_vorg, from_vorg, ' ')) != -1) &&
+           ((from_role = role.tokenize(entry_role, from_role, ' ')) != -1) &&
+           ((from_grps = grps.tokenize(entry_grps, from_grps, ' ')) != -1))
+    {
+        auto fqan = MakePath(entry_grps);
+        if (fqan.empty()) {continue;}
+
+        // By convention, the root group should be the same as the VO name; however,
+        // the VOMS mapfile makes this assumption.  To be secure, enforce it.
+        if (strcmp(fqan[0].c_str(), entry_vorg.c_str())) {continue;}
+
+        fqan.emplace_back(std::string("Role=") + entry_role.c_str());
+        fqan.emplace_back("Capability=NULL");
+        std::string username;
+        if (!(username = Map(fqan)).empty()) {
+            if (entity.name) {free(entity.name);}
+            entity.name = strdup(username.c_str());
+            break;
+        }
+    }
+
+    return 0;
+}
+
+
+XrdVomsMapfile *
+XrdVomsMapfile::Get()
+{
+    return mapper.get();
+}
+
+
+XrdVomsMapfile *
+XrdVomsMapfile::Configure(XrdSysError *erp, XrdHttpSecXtractor *xtractor)
+{
+    if (tried_configure) {
+        auto result = mapper.get();
+        if (result) {
+            result->SetExtractor(xtractor);
+            result->SetErrorStream(erp);
+        }
+        return result;
+    }
+
+    tried_configure = true;
+
+    // Set default mask for logging.
+    if (erp) erp->setMsgMask(LogMask::Error | LogMask::Warning);
+
+    char *config_filename = nullptr;
+    if (!XrdOucEnv::Import("XRDCONFIGFN", config_filename)) {
+        return nullptr;
+    }
+    XrdOucStream stream(erp, getenv("XRDINSTANCE"));
+
+    int cfg_fd;
+    if ((cfg_fd = open(config_filename, O_RDONLY, 0)) < 0) {
+        if (erp) erp->Emsg("Config", errno, "open config file", config_filename);
+        return nullptr;
+    }
+    stream.Attach(cfg_fd);
+    char *var;
+    std::string map_filename;
+    while ((var = stream.GetMyFirstWord())) {
+        if (!strcmp(var, "voms.mapfile")) {
+            auto val = stream.GetWord();
+            if (!val || !val[0]) {
+                if (erp) erp->Emsg("Config", "VOMS mapfile not specified");
+                return nullptr;
+            }
+            map_filename = val;
+        } else if (!strcmp(var, "voms.trace")) {
+            auto val = stream.GetWord();
+            if (!val || !val[0]) {
+                if (erp) erp->Emsg("Config", "VOMS logging level not specified");
+                return nullptr;
+            }
+            if (erp) erp->setMsgMask(0);
+            if (erp) do {
+                if (!strcmp(val, "all")) {erp->setMsgMask(erp->getMsgMask() | LogMask::All);}
+                else if (!strcmp(val, "error")) {erp->setMsgMask(erp->getMsgMask() | LogMask::Error);}
+                else if (!strcmp(val, "warning")) {erp->setMsgMask(erp->getMsgMask() | LogMask::Warning);}
+                else if (!strcmp(val, "info")) {erp->setMsgMask(erp->getMsgMask() | LogMask::Info);}
+                else if (!strcmp(val, "debug")) {erp->setMsgMask(erp->getMsgMask() | LogMask::Debug);}
+                else if (!strcmp(val, "none")) {erp->setMsgMask(0);}
+                else {erp->Emsg("Config", "voms.trace encountered an unknown directive:", val);}
+                val = stream.GetWord();
+            } while (val);
+        }
+    }
+
+    if (!map_filename.empty()) {
+        if (erp) erp->Emsg("Config", "Will initialize VOMS mapfile", map_filename.c_str());
+        mapper.reset(new XrdVomsMapfile(erp, xtractor, map_filename));
+        mapper->Reconfigure();
+    }
+
+    return mapper.get();
+}
diff --git a/src/XrdVoms/XrdVomsMapfile.hh b/src/XrdVoms/XrdVomsMapfile.hh
new file mode 100644
index 00000000000..7273f0b3376
--- /dev/null
+++ b/src/XrdVoms/XrdVomsMapfile.hh
@@ -0,0 +1,86 @@
+/******************************************************************************/
+/*                                                                            */
+/*                        X r d V o m s M a p f i l e . h h                   */
+/*                                                                            */
+/* This file is part of the XRootD software suite.                            */
+/*                                                                            */
+/* XRootD is free software: you can redistribute it and/or modify it under    */
+/* the terms of the GNU Lesser General Public License as published by the     */
+/* Free Software Foundation, either version 3 of the License, or (at your     */
+/* option) any later version.                                                 */
+/*                                                                            */
+/* XRootD is distributed in the hope that it will be useful, but WITHOUT      */
+/* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or      */
+/* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public       */
+/* License for more details.                                                  */
+/*                                                                            */
+/* You should have received a copy of the GNU Lesser General Public License   */
+/* along with XRootD in a file called COPYING.LESSER (LGPL license) and file  */
+/* COPYING (GPL license).  If not, see <http://www.gnu.org/licenses/>.        */
+/*                                                                            */
+/* The copyright holder's institutional names and contributor's names may not */
+/* be used to endorse or promote products derived from this software without  */
+/* specific prior written permission of the institution or contributor.       */
+/******************************************************************************/
+
+#include "XrdHttp/XrdHttpSecXtractor.hh"
+
+#include "XrdOuc/XrdOucString.hh"
+
+#include <atomic>
+#include <memory>
+#include <string>
+#include <vector>
+
+class XrdVomsMapfile : public XrdHttpSecXtractor {
+
+public:
+    static XrdVomsMapfile *Configure(XrdSysError *, XrdHttpSecXtractor *);
+    static XrdVomsMapfile *Get();
+
+    virtual int GetSecData(XrdLink *, XrdSecEntity &, SSL *);
+    int Apply(XrdSecEntity &);
+
+    /* Base class returns an error if these aren't overridden */
+    virtual int Init(SSL_CTX *, int) {return 0;}
+    virtual int InitSSL(SSL *ssl, char *cadir) {return 0;}
+    virtual int FreeSSL(SSL *) {return 0;}
+
+private:
+    bool Reconfigure();
+    void SetErrorStream(XrdSysError *erp) {if (erp) {m_edest = erp;}}
+    void SetExtractor(XrdHttpSecXtractor *xtractor) {if (xtractor) {m_xrdvoms = xtractor;}}
+
+    XrdVomsMapfile(XrdSysError *erp, XrdHttpSecXtractor *xrdvoms, const std::string &mapfile);
+
+    enum LogMask {
+        Debug = 0x01,
+        Info = 0x02,
+        Warning = 0x04,
+        Error = 0x08,
+        All = 0xff
+    };
+
+    struct MapfileEntry {
+        std::vector<std::string> m_path;
+        std::string m_target;
+    };
+
+    bool ParseMapfile(const std::string &mapfile);
+    bool ParseLine(const std::string &line, std::vector<std::string> &entry, std::string &target);
+
+    std::string Map(const std::vector<std::string> &fqan);
+    bool Compare(const MapfileEntry &entry, const std::vector<std::string> &fqan);
+    std::vector<std::string> MakePath(const XrdOucString &group);
+
+    std::string m_mapfile;
+    std::shared_ptr<const std::vector<MapfileEntry>> m_entries;
+    XrdHttpSecXtractor *m_xrdvoms{nullptr};
+    XrdSysError *m_edest{nullptr};
+
+    std::atomic<time_t> m_last_update;
+
+    // Singleton
+    static std::unique_ptr<XrdVomsMapfile> mapper;
+    static bool tried_configure;
+};
diff --git a/src/XrdVoms/XrdVomsgsi.cc b/src/XrdVoms/XrdVomsgsi.cc
index 293f9363d3b..b054004a9dc 100644
--- a/src/XrdVoms/XrdVomsgsi.cc
+++ b/src/XrdVoms/XrdVomsgsi.cc
@@ -30,6 +30,8 @@
 #include "XrdSys/XrdSysError.hh"
 #include "XrdSys/XrdSysLogger.hh"
 
+#include "XrdVomsMapfile.hh"
+
 #include "XrdVomsFun.hh"
 
 /******************************************************************************/
@@ -57,7 +59,11 @@ int XrdSecgsiVOMSFun(XrdSecEntity &ent)
 {
 // Make sure we were initialized. If so, invoke the function and return result.
 //
-   return (vomsFun ? vomsFun->VOMSFun(ent) : -1);
+   int retval = (vomsFun ? vomsFun->VOMSFun(ent) : -1);
+   if (retval == -1) {return retval;}
+
+   auto mapfile = XrdVomsMapfile::Get();
+   return mapfile ? mapfile->Apply(ent) : retval;
 }
 }
 
@@ -74,6 +80,8 @@ int XrdSecgsiVOMSInit(const char *cfg)
    static XrdSysLogger gLogger;
    static XrdSysError gDest(&gLogger, "XrdVoms");
 
+   XrdVomsMapfile::Configure(&gDest, nullptr);
+
 // Allocate a new Voms object
 //
    vomsFun = new XrdVomsFun(gDest);

From 7b59dc126d969f83fd50faf87bdc278482b3926e Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelman@morgridge.org>
Date: Mon, 17 Jan 2022 10:40:50 -0600
Subject: [PATCH 02/11] Fixup: Add const fixes due to ABI change revert.

---
 src/XrdVoms/XrdVomsMapfile.cc | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/src/XrdVoms/XrdVomsMapfile.cc b/src/XrdVoms/XrdVomsMapfile.cc
index f118dee63c5..d49dc361261 100644
--- a/src/XrdVoms/XrdVomsMapfile.cc
+++ b/src/XrdVoms/XrdVomsMapfile.cc
@@ -228,8 +228,11 @@ XrdVomsMapfile::MakePath(const XrdOucString &group)
     XrdOucString entry;
     std::vector<std::string> path;
     path.reserve(4);
-    while ((from = group.tokenize(entry, from, '/')) != -1) {
-        if (entry.empty()) continue;
+        // The const'ness of the tokenize method as declared is incorrect; we use
+        // const_cast here to avoid fixing the XrdOucString header (which would break
+        // the ABI).
+    while ((from = const_cast<XrdOucString&>(group).tokenize(entry, from, '/')) != -1) {
+        if (entry.length() == 0) continue;
         path.emplace_back(entry.c_str());
     }
     return path;

From 156baf3e7c61bb05e9b8ef49ba403498f7f5c1dc Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelman@morgridge.org>
Date: Mon, 17 Jan 2022 08:58:11 -0600
Subject: [PATCH 03/11] Allow explicit grid-mapfile entries to override
 voms-mapfile.

If there's an entry found in the corresponding grid-mapfile, then
that is considered "more specific" and overrides the "less specific"
voms-mapfile entry.  E.g., a mapping to `bbockelm` should be picked
over a generic `cms`.

To differentiate between an explicit mapping and the fallbacks
generated for the plugins, we use the entity's extended attribute
mechanism.
---
 src/XrdHttp/XrdHttpSecurity.cc     |  2 ++
 src/XrdSecgsi/XrdSecProtocolgsi.cc |  2 ++
 src/XrdVoms/XrdVomsMapfile.cc      | 12 ++++++++++++
 3 files changed, 16 insertions(+)

diff --git a/src/XrdHttp/XrdHttpSecurity.cc b/src/XrdHttp/XrdHttpSecurity.cc
index af1c04c1530..e187851c089 100644
--- a/src/XrdHttp/XrdHttpSecurity.cc
+++ b/src/XrdHttp/XrdHttpSecurity.cc
@@ -26,6 +26,7 @@
 #include "XrdCrypto/XrdCryptoX509Chain.hh"
 #include "XrdCrypto/XrdCryptosslAux.hh"
 #include "XrdCrypto/XrdCryptoFactory.hh"
+#include "XrdSec/XrdSecEntityAttr.hh"
 #include "XrdTls/XrdTlsPeerCerts.hh"
 #include "XrdTls/XrdTlsContext.hh"
 #include "XrdOuc/XrdOucGMap.hh"
@@ -164,6 +165,7 @@ XrdHttpProtocol::HandleGridMap(XrdLink* lp)
       TRACEI(DEBUG, " Mapping name: '" << SecEntity.moninfo << "' --> " << bufname);
       if (SecEntity.name) free(SecEntity.name);
       SecEntity.name = strdup(bufname);
+      SecEntity.eaAPI->Add("gridmap.name", bufname, true);
     }
     else {
       TRACEI(ALL, " Mapping name: " << SecEntity.moninfo << " Failed. err: " << mape);
diff --git a/src/XrdSecgsi/XrdSecProtocolgsi.cc b/src/XrdSecgsi/XrdSecProtocolgsi.cc
index b4b704b4505..e93deb91223 100644
--- a/src/XrdSecgsi/XrdSecProtocolgsi.cc
+++ b/src/XrdSecgsi/XrdSecProtocolgsi.cc
@@ -43,6 +43,7 @@
 #include "XrdVersion.hh"
 
 #include "XrdNet/XrdNetAddr.hh"
+#include "XrdSec/XrdSecEntityAttr.hh"
 #include "XrdSys/XrdSysHeaders.hh"
 #include "XrdSys/XrdSysLogger.hh"
 #include "XrdSys/XrdSysError.hh"
@@ -1953,6 +1954,7 @@ int XrdSecProtocolgsi::Authenticate(XrdSecCredentials *cred,
                DEBUG("user mapping lookup successful: name is '"<<name<<"'");
             }
             Entity.name = strdup(name.c_str());
+            Entity.eaAPI->Add("gridmap.name", name.c_str(), true);
          }
       }
       // If not set, use DN
diff --git a/src/XrdVoms/XrdVomsMapfile.cc b/src/XrdVoms/XrdVomsMapfile.cc
index d49dc361261..98849fa48f9 100644
--- a/src/XrdVoms/XrdVomsMapfile.cc
+++ b/src/XrdVoms/XrdVomsMapfile.cc
@@ -29,6 +29,7 @@
 #include "XrdOuc/XrdOucString.hh"
 #include "XrdOuc/XrdOucStream.hh"
 #include "XrdSec/XrdSecEntity.hh"
+#include "XrdSec/XrdSecEntityAttr.hh"
 #include "XrdSys/XrdSysError.hh"
 
 #include <memory>
@@ -256,6 +257,17 @@ XrdVomsMapfile::Apply(XrdSecEntity &entity)
 {
     Reconfigure();
 
+    // In current use cases, the gridmap results take precedence over the voms-mapfile
+    // results.  However, the grid mapfile plugins often will populate the name attribute
+    // with a reasonable default (DN or DN hash) if the mapping fails, meaning we can't
+    // simply look at entity.name; instead, we look at an extended attribute that is only
+    // set when the mapfile is used to generate the name.
+    std::string gridmap_name;
+    auto gridmap_success = entity.eaAPI->Get("gridmap.name", gridmap_name);
+    if (gridmap_success) {
+        return 0;
+    }
+
     int from_vorg = 0, from_role = 0, from_grps = 0;
     XrdOucString vorg = entity.vorg, entry_vorg;
     XrdOucString role = entity.role, entry_role;

From fb22ea315fd12641565cc04bcc08d86bf8e5b615 Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelman@morgridge.org>
Date: Mon, 17 Jan 2022 09:27:05 -0600
Subject: [PATCH 04/11] Add initial README file covering the syntax and
 behavior of the mapfile.

---
 src/XrdVoms/README.md | 91 +++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 91 insertions(+)
 create mode 100644 src/XrdVoms/README.md

diff --git a/src/XrdVoms/README.md b/src/XrdVoms/README.md
new file mode 100644
index 00000000000..e4a15d77240
--- /dev/null
+++ b/src/XrdVoms/README.md
@@ -0,0 +1,91 @@
+
+VOMS Mapping
+============
+
+The VOMS plugin can now populate the XRootD session's `name` attribute from a
+mapping file (the "voms-mapfile").  Filesystems which rely on the username
+in addition to the XRootD authorization can utilize this name to make authorization
+and file ownership decisions.
+
+Note the plugins have the following precedence for the `name` attribute:
+
+- Explicit entry in the grid-mapfile.
+- Entry in the voms-mapfile.
+- Default auto-generated name for the grid mapfile.
+
+Administrators may desire to disable the auto-generated name as it likely does
+not match any Unix username on the system.
+
+Configuration
+-------------
+
+There are two configuration options that control the plugin:
+
+```
+voms.mapfile FILENAME
+```
+
+Enables the mapping functionality and uses the file at FILENAME as the voms-mapfile.
+The mapfile is reloaded every 30 seconds; the daemon does not need to be restarted
+to pick up changes.
+
+```
+voms.trace [none|all|debug|info|warning|error]+
+```
+
+Enable debugging of the VOMS mapfile logic.  Options are additive and multiple can be
+given.
+
+Format and Matching Details
+---------------------------
+
+The file format ignores empty lines; a line beginning with the hash (`#`) are considered
+comments and ignored.
+
+Otherwise, each line specifies a mapping from an expression to a Unix username in the
+following form:
+
+```
+"EXPRESSION" USERNAME
+```
+
+If the session has a VOMS FQAN matching EXPRESSION then the session's name will be set
+to USERNAME.
+
+Examples of the EXPRESSION include:
+
+```
+/cms/Role=production/Capability=NULL
+/atlas/usatlas/Role=pilot/Capability=NULL
+```
+
+Expressions may also have wildcards (`*`) present.  The wildcard can serve as
+two roles:
+
+- If the expression ends with `/*`, then any remaining portion of the attribute
+  is matched.  For example, `/cms/*` matches `/cms/Role=NULL/Capability=NULL` and
+  `/cms/uscms/Role=pilot/Capability=NULL`.
+- If the wildcard is inside a path hierarchy, it allows any character inisde the
+  path.  For example, `/fermilab/*/Role=pilot/Capability=NULL` matches both
+  `/fermilab/dune/Role=pilot/Capability=NULL` and `/fermilab/des/Role=pilot/Capability=NULL`
+  but not `/fermilab/Role=pilot/Capability=NULL`.
+
+Several escape sequences are supported within the expression:
+
+- `\'`: a single quote character (`'`).
+- `\"`: a double quote character (`"`).
+- `\\`: a backwards slash (`\`).
+- `\/`: a forward slash that is not a path separator (`/`)
+- `\f`: a formfeed
+- `\n`: a newline
+- `\r`: a carriage return
+- `\t`: a tab character.
+
+The use of these escape sequences are discouraged as it's unclear whether other software
+is able to safely handle them.  Unicode and extended 8-bit ASCII are not supported at this
+time.
+
+Note, as is tradition, the name of the VO in the VOMS FQAN must match the first group name.
+That is, if the `cms` VO issues a FQAN of the form `/atlas/Role=pilot/Capability=NULL` then
+the FQAN is ignored.
+

From 29fa30a2271a45b4a4cead5ba78686c767ede3d2 Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelman@morgridge.org>
Date: Mon, 17 Jan 2022 10:18:03 -0600
Subject: [PATCH 05/11] Overhaul reload strategy to use a maintenance thread.

Instead of doing the reload of the mapfile in-line, add a new maintenance
thread that will periodically reload the mapfile (if and only if a change
is detected in the modification time of the mapfile).
---
 src/XrdVoms/XrdVomsMapfile.cc | 150 +++++++++++++++++++++++++++++-----
 src/XrdVoms/XrdVomsMapfile.hh |  27 +++++-
 2 files changed, 155 insertions(+), 22 deletions(-)

diff --git a/src/XrdVoms/XrdVomsMapfile.cc b/src/XrdVoms/XrdVomsMapfile.cc
index 98849fa48f9..aa4fef6d913 100644
--- a/src/XrdVoms/XrdVomsMapfile.cc
+++ b/src/XrdVoms/XrdVomsMapfile.cc
@@ -31,6 +31,8 @@
 #include "XrdSec/XrdSecEntity.hh"
 #include "XrdSec/XrdSecEntityAttr.hh"
 #include "XrdSys/XrdSysError.hh"
+#include "XrdSys/XrdSysFD.hh"
+#include "XrdSys/XrdSysPthread.hh"
 
 #include <memory>
 #include <fstream>
@@ -38,7 +40,7 @@
 #include <vector>
 #include <string>
 #include <fcntl.h>
-
+#include <sys/poll.h>
 
 bool XrdVomsMapfile::tried_configure = false;
 std::unique_ptr<XrdVomsMapfile> XrdVomsMapfile::mapper;
@@ -57,6 +59,12 @@ PathToString(const std::vector<std::string> &path)
     return ss.str();
 }
 
+uint64_t monotonic_time_s() {
+  struct timespec tp;
+  clock_gettime(CLOCK_MONOTONIC, &tp);
+  return tp.tv_sec + (tp.tv_nsec >= 500000000);
+}
+
 }
 
 
@@ -64,7 +72,62 @@ XrdVomsMapfile::XrdVomsMapfile(XrdSysError *erp, XrdHttpSecXtractor *xrdvoms,
     const std::string &mapfile)
     : m_mapfile(mapfile), m_xrdvoms(xrdvoms), m_edest(erp)
 {
-    m_last_update.store(0, std::memory_order_relaxed);
+    // Setup communication pipes; we write one byte to the child to tell it to shutdown;
+    // it'll write one byte back to acknowledge before our destructor exits.
+    int pipes[2];
+    if (-1 == XrdSysFD_Pipe(pipes)) {
+        m_edest->Emsg("XrdVomsMapfile", "Failed to create communication pipes", strerror(errno));
+        return;
+    }
+    if (-1 == XrdSysFD_Pipe(pipes)) {
+        m_edest->Emsg("XrdVomsMapfile", "Failed to create communication pipes", strerror(errno));
+        return;
+    }
+
+    struct stat statbuf;
+    if (-1 == stat(m_mapfile.c_str(), &statbuf)) {
+        m_edest->Emsg("XrdVomsMapfile", errno, "Error checking the mapfile", m_mapfile.c_str());
+        return;
+    }
+    memcpy(&m_mapfile_ctime, &statbuf.st_ctim, sizeof(decltype(m_mapfile_ctime)));
+
+    if (!ParseMapfile(m_mapfile)) {return;}
+
+    m_maintenance_pipe_r = pipes[0];
+    m_maintenance_pipe_w = pipes[1];
+    m_maintenance_thread_pipe_r = pipes[0];
+    m_maintenance_thread_pipe_w = pipes[1];
+
+    pthread_t tid;
+    auto rc = XrdSysThread::Run(&tid, XrdVomsMapfile::MaintenanceThread,
+                                static_cast<void*>(this), 0, "VOMS Mapfile refresh");
+    if (rc) {
+        m_edest->Emsg("XrdVomsMapfile", "Failed to launch VOMS mapfile monitoring thread");
+        close(m_maintenance_pipe_r); m_maintenance_pipe_r = -1;
+        close(m_maintenance_pipe_w); m_maintenance_pipe_w = -1;
+        close(m_maintenance_thread_pipe_r); m_maintenance_thread_pipe_r = -1;
+        close(m_maintenance_thread_pipe_w); m_maintenance_thread_pipe_w = -1;
+        return;
+    }
+    m_is_valid = true;
+}
+
+
+XrdVomsMapfile::~XrdVomsMapfile()
+{
+    char indicator[1];
+    if (m_maintenance_pipe_w >= 0) {
+        indicator[0] = '1';
+        int rval;
+        do {rval = write(m_maintenance_pipe_w, indicator, 1);} while (rval != -1 || errno == EINTR);
+        if (m_maintenance_thread_pipe_r >= 0) {
+            do {rval = read(m_maintenance_thread_pipe_r, indicator, 1);} while (rval != -1 || errno == EINTR);
+            close(m_maintenance_thread_pipe_r);
+            close(m_maintenance_thread_pipe_w);
+        }
+        close(m_maintenance_pipe_r);
+        close(m_maintenance_pipe_w);
+    }
 }
 
 
@@ -91,21 +154,6 @@ XrdVomsMapfile::ParseMapfile(const std::string &mapfile)
 }
 
 
-bool
-XrdVomsMapfile::Reconfigure() {
-    auto now = time(NULL);
-    auto retval = true;
-    std::stringstream ss;
-    ss << "Last update " << m_last_update.load(std::memory_order_relaxed) << ", " << now;
-    m_edest->Log(LogMask::Debug, "VOMS Mapfile", ss.str().c_str());
-    if (now > m_last_update.load(std::memory_order_relaxed) + 30) {
-        retval = ParseMapfile(m_mapfile);
-        m_last_update.store(now, std::memory_order_relaxed);
-    }
-    return retval;
-}
-
-
 bool
 XrdVomsMapfile::ParseLine(const std::string &line, std::vector<std::string> &entry, std::string &target)
 {
@@ -255,8 +303,6 @@ XrdVomsMapfile::GetSecData(XrdLink * lnk, XrdSecEntity &entity, SSL *ssl)
 int
 XrdVomsMapfile::Apply(XrdSecEntity &entity)
 {
-    Reconfigure();
-
     // In current use cases, the gridmap results take precedence over the voms-mapfile
     // results.  However, the grid mapfile plugins often will populate the name attribute
     // with a reasonable default (DN or DN hash) if the mapping fails, meaning we can't
@@ -367,8 +413,70 @@ XrdVomsMapfile::Configure(XrdSysError *erp, XrdHttpSecXtractor *xtractor)
     if (!map_filename.empty()) {
         if (erp) erp->Emsg("Config", "Will initialize VOMS mapfile", map_filename.c_str());
         mapper.reset(new XrdVomsMapfile(erp, xtractor, map_filename));
-        mapper->Reconfigure();
     }
 
-    return mapper.get();
+    return mapper->IsValid() ? mapper.get() : nullptr;
+}
+
+
+void *
+XrdVomsMapfile::MaintenanceThread(void *myself_raw)
+{
+    auto myself = static_cast<XrdVomsMapfile*>(myself_raw);
+
+   auto now = monotonic_time_s();
+   auto next_update = now + m_update_interval;
+   while (true) {
+       now = monotonic_time_s();
+       auto remaining = next_update - now;
+       struct pollfd fds;
+       fds.fd = myself->m_maintenance_pipe_r;
+       fds.events = POLLIN;
+       auto rval = poll(&fds, 1, remaining*1000);
+       if (rval == -1) {
+           if (rval == EINTR) continue;
+           else break;
+       } else if (rval == 0) { // timeout!  Let's run maintenance.
+           struct stat statbuf;
+           if (-1 == stat(myself->m_mapfile.c_str(), &statbuf)) {
+               myself->m_edest->Emsg("XrdVomsMapfile", errno, "Error checking the mapfile",
+                   myself->m_mapfile.c_str());
+               next_update = monotonic_time_s() + m_update_interval_failure;
+               myself->m_mapfile_ctime.tv_sec = 0;
+               myself->m_mapfile_ctime.tv_nsec = 0;
+               myself->m_is_valid = false;
+               continue;
+           }
+           if ((myself->m_mapfile_ctime.tv_sec == statbuf.st_ctim.tv_sec) &&
+               (myself->m_mapfile_ctime.tv_nsec == statbuf.st_ctim.tv_nsec))
+           {
+               myself->m_edest->Log(LogMask::Debug, "Maintenance", "Not reloading VOMS mapfile; "
+                   "no changes detected.");
+               next_update = monotonic_time_s() + m_update_interval;
+               continue;
+           }
+           memcpy(&myself->m_mapfile_ctime, &statbuf.st_ctim, sizeof(decltype(statbuf.st_ctim)));
+
+           myself->m_edest->Log(LogMask::Debug, "Maintenance", "Reloading VOMS mapfile now");
+           if ( (myself->m_is_valid = myself->ParseMapfile(myself->m_mapfile)) ) {
+               next_update = monotonic_time_s() + m_update_interval;
+           } else {
+               next_update = monotonic_time_s() + m_update_interval_failure;
+           }
+       } else { // FD ready; let's shutdown
+           if (fds.revents & POLLIN) {
+               char indicator[1];
+               do {rval = read(myself->m_maintenance_pipe_r, indicator, 1);} while (rval != -1 || errno == EINTR);
+           }
+       }
+   }
+   if (errno) {
+       myself->m_edest->Emsg("Maintenance", "Failed to poll for events from parent object");
+   }
+   char indicator = '1';
+   int rval;
+   do {rval = write(myself->m_maintenance_thread_pipe_w, &indicator, 1);} while (rval != -1 || errno == EINTR);
+
+
+   return nullptr;
 }
diff --git a/src/XrdVoms/XrdVomsMapfile.hh b/src/XrdVoms/XrdVomsMapfile.hh
index 7273f0b3376..61c47cbfeb7 100644
--- a/src/XrdVoms/XrdVomsMapfile.hh
+++ b/src/XrdVoms/XrdVomsMapfile.hh
@@ -35,12 +35,16 @@
 class XrdVomsMapfile : public XrdHttpSecXtractor {
 
 public:
+    virtual ~XrdVomsMapfile();
+
     static XrdVomsMapfile *Configure(XrdSysError *, XrdHttpSecXtractor *);
     static XrdVomsMapfile *Get();
 
     virtual int GetSecData(XrdLink *, XrdSecEntity &, SSL *);
     int Apply(XrdSecEntity &);
 
+    bool IsValid() const {return m_is_valid;}
+
     /* Base class returns an error if these aren't overridden */
     virtual int Init(SSL_CTX *, int) {return 0;}
     virtual int InitSSL(SSL *ssl, char *cadir) {return 0;}
@@ -73,14 +77,35 @@ private:
     bool Compare(const MapfileEntry &entry, const std::vector<std::string> &fqan);
     std::vector<std::string> MakePath(const XrdOucString &group);
 
+    // A continuously-running thread for maintenance tasks (reloading the mapfile)
+    static void *MaintenanceThread(void *myself_raw);
+
+    // Set to true if the last maintenance attempt succeeded.
+    bool m_is_valid = false;
+    // Time of the last observed status change of file.
+    struct timespec m_mapfile_ctime{0, 0};
+
     std::string m_mapfile;
     std::shared_ptr<const std::vector<MapfileEntry>> m_entries;
     XrdHttpSecXtractor *m_xrdvoms{nullptr};
     XrdSysError *m_edest{nullptr};
 
-    std::atomic<time_t> m_last_update;
+    // Pipes to allow the main thread to communicate shutdown events to the maintenance
+    // thread, allowing for a clean shutdown.
+    int m_maintenance_pipe_r{-1};
+    int m_maintenance_pipe_w{-1};
+    int m_maintenance_thread_pipe_r{-1};
+    int m_maintenance_thread_pipe_w{-1};
+
+        // After success, how long to wait until the next mapfile check.
+    static constexpr unsigned m_update_interval = 30;
+        // After failure, how long to wait until the next mapfile check.
+    static constexpr unsigned m_update_interval_failure = 3;
 
     // Singleton
     static std::unique_ptr<XrdVomsMapfile> mapper;
+    // There are multiple protocol objects that may need the mapfile object;
+    // if we already tried-and-failed configuration once, this singleton will
+    // help us avoid failing again.
     static bool tried_configure;
 };

From f9931b4c62687d142839f865933d2ae7c89181fc Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelman@morgridge.org>
Date: Mon, 17 Jan 2022 11:23:48 -0600
Subject: [PATCH 06/11] Refactor the mapfile class to be core within XrdVoms.

This moves the mapfile invocation from being a "wrapper" around the
existing XrdVoms plugins to be a core part of the functionality.

Note this also changes the failure semantics from "fail quietly"
to "fail process startup if misconfigured."
---
 src/XrdVoms/XrdVomsFun.cc     | 16 +++++++++++++++-
 src/XrdVoms/XrdVomsFun.hh     |  3 +++
 src/XrdVoms/XrdVomsHttp.cc    |  5 +----
 src/XrdVoms/XrdVomsMapfile.cc | 35 +++++++++++++----------------------
 src/XrdVoms/XrdVomsMapfile.hh | 23 ++++++++++-------------
 src/XrdVoms/XrdVomsgsi.cc     | 10 +---------
 6 files changed, 43 insertions(+), 49 deletions(-)

diff --git a/src/XrdVoms/XrdVomsFun.cc b/src/XrdVoms/XrdVomsFun.cc
index 1c7fd5417c7..a4ced43ba5c 100644
--- a/src/XrdVoms/XrdVomsFun.cc
+++ b/src/XrdVoms/XrdVomsFun.cc
@@ -41,6 +41,7 @@
 #include "XrdVoms.hh"
 #include "XrdVomsFun.hh"
 #include "XrdVomsTrace.hh"
+#include "XrdVomsMapfile.hh"
 
 #ifdef HAVE_XRDCRYPTO
 #include "XrdCrypto/XrdCryptoX509.hh"
@@ -380,7 +381,13 @@ int XrdVomsFun::VOMSFun(XrdSecEntity &ent)
    // Success or failure?
    int rc = !ent.vorg ? -1 : 0;
    if (rc == 0 && gGrps.Num() && !ent.grps) rc = -1;
-   
+
+   // If we have a mapfile object, apply the mapping now.
+   if (m_mapfile) {
+       auto mapfile_rc = m_mapfile->Apply(ent);
+       rc = rc ? rc : mapfile_rc;
+   }
+
    // Done
    return rc;
 }
@@ -592,6 +599,13 @@ int XrdVomsFun::VOMSInit(const char *cfg)
    if (gVOs.Num() > 0) {PRINT("+++ VO(s):        "<< voss);}
       else             {PRINT("+++ VO(s):         all");}
    PRINT("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
+
+   m_mapfile = XrdVomsMapfile::Configure(&gDest);
+   if (m_mapfile == VOMS_MAP_FAILED) {
+      aOK = false;
+      PRINT("VOMS mapfile requested but initialization failed; failing VOMS plugin config.");
+   }
+
    // Done
    return (aOK ? gCertFmt : -1);
 }
diff --git a/src/XrdVoms/XrdVomsFun.hh b/src/XrdVoms/XrdVomsFun.hh
index 41a9251c9fd..ff5df58efc8 100644
--- a/src/XrdVoms/XrdVomsFun.hh
+++ b/src/XrdVoms/XrdVomsFun.hh
@@ -38,6 +38,7 @@
 class XrdSecEntity;
 class XrdSysError;
 class XrdSysLogger;
+class XrdVomsMapfile;
 
 class XrdVomsFun
 {
@@ -82,5 +83,7 @@ XrdOucString    gVoFmt;           // format contents of XrdSecEntity::vorg
 
 XrdSysError    &gDest;
 XrdSysLogger   *gLogger;
+
+XrdVomsMapfile *m_mapfile{nullptr};
 };
 #endif
diff --git a/src/XrdVoms/XrdVomsHttp.cc b/src/XrdVoms/XrdVomsHttp.cc
index 5c2532707df..4e7131bc363 100644
--- a/src/XrdVoms/XrdVomsHttp.cc
+++ b/src/XrdVoms/XrdVomsHttp.cc
@@ -29,7 +29,6 @@
 
 // This code is based on
 
-#include "XrdVomsMapfile.hh"
 #include "XrdVomsFun.hh"
 
 /** @brief This code is based on the basic architecture shown in
@@ -143,9 +142,7 @@ XrdHttpSecXtractor *XrdHttpGetSecXtractor(XrdHttpSecXtractorArgs)
 
 // Now return the interface object
 //
-   auto base = static_cast<XrdHttpSecXtractor *>(new XrdVomsHttp(eDest, *vomsFun));
-   auto wrapper = static_cast<XrdHttpSecXtractor *>(XrdVomsMapfile::Configure(eDest, base));
-   return wrapper ? wrapper : base;
+   return (XrdHttpSecXtractor *)new XrdVomsHttp(eDest, *vomsFun);
 }
 
 /******************************************************************************/
diff --git a/src/XrdVoms/XrdVomsMapfile.cc b/src/XrdVoms/XrdVomsMapfile.cc
index aa4fef6d913..24d23d28172 100644
--- a/src/XrdVoms/XrdVomsMapfile.cc
+++ b/src/XrdVoms/XrdVomsMapfile.cc
@@ -68,9 +68,9 @@ uint64_t monotonic_time_s() {
 }
 
 
-XrdVomsMapfile::XrdVomsMapfile(XrdSysError *erp, XrdHttpSecXtractor *xrdvoms,
+XrdVomsMapfile::XrdVomsMapfile(XrdSysError *erp,
     const std::string &mapfile)
-    : m_mapfile(mapfile), m_xrdvoms(xrdvoms), m_edest(erp)
+    : m_mapfile(mapfile), m_edest(erp)
 {
     // Setup communication pipes; we write one byte to the child to tell it to shutdown;
     // it'll write one byte back to acknowledge before our destructor exits.
@@ -288,18 +288,6 @@ XrdVomsMapfile::MakePath(const XrdOucString &group)
 }
 
 
-int
-XrdVomsMapfile::GetSecData(XrdLink * lnk, XrdSecEntity &entity, SSL *ssl)
-{
-    if (!m_xrdvoms) return -1;
-
-    auto retval = m_xrdvoms->GetSecData(lnk, entity, ssl);
-    if (retval) return retval;
-
-    return Apply(entity);
-}
-
-
 int
 XrdVomsMapfile::Apply(XrdSecEntity &entity)
 {
@@ -352,12 +340,11 @@ XrdVomsMapfile::Get()
 
 
 XrdVomsMapfile *
-XrdVomsMapfile::Configure(XrdSysError *erp, XrdHttpSecXtractor *xtractor)
+XrdVomsMapfile::Configure(XrdSysError *erp)
 {
     if (tried_configure) {
         auto result = mapper.get();
         if (result) {
-            result->SetExtractor(xtractor);
             result->SetErrorStream(erp);
         }
         return result;
@@ -370,14 +357,14 @@ XrdVomsMapfile::Configure(XrdSysError *erp, XrdHttpSecXtractor *xtractor)
 
     char *config_filename = nullptr;
     if (!XrdOucEnv::Import("XRDCONFIGFN", config_filename)) {
-        return nullptr;
+        return VOMS_MAP_FAILED;
     }
     XrdOucStream stream(erp, getenv("XRDINSTANCE"));
 
     int cfg_fd;
     if ((cfg_fd = open(config_filename, O_RDONLY, 0)) < 0) {
         if (erp) erp->Emsg("Config", errno, "open config file", config_filename);
-        return nullptr;
+        return VOMS_MAP_FAILED;
     }
     stream.Attach(cfg_fd);
     char *var;
@@ -387,14 +374,14 @@ XrdVomsMapfile::Configure(XrdSysError *erp, XrdHttpSecXtractor *xtractor)
             auto val = stream.GetWord();
             if (!val || !val[0]) {
                 if (erp) erp->Emsg("Config", "VOMS mapfile not specified");
-                return nullptr;
+                return VOMS_MAP_FAILED;
             }
             map_filename = val;
         } else if (!strcmp(var, "voms.trace")) {
             auto val = stream.GetWord();
             if (!val || !val[0]) {
                 if (erp) erp->Emsg("Config", "VOMS logging level not specified");
-                return nullptr;
+                return VOMS_MAP_FAILED;
             }
             if (erp) erp->setMsgMask(0);
             if (erp) do {
@@ -412,10 +399,14 @@ XrdVomsMapfile::Configure(XrdSysError *erp, XrdHttpSecXtractor *xtractor)
 
     if (!map_filename.empty()) {
         if (erp) erp->Emsg("Config", "Will initialize VOMS mapfile", map_filename.c_str());
-        mapper.reset(new XrdVomsMapfile(erp, xtractor, map_filename));
+        mapper.reset(new XrdVomsMapfile(erp, map_filename));
+        if (!mapper->IsValid()) {
+            mapper.reset(nullptr);
+            return VOMS_MAP_FAILED;
+        }
     }
 
-    return mapper->IsValid() ? mapper.get() : nullptr;
+    return mapper.get();
 }
 
 
diff --git a/src/XrdVoms/XrdVomsMapfile.hh b/src/XrdVoms/XrdVomsMapfile.hh
index 61c47cbfeb7..e859c8fbe7d 100644
--- a/src/XrdVoms/XrdVomsMapfile.hh
+++ b/src/XrdVoms/XrdVomsMapfile.hh
@@ -23,39 +23,37 @@
 /* specific prior written permission of the institution or contributor.       */
 /******************************************************************************/
 
-#include "XrdHttp/XrdHttpSecXtractor.hh"
-
 #include "XrdOuc/XrdOucString.hh"
+#include "XrdSys/XrdSysError.hh"
+#include "XrdSec/XrdSecEntity.hh"
 
 #include <atomic>
 #include <memory>
 #include <string>
 #include <vector>
 
-class XrdVomsMapfile : public XrdHttpSecXtractor {
+#define VOMS_MAP_FAILED ((XrdVomsMapfile *)-1)
+
+class XrdVomsMapfile {
 
 public:
     virtual ~XrdVomsMapfile();
 
-    static XrdVomsMapfile *Configure(XrdSysError *, XrdHttpSecXtractor *);
+    // Returns `nullptr` if the mapfile was not configured; returns
+    // VOMS_MAP_FAILED (`(void*)-1`) if the mapfile was configured but it
+    // was unable to be parsed (or other error occurred).
+    static XrdVomsMapfile *Configure(XrdSysError *);
     static XrdVomsMapfile *Get();
 
-    virtual int GetSecData(XrdLink *, XrdSecEntity &, SSL *);
     int Apply(XrdSecEntity &);
 
     bool IsValid() const {return m_is_valid;}
 
-    /* Base class returns an error if these aren't overridden */
-    virtual int Init(SSL_CTX *, int) {return 0;}
-    virtual int InitSSL(SSL *ssl, char *cadir) {return 0;}
-    virtual int FreeSSL(SSL *) {return 0;}
-
 private:
     bool Reconfigure();
     void SetErrorStream(XrdSysError *erp) {if (erp) {m_edest = erp;}}
-    void SetExtractor(XrdHttpSecXtractor *xtractor) {if (xtractor) {m_xrdvoms = xtractor;}}
 
-    XrdVomsMapfile(XrdSysError *erp, XrdHttpSecXtractor *xrdvoms, const std::string &mapfile);
+    XrdVomsMapfile(XrdSysError *erp, const std::string &mapfile);
 
     enum LogMask {
         Debug = 0x01,
@@ -87,7 +85,6 @@ private:
 
     std::string m_mapfile;
     std::shared_ptr<const std::vector<MapfileEntry>> m_entries;
-    XrdHttpSecXtractor *m_xrdvoms{nullptr};
     XrdSysError *m_edest{nullptr};
 
     // Pipes to allow the main thread to communicate shutdown events to the maintenance
diff --git a/src/XrdVoms/XrdVomsgsi.cc b/src/XrdVoms/XrdVomsgsi.cc
index b054004a9dc..293f9363d3b 100644
--- a/src/XrdVoms/XrdVomsgsi.cc
+++ b/src/XrdVoms/XrdVomsgsi.cc
@@ -30,8 +30,6 @@
 #include "XrdSys/XrdSysError.hh"
 #include "XrdSys/XrdSysLogger.hh"
 
-#include "XrdVomsMapfile.hh"
-
 #include "XrdVomsFun.hh"
 
 /******************************************************************************/
@@ -59,11 +57,7 @@ int XrdSecgsiVOMSFun(XrdSecEntity &ent)
 {
 // Make sure we were initialized. If so, invoke the function and return result.
 //
-   int retval = (vomsFun ? vomsFun->VOMSFun(ent) : -1);
-   if (retval == -1) {return retval;}
-
-   auto mapfile = XrdVomsMapfile::Get();
-   return mapfile ? mapfile->Apply(ent) : retval;
+   return (vomsFun ? vomsFun->VOMSFun(ent) : -1);
 }
 }
 
@@ -80,8 +74,6 @@ int XrdSecgsiVOMSInit(const char *cfg)
    static XrdSysLogger gLogger;
    static XrdSysError gDest(&gLogger, "XrdVoms");
 
-   XrdVomsMapfile::Configure(&gDest, nullptr);
-
 // Allocate a new Voms object
 //
    vomsFun = new XrdVomsFun(gDest);

From b324a1adbe08daa5babbdd49ac4f0d2ab1904174 Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelman@morgridge.org>
Date: Sat, 29 Jan 2022 13:09:56 -0600
Subject: [PATCH 07/11] Remove faster polling interval for failures.

Reduces some of the logical complexity; prevents log files filling
up quicker on failure.
---
 src/XrdVoms/XrdVomsMapfile.cc | 9 +++------
 src/XrdVoms/XrdVomsMapfile.hh | 2 --
 2 files changed, 3 insertions(+), 8 deletions(-)

diff --git a/src/XrdVoms/XrdVomsMapfile.cc b/src/XrdVoms/XrdVomsMapfile.cc
index 24d23d28172..98f226c68e4 100644
--- a/src/XrdVoms/XrdVomsMapfile.cc
+++ b/src/XrdVoms/XrdVomsMapfile.cc
@@ -428,11 +428,11 @@ XrdVomsMapfile::MaintenanceThread(void *myself_raw)
            if (rval == EINTR) continue;
            else break;
        } else if (rval == 0) { // timeout!  Let's run maintenance.
+           next_update = monotonic_time_s() + m_update_interval;
            struct stat statbuf;
            if (-1 == stat(myself->m_mapfile.c_str(), &statbuf)) {
                myself->m_edest->Emsg("XrdVomsMapfile", errno, "Error checking the mapfile",
                    myself->m_mapfile.c_str());
-               next_update = monotonic_time_s() + m_update_interval_failure;
                myself->m_mapfile_ctime.tv_sec = 0;
                myself->m_mapfile_ctime.tv_nsec = 0;
                myself->m_is_valid = false;
@@ -443,16 +443,13 @@ XrdVomsMapfile::MaintenanceThread(void *myself_raw)
            {
                myself->m_edest->Log(LogMask::Debug, "Maintenance", "Not reloading VOMS mapfile; "
                    "no changes detected.");
-               next_update = monotonic_time_s() + m_update_interval;
                continue;
            }
            memcpy(&myself->m_mapfile_ctime, &statbuf.st_ctim, sizeof(decltype(statbuf.st_ctim)));
 
            myself->m_edest->Log(LogMask::Debug, "Maintenance", "Reloading VOMS mapfile now");
-           if ( (myself->m_is_valid = myself->ParseMapfile(myself->m_mapfile)) ) {
-               next_update = monotonic_time_s() + m_update_interval;
-           } else {
-               next_update = monotonic_time_s() + m_update_interval_failure;
+           if ( !(myself->m_is_valid = myself->ParseMapfile(myself->m_mapfile)) ) {
+               myself->m_edest->Log(LogMask::Error, "Maintenance", "Failed to reload VOMS mapfile");
            }
        } else { // FD ready; let's shutdown
            if (fds.revents & POLLIN) {
diff --git a/src/XrdVoms/XrdVomsMapfile.hh b/src/XrdVoms/XrdVomsMapfile.hh
index e859c8fbe7d..ae665c6e5df 100644
--- a/src/XrdVoms/XrdVomsMapfile.hh
+++ b/src/XrdVoms/XrdVomsMapfile.hh
@@ -96,8 +96,6 @@ private:
 
         // After success, how long to wait until the next mapfile check.
     static constexpr unsigned m_update_interval = 30;
-        // After failure, how long to wait until the next mapfile check.
-    static constexpr unsigned m_update_interval_failure = 3;
 
     // Singleton
     static std::unique_ptr<XrdVomsMapfile> mapper;

From 52a960007d3494d0f13746d4dae12fdd3c796bd0 Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelman@morgridge.org>
Date: Sat, 29 Jan 2022 13:20:26 -0600
Subject: [PATCH 08/11] Remove shutdown capabilities for maintenance thread.

Decision was that this would be sufficiently infrequently used that
we can just let the OS cleanup the maintenance thread.
---
 src/XrdVoms/XrdVomsMapfile.cc | 109 +++++++++-------------------------
 src/XrdVoms/XrdVomsMapfile.hh |   7 ---
 2 files changed, 28 insertions(+), 88 deletions(-)

diff --git a/src/XrdVoms/XrdVomsMapfile.cc b/src/XrdVoms/XrdVomsMapfile.cc
index 98f226c68e4..e5313343379 100644
--- a/src/XrdVoms/XrdVomsMapfile.cc
+++ b/src/XrdVoms/XrdVomsMapfile.cc
@@ -72,18 +72,6 @@ XrdVomsMapfile::XrdVomsMapfile(XrdSysError *erp,
     const std::string &mapfile)
     : m_mapfile(mapfile), m_edest(erp)
 {
-    // Setup communication pipes; we write one byte to the child to tell it to shutdown;
-    // it'll write one byte back to acknowledge before our destructor exits.
-    int pipes[2];
-    if (-1 == XrdSysFD_Pipe(pipes)) {
-        m_edest->Emsg("XrdVomsMapfile", "Failed to create communication pipes", strerror(errno));
-        return;
-    }
-    if (-1 == XrdSysFD_Pipe(pipes)) {
-        m_edest->Emsg("XrdVomsMapfile", "Failed to create communication pipes", strerror(errno));
-        return;
-    }
-
     struct stat statbuf;
     if (-1 == stat(m_mapfile.c_str(), &statbuf)) {
         m_edest->Emsg("XrdVomsMapfile", errno, "Error checking the mapfile", m_mapfile.c_str());
@@ -93,20 +81,11 @@ XrdVomsMapfile::XrdVomsMapfile(XrdSysError *erp,
 
     if (!ParseMapfile(m_mapfile)) {return;}
 
-    m_maintenance_pipe_r = pipes[0];
-    m_maintenance_pipe_w = pipes[1];
-    m_maintenance_thread_pipe_r = pipes[0];
-    m_maintenance_thread_pipe_w = pipes[1];
-
     pthread_t tid;
     auto rc = XrdSysThread::Run(&tid, XrdVomsMapfile::MaintenanceThread,
                                 static_cast<void*>(this), 0, "VOMS Mapfile refresh");
     if (rc) {
         m_edest->Emsg("XrdVomsMapfile", "Failed to launch VOMS mapfile monitoring thread");
-        close(m_maintenance_pipe_r); m_maintenance_pipe_r = -1;
-        close(m_maintenance_pipe_w); m_maintenance_pipe_w = -1;
-        close(m_maintenance_thread_pipe_r); m_maintenance_thread_pipe_r = -1;
-        close(m_maintenance_thread_pipe_w); m_maintenance_thread_pipe_w = -1;
         return;
     }
     m_is_valid = true;
@@ -114,21 +93,7 @@ XrdVomsMapfile::XrdVomsMapfile(XrdSysError *erp,
 
 
 XrdVomsMapfile::~XrdVomsMapfile()
-{
-    char indicator[1];
-    if (m_maintenance_pipe_w >= 0) {
-        indicator[0] = '1';
-        int rval;
-        do {rval = write(m_maintenance_pipe_w, indicator, 1);} while (rval != -1 || errno == EINTR);
-        if (m_maintenance_thread_pipe_r >= 0) {
-            do {rval = read(m_maintenance_thread_pipe_r, indicator, 1);} while (rval != -1 || errno == EINTR);
-            close(m_maintenance_thread_pipe_r);
-            close(m_maintenance_thread_pipe_w);
-        }
-        close(m_maintenance_pipe_r);
-        close(m_maintenance_pipe_w);
-    }
-}
+{}
 
 
 bool
@@ -420,51 +385,33 @@ XrdVomsMapfile::MaintenanceThread(void *myself_raw)
    while (true) {
        now = monotonic_time_s();
        auto remaining = next_update - now;
-       struct pollfd fds;
-       fds.fd = myself->m_maintenance_pipe_r;
-       fds.events = POLLIN;
-       auto rval = poll(&fds, 1, remaining*1000);
-       if (rval == -1) {
-           if (rval == EINTR) continue;
-           else break;
-       } else if (rval == 0) { // timeout!  Let's run maintenance.
-           next_update = monotonic_time_s() + m_update_interval;
-           struct stat statbuf;
-           if (-1 == stat(myself->m_mapfile.c_str(), &statbuf)) {
-               myself->m_edest->Emsg("XrdVomsMapfile", errno, "Error checking the mapfile",
-                   myself->m_mapfile.c_str());
-               myself->m_mapfile_ctime.tv_sec = 0;
-               myself->m_mapfile_ctime.tv_nsec = 0;
-               myself->m_is_valid = false;
-               continue;
-           }
-           if ((myself->m_mapfile_ctime.tv_sec == statbuf.st_ctim.tv_sec) &&
-               (myself->m_mapfile_ctime.tv_nsec == statbuf.st_ctim.tv_nsec))
-           {
-               myself->m_edest->Log(LogMask::Debug, "Maintenance", "Not reloading VOMS mapfile; "
-                   "no changes detected.");
-               continue;
-           }
-           memcpy(&myself->m_mapfile_ctime, &statbuf.st_ctim, sizeof(decltype(statbuf.st_ctim)));
-
-           myself->m_edest->Log(LogMask::Debug, "Maintenance", "Reloading VOMS mapfile now");
-           if ( !(myself->m_is_valid = myself->ParseMapfile(myself->m_mapfile)) ) {
-               myself->m_edest->Log(LogMask::Error, "Maintenance", "Failed to reload VOMS mapfile");
-           }
-       } else { // FD ready; let's shutdown
-           if (fds.revents & POLLIN) {
-               char indicator[1];
-               do {rval = read(myself->m_maintenance_pipe_r, indicator, 1);} while (rval != -1 || errno == EINTR);
-           }
+       auto rval = sleep(remaining);
+       if (rval > 0) {
+           // Woke up early due to a signal; re-run prior logic.
+           continue;
        }
-   }
-   if (errno) {
-       myself->m_edest->Emsg("Maintenance", "Failed to poll for events from parent object");
-   }
-   char indicator = '1';
-   int rval;
-   do {rval = write(myself->m_maintenance_thread_pipe_w, &indicator, 1);} while (rval != -1 || errno == EINTR);
-
+       next_update = monotonic_time_s() + m_update_interval;
+       struct stat statbuf;
+       if (-1 == stat(myself->m_mapfile.c_str(), &statbuf)) {
+           myself->m_edest->Emsg("XrdVomsMapfile", errno, "Error checking the mapfile",
+               myself->m_mapfile.c_str());
+           myself->m_mapfile_ctime.tv_sec = 0;
+           myself->m_mapfile_ctime.tv_nsec = 0;
+           myself->m_is_valid = false;
+           continue;
+       }
+       if ((myself->m_mapfile_ctime.tv_sec == statbuf.st_ctim.tv_sec) &&
+           (myself->m_mapfile_ctime.tv_nsec == statbuf.st_ctim.tv_nsec))
+       {
+           myself->m_edest->Log(LogMask::Debug, "Maintenance", "Not reloading VOMS mapfile; "
+               "no changes detected.");
+           continue;
+       }
+       memcpy(&myself->m_mapfile_ctime, &statbuf.st_ctim, sizeof(decltype(statbuf.st_ctim)));
 
-   return nullptr;
+       myself->m_edest->Log(LogMask::Debug, "Maintenance", "Reloading VOMS mapfile now");
+       if ( !(myself->m_is_valid = myself->ParseMapfile(myself->m_mapfile)) ) {
+           myself->m_edest->Log(LogMask::Error, "Maintenance", "Failed to reload VOMS mapfile");
+       }
+   }
 }
diff --git a/src/XrdVoms/XrdVomsMapfile.hh b/src/XrdVoms/XrdVomsMapfile.hh
index ae665c6e5df..8119411cb6d 100644
--- a/src/XrdVoms/XrdVomsMapfile.hh
+++ b/src/XrdVoms/XrdVomsMapfile.hh
@@ -87,13 +87,6 @@ private:
     std::shared_ptr<const std::vector<MapfileEntry>> m_entries;
     XrdSysError *m_edest{nullptr};
 
-    // Pipes to allow the main thread to communicate shutdown events to the maintenance
-    // thread, allowing for a clean shutdown.
-    int m_maintenance_pipe_r{-1};
-    int m_maintenance_pipe_w{-1};
-    int m_maintenance_thread_pipe_r{-1};
-    int m_maintenance_thread_pipe_w{-1};
-
         // After success, how long to wait until the next mapfile check.
     static constexpr unsigned m_update_interval = 30;
 

From 5f0a255a58c01c49dc2aa7f67e760ca42deb7a21 Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelman@morgridge.org>
Date: Tue, 8 Feb 2022 07:44:57 -0600
Subject: [PATCH 09/11] XrdVomsMapfile: Add a comment on why we use ctime over
 mtime for detecting file changes.

---
 src/XrdVoms/XrdVomsMapfile.cc | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/XrdVoms/XrdVomsMapfile.cc b/src/XrdVoms/XrdVomsMapfile.cc
index e5313343379..30bdb88c9a0 100644
--- a/src/XrdVoms/XrdVomsMapfile.cc
+++ b/src/XrdVoms/XrdVomsMapfile.cc
@@ -400,6 +400,12 @@ XrdVomsMapfile::MaintenanceThread(void *myself_raw)
            myself->m_is_valid = false;
            continue;
        }
+       // Use ctime here as it is solely controlled by the OS (unlike mtime,
+       // which can be manipulated by userspace and potentially not change
+       // when updated - rsync, tar, and rpm, for example, all preserve mtime).
+       // ctime also will also be updated appropriately for overwrites/renames,
+       // allowing us to detect those changes as well.
+       //
        if ((myself->m_mapfile_ctime.tv_sec == statbuf.st_ctim.tv_sec) &&
            (myself->m_mapfile_ctime.tv_nsec == statbuf.st_ctim.tv_nsec))
        {

From 67d047b422bb6f5f1e697dccdd9c128c36711730 Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelman@morgridge.org>
Date: Mon, 28 Feb 2022 22:46:46 -0600
Subject: [PATCH 10/11] Return nullptr from function that won't ever hit return
 statement.

---
 src/XrdVoms/XrdVomsMapfile.cc | 1 +
 1 file changed, 1 insertion(+)

diff --git a/src/XrdVoms/XrdVomsMapfile.cc b/src/XrdVoms/XrdVomsMapfile.cc
index 30bdb88c9a0..254ac3d98d7 100644
--- a/src/XrdVoms/XrdVomsMapfile.cc
+++ b/src/XrdVoms/XrdVomsMapfile.cc
@@ -420,4 +420,5 @@ XrdVomsMapfile::MaintenanceThread(void *myself_raw)
            myself->m_edest->Log(LogMask::Error, "Maintenance", "Failed to reload VOMS mapfile");
        }
    }
+   return nullptr;
 }

From 4ede2baf8e9e6af9131caa4cfd3987bd0dcad264 Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelman@morgridge.org>
Date: Mon, 28 Feb 2022 22:51:59 -0600
Subject: [PATCH 11/11] Use gridmap.name as a flag - no need to preserve the
 actual name (as this is also in the Entity name).

---
 src/XrdHttp/XrdHttpSecurity.cc     | 2 +-
 src/XrdSecgsi/XrdSecProtocolgsi.cc | 2 +-
 src/XrdVoms/XrdVomsMapfile.cc      | 2 +-
 3 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/XrdHttp/XrdHttpSecurity.cc b/src/XrdHttp/XrdHttpSecurity.cc
index e187851c089..638045eb659 100644
--- a/src/XrdHttp/XrdHttpSecurity.cc
+++ b/src/XrdHttp/XrdHttpSecurity.cc
@@ -165,7 +165,7 @@ XrdHttpProtocol::HandleGridMap(XrdLink* lp)
       TRACEI(DEBUG, " Mapping name: '" << SecEntity.moninfo << "' --> " << bufname);
       if (SecEntity.name) free(SecEntity.name);
       SecEntity.name = strdup(bufname);
-      SecEntity.eaAPI->Add("gridmap.name", bufname, true);
+      SecEntity.eaAPI->Add("gridmap.name", "1", true);
     }
     else {
       TRACEI(ALL, " Mapping name: " << SecEntity.moninfo << " Failed. err: " << mape);
diff --git a/src/XrdSecgsi/XrdSecProtocolgsi.cc b/src/XrdSecgsi/XrdSecProtocolgsi.cc
index e93deb91223..c7bcb1d7e98 100644
--- a/src/XrdSecgsi/XrdSecProtocolgsi.cc
+++ b/src/XrdSecgsi/XrdSecProtocolgsi.cc
@@ -1954,7 +1954,7 @@ int XrdSecProtocolgsi::Authenticate(XrdSecCredentials *cred,
                DEBUG("user mapping lookup successful: name is '"<<name<<"'");
             }
             Entity.name = strdup(name.c_str());
-            Entity.eaAPI->Add("gridmap.name", name.c_str(), true);
+            Entity.eaAPI->Add("gridmap.name", "1", true);
          }
       }
       // If not set, use DN
diff --git a/src/XrdVoms/XrdVomsMapfile.cc b/src/XrdVoms/XrdVomsMapfile.cc
index 254ac3d98d7..824edd94a49 100644
--- a/src/XrdVoms/XrdVomsMapfile.cc
+++ b/src/XrdVoms/XrdVomsMapfile.cc
@@ -263,7 +263,7 @@ XrdVomsMapfile::Apply(XrdSecEntity &entity)
     // set when the mapfile is used to generate the name.
     std::string gridmap_name;
     auto gridmap_success = entity.eaAPI->Get("gridmap.name", gridmap_name);
-    if (gridmap_success) {
+    if (gridmap_success && gridmap_name == "1") {
         return 0;
     }
 
