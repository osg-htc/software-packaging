--- trunk/lcas-lcmaps-gt4-interface/src/lcmaps_gt4_front.c	2011/12/01 12:43:09	15655
+++ trunk/lcas-lcmaps-gt4-interface/src/lcmaps_gt4_front.c	2012/01/03 14:55:46	15820
@@ -115,6 +115,7 @@
 static int llgt_run_lcas_authz_and_lcmaps_mapping (gss_ctx_id_t context, char ** local_identity)
 {
     gss_cred_id_t    user_cred_handle   = GSS_C_NO_CREDENTIAL;
+    char            *client_name        = NULL;
     FILE            *flog_lcas          = NULL;
     FILE            *flog_lcmaps        = NULL;
     int              errno_fopen        = 0;
@@ -128,6 +129,7 @@
 
     /* get user credential from context */
     user_cred_handle = llgt_get_user_cred_handle(context);
+    client_name=llgt_get_client_name(context);
 
     /* Selectively run LCAS or not. Use "disabled" or "no" as value */
     if ((run_lcas = getenv("LLGT_RUN_LCAS"))) {
@@ -161,8 +163,9 @@
         }
 
         /* Execute LCAS with GLOBUS INTERFACE TO LCAS */
-        if (llgt_run_lcas (user_cred_handle, llgt_get_client_name(context), flog_lcas)) {
+        if (llgt_run_lcas (user_cred_handle, client_name, flog_lcas)) {
             llgt_logmsg(LOG_ERR, "Execution of LCAS failed.\n");
+	    free(client_name);
             return 1;
         } else {
             llgt_logmsg(LOG_DEBUG, "Execution of LCAS successful.\n");
@@ -188,11 +191,15 @@
     llgt_create_jobid();
 
     /* Execute LCMAPS */
-    if (llgt_run_lcmaps(user_cred_handle, llgt_get_client_name(context), flog_lcmaps, local_identity)) {
+    if (llgt_run_lcmaps(user_cred_handle, client_name, flog_lcmaps, local_identity)) {
         llgt_logmsg(LOG_ERR, "Execution of LCMAPS failed.\n");
+	free(client_name);
         return 1;
     }
 
+    /* No longer need client_name */
+    free(client_name);
+
     /* Implicit post-LCMAPS mapping to 'root' protection */
     if ((getuid() == 0) || geteuid() == 0 || getgid() == 0 || getegid() == 0) {
         /* Override the Implicit post-LCMAPS mapping to 'root' protection */
--- trunk/lcas-lcmaps-gt4-interface/src/lcmaps.c	2011/12/01 12:43:09	15655
+++ trunk/lcas-lcmaps-gt4-interface/src/lcmaps.c	2012/01/04 11:29:07	15825
@@ -104,6 +104,79 @@
     return 0;
 }
 
+static int policy_tokenize(char ***policies);
+
+/*!
+ * Splits LCMAPS_POLICY_NAME value into array of policy names.
+ * \return number of policies or -1 on error
+ */
+static int policy_tokenize(char ***policies)	{
+    char *input=getenv("LCMAPS_POLICY_NAME");
+    char *inp_copy,*pos1,*pos2,**pol_array;
+    int i,npol=0;
+
+    /* initialize */
+    *policies=NULL;
+
+    /* anything specified? */
+    if (input==NULL || strlen(input)==0)
+	return 0;
+
+    /* Count the number of colons: upper limit for number of policies */
+    npol=1;
+    for (i=0; i<strlen(input); i++)	{
+	if (input[i]==':')
+	    npol++;
+    }
+
+    /* Make a local copy of the env variable, which we can modify */
+    if ((inp_copy=strdup(input))==NULL)	{
+	return -1;
+    }
+    /* Now malloc the memory needed for the policies: add one for a NULL
+     * termination */
+    if ( (pol_array=(char **)malloc(sizeof(char*)*(npol+1)))==NULL) {
+	free(inp_copy);
+	return -1;
+    }
+
+    /* Get all (non-empty) policies */
+    pos1=inp_copy;
+    /* restart from 0 since we want only non-empty policy names */
+    npol=0;
+    while (1)	{
+	/* Check if there is a colon -> set it to null character */
+	if ( (pos2=strchr(pos1,':')) != NULL )
+	    pos2[0]='\0';
+	/* Check if the name is non-empty */
+	if (pos1[0]!='\0')  {
+	    if ((pol_array[npol]=strdup(pos1))==NULL)	{
+		/* Cleanup and return */
+		free(inp_copy);
+		for (i=0; i<npol; i++)
+		    free(pol_array[i]);
+		return -1;
+	    }
+	    npol++;
+	}
+	/* Was this the last entry? */
+	if (pos2==NULL)
+	    break;
+	/* Update the starting pointer */
+	pos1=pos2+1;
+    }
+
+    /* Check there is at least one policy */
+    if (npol>0)	{
+	pol_array[npol]=NULL;
+	*policies=pol_array;
+    } else  /* No policies: free pol_array */
+	free(pol_array);
+    /* Free temporary local storage */
+    free(inp_copy);
+    
+    return npol;
+}
 
 int llgt_run_lcmaps(gss_cred_id_t user_cred_handle, char * client_name, FILE * logfile, char ** username)
 {
@@ -112,6 +185,10 @@
     char *  error           = NULL;
     int     retval          = 0;
     char *  liblcmaps_path  = NULL;
+
+    int i,npol=0;
+    char **policies=NULL;
+
     int (*LcmapsInit)(FILE *);
     int (*LcmapsTerm)();
     void (*LcmapsEnableVomsAttributesVerification)();
@@ -122,7 +199,7 @@
     int (*LcmapsRunAndReturnUsername)(gss_cred_id_t, char*, char**, int, char**);
 #endif /* ALLOW_EMPTY_CREDENTIALS */
 
-    /* Get the path to the to be opened LCAS main library - Must be free'd */
+    /* Get the path to the to be opened LCMAPS main library - Must be free'd */
     if (set_liblcmaps_path(&liblcmaps_path)) {
         llgt_logmsg(LOG_ERR, "Couldn't set the path to \"%s\"\n", LIBLCMAPS_SO);
         return 1;
@@ -130,7 +207,8 @@
 
     /* I must have a path set */
     if (!liblcmaps_path) {
-        llgt_logmsg(LOG_ERR, "Failed set a name or path to find liblcas.so\n");
+        llgt_logmsg(LOG_ERR, "Failed set a name or path to find %s\n",
+		    LIBLCMAPS_SO);
         return 1;
     }
 
@@ -191,22 +269,37 @@
             (*LcmapsEnableVomsAttributesVerification)();
         }
 
+	/* Split the LCMAPS_POLICY_NAME contents into an array of policy 
+	 * names */
+	if ( (npol=policy_tokenize(&policies)) < 0) {
+	    llgt_logmsg(LOG_ERR,
+		"Failed to parse value of env variable LCMAPS_POLICY_NAME");
+	    npol=0;
+	}
+
 #if ALLOW_EMPTY_CREDENTIALS
         retval=(*LcmapsRunAndReturnUsername)(client_name,
                                              user_cred_handle,
                                              NULL,
                                              username,
-                                             0,
-                                             NULL
+                                             npol,
+                                             policies
                                             );
 #else
         retval=(*LcmapsRunAndReturnUsername)(user_cred_handle,
                                              NULL,
                                              username,
-                                             0,
-                                             NULL
+                                             npol,
+                                             policies
                                             );
 #endif
+
+	/* Free memory malloced: note that the policies[0] points to the result
+	 * of the strdup */
+	for (i=0; i<npol; i++)
+	    free(policies[i]);
+	free(policies);
+
         if (retval) {
             llgt_logmsg(LOG_WARNING, "Warning: failed mapping. LCMAPS returned: %d\n", retval);
             if ((*LcmapsTerm)()) {
@@ -215,15 +308,18 @@
                 return 1;
             }
             dlclose(lcmaps_handle);
+	    free(liblcmaps_path);
             return 1;
         }
         retval=(*LcmapsTerm)();
         if (retval) {
             llgt_logmsg(LOG_ERR, "LCMAPS Termination failure!");
             dlclose(lcmaps_handle);
+	    free(liblcmaps_path);
             return 1;
         }
         dlclose(lcmaps_handle);
+	free(liblcmaps_path);
     }
     /* END USER MAPPING */
     return 0;
