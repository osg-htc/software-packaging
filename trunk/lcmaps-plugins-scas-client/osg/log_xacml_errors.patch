--- src/scas-client/lcmaps_scas_client.c.orig2	2013-09-16 20:10:52.504808328 -0500
+++ src/scas-client/lcmaps_scas_client.c	2013-09-16 20:56:06.509036872 -0500
@@ -65,6 +65,7 @@
 #include <openssl/x509_vfy.h>
 #include <openssl/asn1.h>
 #include <time.h>
+#include <fcntl.h>
 
 #include <netdb.h>
 #include <sys/socket.h>
@@ -121,6 +122,8 @@
 
 // #define VOMS_BUFFER_SIZE  1024
 
+#define PIPE_BUFFER_SIZE 1024
+
 // What do we want to do with this time presentation?
 #define GMT               1
 
@@ -161,6 +164,7 @@
 static XACML_QUERY_ANSWER_T xacmlqueryscas (char *           ,
                                             xacml_request_t  ,
                                             xacml_response_t );
+static void log_fake_stderr(int level, int fd);
 
 static time_t lcmaps_scas_client_asn1TimeToTimeT(char *asn1time);
 static time_t lcmaps_scas_client_timegm(struct tm *tm);
@@ -789,6 +793,7 @@
     int fd_out_save         = -1;
     int fd_err              = -1;
     int fd_err_save         = -1;
+    int pfd[2]; pfd[0] = -1; pfd[1] = -1;
 /* Hack: SAML2-XACML2 must not write to stdout */
 
 
@@ -1221,8 +1226,24 @@
 
     streams_redirected = 1;
 
-    freopen ("/dev/null", "w", stdout);
-    freopen ("/dev/null", "w", stderr);
+    if (pipe(pfd))
+    {
+        lcmaps_log(LOG_ERR, "%s: XACML: Error - cannot open new pipes: (errno=%d, %s)\n", logstr, errno, strerror(errno));
+        goto fail_scas_client;
+    }
+    if ((fcntl(pfd[1], F_SETFD, FD_CLOEXEC) == -1) || (fcntl(pfd[0], F_SETFD, FD_CLOEXEC) == -1))
+    {
+        lcmaps_log(LOG_ERR, "%s: XACML: Error - cannot set pipes to CLOEXEC: (errno=%d, %s)\n", logstr, errno, strerror(errno));
+        goto fail_scas_client;
+    }
+    if ((fcntl(pfd[1], F_SETFL, O_NONBLOCK) == -1) || (fcntl(pfd[0], F_SETFL, O_NONBLOCK) == -1))
+    {
+        lcmaps_log(LOG_ERR, "%s: XACML: Error - cannot set write pipe to non-blocking: (errno=%d, %s)\n", logstr, errno, strerror(errno));
+        goto fail_scas_client;
+    }
+
+    dup2(pfd[1], 1);
+    dup2(pfd[1], 2);
     /************* E: Silence the stdout and stderr of the SAML2-XACML2 library *************/
 
 
@@ -1246,23 +1267,27 @@
                     switch (rc)
                     {
                         case XACML_QUERY_ALLOWED        :
+                            log_fake_stderr(LOG_NOTICE, pfd[0]);
                             lcmaps_log (LOG_NOTICE, "%s: User \"%s\" with first FQAN \"%s\" Permitted at endpoint \"%s\"\n",
                                            logstr, user_dn, (nfqans > 0) ? fqans[0] : "", endpoints[i]);
                             should_do_high_level_retry = 0;
                             break;
                         case XACML_QUERY_BANNED         :
+                            log_fake_stderr(LOG_WARNING, pfd[0]);
                             lcmaps_log (LOG_WARNING, "%s: User \"%s\" with first FQAN \"%s\" Banned at endpoint \"%s\"\n",
                                            logstr, user_dn, (nfqans > 0) ? fqans[0] : "", endpoints[i]);
                             should_do_high_level_retry = 0;
                             goto fail_scas_client;
                             break;
                         case XACML_QUERY_PROTOCOL_ERROR :
+                            log_fake_stderr(LOG_ERR, pfd[0]);
                             lcmaps_log_debug (2, "%s: Failed to authorize and get a mapping with endpoint \"%s\" (on try #%d)\n", logstr, endpoints[i], j + 1);
 
                             /* Wait for 50 milli seconds, plus a random number that randomizes below the 10 milli seconds */
                             usleep (50000 + rand_r (&seed) % 10000);
                             break; /* continue the for loops */
                         default:
+                            log_fake_stderr(LOG_ERR, pfd[0]);
                             lcmaps_log(LOG_ERR, "%s: Failed to authorize and get a mapping with endpoint (with odd error return from xacmlqueryscas()) \"%s\" (on try #%d)\n",
                                             logstr, endpoints[i], j + 1);
 
@@ -1297,23 +1322,27 @@
                     switch (rc)
                     {
                         case XACML_QUERY_ALLOWED        :
+                            log_fake_stderr(LOG_NOTICE, pfd[0]);
                             lcmaps_log (LOG_NOTICE, "%s: User \"%s\" with first FQAN \"%s\" Permitted at endpoint \"%s\"\n",
                                            logstr, user_dn, (nfqans > 0) ? fqans[0] : "", endpoints[selected_endpoint]);
                             should_do_high_level_retry = 0;
                             break;
                         case XACML_QUERY_BANNED         :
+                            log_fake_stderr(LOG_WARNING, pfd[0]);
                             lcmaps_log (LOG_WARNING, "%s: User \"%s\" with first FQAN \"%s\" Banned at endpoint \"%s\"\n",
                                            logstr, user_dn, (nfqans > 0) ? fqans[0] : "", endpoints[selected_endpoint]);
                             should_do_high_level_retry = 0;
                             goto fail_scas_client;
                             break;
                         case XACML_QUERY_PROTOCOL_ERROR :
+                            log_fake_stderr(LOG_ERR, pfd[0]);
                             lcmaps_log_debug (2, "%s: Failed to authorize and get a mapping with endpoint \"%s\" (on try #%d)\n", logstr, endpoints[selected_endpoint], j + 1);
 
                             /* Wait for 50 milli seconds, plus a random number that randomizes below the 10 milli seconds */
                             usleep (50000 + rand_r (&seed) % 10000);
                             break; /* continue the for loops */
                         default:
+                            log_fake_stderr(LOG_ERR, pfd[0]);
                             lcmaps_log(LOG_ERR, "%s: Failed to authorize and get a mapping with endpoint (with odd error return from xacmlqueryscas()) \"%s\" (on try #%d)\n",
                                             logstr, endpoints[selected_endpoint], j + 1);
 
@@ -1347,23 +1376,27 @@
                     switch (rc)
                     {
                         case XACML_QUERY_ALLOWED        :
+                            log_fake_stderr(LOG_NOTICE, pfd[0]);
                             lcmaps_log (LOG_NOTICE, "%s: User \"%s\" with first FQAN \"%s\" Permitted at endpoint \"%s\"\n",
                                            logstr, user_dn, (nfqans > 0) ? fqans[0] : "", endpoints[random_choice]);
                             should_do_high_level_retry = 0;
                             break;
                         case XACML_QUERY_BANNED         :
+                            log_fake_stderr(LOG_WARNING, pfd[0]);
                             lcmaps_log (LOG_WARNING, "%s: User \"%s\" with first FQAN \"%s\" Banned at endpoint \"%s\"\n",
                                            logstr, user_dn, (nfqans > 0) ? fqans[0] : "", endpoints[random_choice]);
                             should_do_high_level_retry = 0;
                             goto fail_scas_client;
                             break;
                         case XACML_QUERY_PROTOCOL_ERROR :
+                            log_fake_stderr(LOG_ERR, pfd[0]);
                             lcmaps_log_debug (2, "%s: Failed to authorize and get a mapping with endpoint \"%s\" (on try #%d)\n", logstr, endpoints[random_choice], j + 1);
 
                             /* Wait for 50 milli seconds, plus a random number that randomizes below the 10 milli seconds */
                             usleep (50000 + rand_r (&seed) % 10000);
                             break; /* continue the for loops */
                         default:
+                            log_fake_stderr(LOG_ERR, pfd[0]);
                             lcmaps_log(LOG_ERR, "%s: Failed to authorize and get a mapping with endpoint (with odd error return from xacmlqueryscas()) \"%s\" (on try #%d)\n",
                                             logstr, endpoints[random_choice], j + 1);
 
@@ -1395,23 +1428,27 @@
                     switch (rc)
                     {
                         case XACML_QUERY_ALLOWED        :
+                            log_fake_stderr(LOG_NOTICE, pfd[0]);
                             lcmaps_log (LOG_NOTICE, "%s: User \"%s\" with first FQAN \"%s\" Permitted at endpoint \"%s\"\n",
                                            logstr, user_dn, (nfqans > 0) ? fqans[0] : "", endpoints[i]);
                             should_do_high_level_retry = 0;
                             break;
                         case XACML_QUERY_BANNED         :
+                            log_fake_stderr(LOG_WARNING, pfd[0]);
                             lcmaps_log (LOG_WARNING, "%s: User \"%s\" with first FQAN \"%s\" Banned at endpoint \"%s\"\n",
                                            logstr, user_dn, (nfqans > 0) ? fqans[0] : "", endpoints[i]);
                             should_do_high_level_retry = 0;
                             goto fail_scas_client;
                             break;
                         case XACML_QUERY_PROTOCOL_ERROR :
+                            log_fake_stderr(LOG_ERR, pfd[0]);
                             lcmaps_log_debug (2, "%s: Failed to authorize and get a mapping with endpoint \"%s\" (on try #%d)\n", logstr, endpoints[i], j + 1);
 
                             /* Wait for 50 milli seconds, plus a random number that randomizes below the 10 milli seconds */
                             usleep (50000 + rand_r (&seed) % 10000);
                             break; /* continue the for loops */
                         default:
+                            log_fake_stderr(LOG_ERR, pfd[0]);
                             lcmaps_log(LOG_ERR, "%s: Failed to authorize and get a mapping with endpoint (with odd error return from xacmlqueryscas()) \"%s\" (on try #%d)\n", logstr, endpoints[i], j + 1);
 
                             /* Wait for 50 milli seconds, plus a random number that randomizes below the 10 milli seconds */
@@ -1474,6 +1511,8 @@
 
         streams_redirected = 0;
     }
+    if (pfd[0] >= 0) close(pfd[0]);
+    if (pfd[1] >= 0) close(pfd[1]);
     /** B: Restore stderr and stdout streams ***/
 
 
@@ -1646,6 +1685,33 @@
     return 0;
 }
 
+/******************************************************************************
+Function:       log_fake_stderr
+Description:    Dumps the contents of the read pipe to the logfile
+Parameters:
+                level - log level
+                fd - file descriptor to read from
+Returns:        void
+******************************************************************************/
+void log_fake_stderr(int level, int fd)
+{
+    char pipe_buf[PIPE_BUFFER_SIZE];
+    int ret;
+    while ((ret = read(fd, pipe_buf, PIPE_BUFFER_SIZE-1)) != 0)
+    {
+        if (ret == -1)
+        {
+            if (ret != EINTR) break;
+            else continue;
+        }
+        pipe_buf[ret] = '\0';
+        lcmaps_log(level, "%s", pipe_buf);
+    }
+    if ((ret == -1) && (errno != EAGAIN))
+    {
+        lcmaps_log(level, "Error reading from error buffer: (errno=%d, %s)\n", errno, strerror(errno));
+    }
+}
 
 /******************************************************************************
 Function:       xacmlqueryscas
