diff --git a/cvmfs/cache.cc b/cvmfs/cache.cc
index b2539b0..e83438b 100644
--- a/cvmfs/cache.cc
+++ b/cvmfs/cache.cc
@@ -30,6 +30,7 @@
 #include "cache.h"
 
 #include <sys/stat.h>
+#include <sys/statfs.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <pthread.h>
@@ -60,6 +61,10 @@
 #include "manifest_fetch.h"
 #include "cvmfs.h"
 
+#ifndef NFS_SUPER_MAGIC
+#define NFS_SUPER_MAGIC 0x6969
+#endif
+
 using namespace std;  // NOLINT
 
 namespace cache {
@@ -113,6 +118,7 @@ typedef map< shash::Any, vector<int> * > ThreadQueues;
 
 string *cache_path_ = NULL;
 bool alien_cache_ = false;
+bool alien_cache_on_nfs_ = false;
 ThreadQueues *queues_download_ = NULL;  /**< maps currently
   downloaded chunks to an array of writer's ends of a pipe to signal the waiting
   threads when the download has finished */
@@ -170,6 +176,14 @@ bool Init(const string &cache_path, const bool alien_cache) {
     }
     LogCvmfs(kLogCache, kLogDebug | kLogSyslog,
              "Cache directory structure created.");
+    struct statfs cache_buf;
+    if ((statfs(cache_path.c_str(), &cache_buf) == 0) &&
+	    (cache_buf.f_type == NFS_SUPER_MAGIC))
+    {
+      alien_cache_on_nfs_ = true;
+      LogCvmfs(kLogCache, kLogDebug | kLogSyslog,
+             "Alien cache is on NFS.");
+    }
   } else {
     if (!MakeCacheDirectories(cache_path, 0700))
       return false;
@@ -357,6 +371,34 @@ static int AbortTransaction(const string &temp_path) {
 
 
 /**
+ * Renames a file.  If using alien_cache on NFS, need to avoid deleting
+ * an existing file that was created by more than one node, so use
+ * link()/unlink() to rename, and ignore if the file already exists.
+ *
+ * @param[in] oldpath Absolute path of the file to rename
+ * @param[in] newpath Absolute path to rename the file to
+ * \return Zero on success, non-zero else.
+ */
+
+static int Rename(const char *oldpath,
+	          const char *newpath)
+{
+  if (!alien_cache_on_nfs_) {
+    return rename(oldpath, newpath);
+  }
+
+  int result = link(oldpath, newpath);
+  if (result < 0) {
+    if (errno == EEXIST)
+      LogCvmfs(kLogCache, kLogDebug, "%s already existed, ignoring", newpath);
+    else
+      return(result);
+  }
+  return(unlink(oldpath));
+}
+
+
+/**
  * Commits a file download started with StartTransaction(), i.e. renames
  * the temporary file to its real content hash name.
  *
@@ -385,7 +427,7 @@ static int CommitTransaction(const string &final_path,
     int retval = chmod(temp_path.c_str(), 0660);
     assert(retval == 0);
   }
-  result = rename(temp_path.c_str(), final_path.c_str());
+  result = Rename(temp_path.c_str(), final_path.c_str());
   if (result < 0) {
     result = -errno;
     LogCvmfs(kLogCache, kLogDebug, "commit failed: %s", strerror(errno));
@@ -743,7 +785,7 @@ catalog::LoadError CatalogManager::LoadCatalogCas(const shash::Any &hash,
   // Try from cache
   const string cache_path = *cache_path_ + hash.MakePath(1, 2);
   *catalog_path = cache_path + "T";
-  retval = rename(cache_path.c_str(), catalog_path->c_str());
+  retval = Rename(cache_path.c_str(), catalog_path->c_str());
   if (retval == 0) {
     LogCvmfs(kLogCache, kLogDebug, "found catalog %s in cache",
              hash.ToString().c_str());
@@ -761,7 +803,7 @@ catalog::LoadError CatalogManager::LoadCatalogCas(const shash::Any &hash,
       }
     }
     // Pinned, can be safely renamed
-    retval = rename(catalog_path->c_str(), cache_path.c_str());
+    retval = Rename(catalog_path->c_str(), cache_path.c_str());
     *catalog_path = cache_path;
     return catalog::kLoadNew;
   }
@@ -818,7 +860,7 @@ catalog::LoadError CatalogManager::LoadCatalogCas(const shash::Any &hash,
 
   retval = chmod(temp_path.c_str(), 0660);
   assert(retval == 0);
-  retval = rename(temp_path.c_str(), catalog_path->c_str());
+  retval = Rename(temp_path.c_str(), catalog_path->c_str());
   if (retval != 0) {
     quota::Remove(hash);
     backoff_throttle_.Throttle();
