From 900fde2d5c1253a4523928f2821624881459ddbf Mon Sep 17 00:00:00 2001
From: Cedric Clerget <cedric.clerget@gmail.com>
Date: Tue, 27 Mar 2018 22:53:23 +0200
Subject: [PATCH 1/3] Don't create files or directories with nested binds. Add
 a base path argument to s_mkpath to check if created directory are within
 base path. Save and restore mount errno in singularity_mount.

---
 src/lib/runtime/files/libs/libs.c            |  4 ++--
 src/lib/runtime/mounts/binds/binds.c         |  9 +++++++--
 src/lib/runtime/mounts/dev/dev.c             |  8 ++++----
 src/lib/runtime/mounts/home/home.c           |  4 ++--
 src/lib/runtime/mounts/hostfs/hostfs.c       |  2 +-
 src/lib/runtime/mounts/scratch/scratch.c     |  4 ++--
 src/lib/runtime/mounts/tmp/tmp.c             |  4 ++--
 src/lib/runtime/mounts/userbinds/userbinds.c | 14 +++++++++-----
 src/lib/runtime/overlayfs/overlayfs.c        |  6 +++---
 src/util/daemon.c                            |  2 +-
 src/util/file.c                              | 28 ++++++++++++++++++++++++++--
 src/util/file.h                              |  2 +-
 src/util/mount.c                             | 22 +++++++++++++++++++---
 13 files changed, 79 insertions(+), 30 deletions(-)

diff --git a/src/lib/runtime/files/libs/libs.c b/src/lib/runtime/files/libs/libs.c
index 4d17665..e9538c6 100644
--- a/src/lib/runtime/files/libs/libs.c
+++ b/src/lib/runtime/files/libs/libs.c
@@ -73,11 +73,11 @@ int _singularity_runtime_files_libs(void) {
         if ( is_dir(libdir_contained) != 0 ) {
             singularity_message(WARNING, "Library bind directory not present in container, update container\n");
         }
 
         singularity_message(DEBUG, "Creating session libdir at: %s\n", libdir);
-        if ( s_mkpath(libdir, 0755) != 0 ) {
+        if ( s_mkpath(libdir, 0755, tmpdir) != 0 ) {
             singularity_message(ERROR, "Failed creating temp lib directory at: %s\n", libdir);
             ABORT(255);
         }
 
         while (current != NULL ) {
@@ -148,11 +148,11 @@ int _singularity_runtime_files_libs(void) {
 
         if ( is_dir(libdir_contained) != 0 ) {
             char *ld_path;
             singularity_message(DEBUG, "Attempting to create contained libdir\n");
             singularity_priv_escalate();
-            if ( s_mkpath(libdir_contained, 0755) != 0 ) {
+            if ( s_mkpath(libdir_contained, 0755, container_dir) != 0 ) {
                 singularity_message(ERROR, "Failed creating directory %s :%s\n", libdir_contained, strerror(errno));
                 ABORT(255);
             }
             singularity_priv_drop();
             ld_path = envar_path("LD_LIBRARY_PATH");
diff --git a/src/lib/runtime/mounts/binds/binds.c b/src/lib/runtime/mounts/binds/binds.c
index 1364c94..eed4f04 100644
--- a/src/lib/runtime/mounts/binds/binds.c
+++ b/src/lib/runtime/mounts/binds/binds.c
@@ -83,16 +83,21 @@ int _singularity_runtime_mount_binds(void) {
         }
 
         if ( ( is_file(source) == 0 ) && ( is_file(joinpath(container_dir, dest)) < 0 ) ) {
             if ( singularity_registry_get("OVERLAYFS_ENABLED") != NULL ) {
                 char *basedir = dirname(joinpath(container_dir, dest));
+                char *dir = dirname(strdup(dest));
+                if ( strcmp(dir, "/") != 0 && check_mounted(dir) >= 0 ) {
+                    singularity_message(WARNING, "Nested bind detected, skip file creation\n");
+                    continue;
+                }
 
                 singularity_message(DEBUG, "Checking base directory for file %s ('%s')\n", dest, basedir);
                 if ( is_dir(basedir) != 0 ) {
                     singularity_message(DEBUG, "Creating base directory for file bind\n");
                     singularity_priv_escalate();
-                    if ( s_mkpath(basedir, 0755) != 0 ) {
+                    if ( s_mkpath(basedir, 0755, container_dir) != 0 ) {
                         singularity_message(ERROR, "Failed creating base directory to bind file: %s\n", dest);
                         ABORT(255);
                     }
                     singularity_priv_drop();
                 }
@@ -118,11 +123,11 @@ int _singularity_runtime_mount_binds(void) {
             }
         } else if ( ( is_dir(source) == 0 ) && ( is_dir(joinpath(container_dir, dest)) < 0 ) ) {
             if ( singularity_registry_get("OVERLAYFS_ENABLED") != NULL ) {
                 singularity_priv_escalate();
                 singularity_message(VERBOSE3, "Creating bind directory on overlay file system: %s\n", dest);
-                if ( s_mkpath(joinpath(container_dir, dest), 0755) < 0 ) {
+                if ( s_mkpath(joinpath(container_dir, dest), 0755, container_dir) < 0 ) {
                     singularity_priv_drop();
                     singularity_message(WARNING, "Could not create bind point directory in container %s: %s\n", dest, strerror(errno));
                     continue;
                 }
                 singularity_priv_drop();
diff --git a/src/lib/runtime/mounts/dev/dev.c b/src/lib/runtime/mounts/dev/dev.c
index 91b3255..1753682 100644
--- a/src/lib/runtime/mounts/dev/dev.c
+++ b/src/lib/runtime/mounts/dev/dev.c
@@ -60,40 +60,40 @@ int _singularity_runtime_mount_dev(void) {
                 singularity_message(WARNING, "Not mounting devices as /dev directory does not exist within container\n");
                 return(-1);
             }
 
             singularity_priv_escalate();
-            ret = s_mkpath(joinpath(container_dir, "/dev"), 0755);
+            ret = s_mkpath(joinpath(container_dir, "/dev"), 0755, container_dir);
             singularity_priv_drop();
 
             if ( ret < 0 ) {
                 singularity_message(ERROR, "Could not create /dev inside container\n");
                 ABORT(255);
             }
         }
 
         singularity_message(DEBUG, "Creating temporary staged /dev\n");
-        if ( s_mkpath(devdir, 0755) != 0 ) {
+        if ( s_mkpath(devdir, 0755, NULL) != 0 ) {
             singularity_message(ERROR, "Failed creating the session device directory %s: %s\n", devdir, strerror(errno));
             ABORT(255);
         }
 
         singularity_message(DEBUG, "Creating temporary staged /dev/shm\n");
-        if ( s_mkpath(joinpath(devdir, "/shm"), 0755) != 0 ) {
+        if ( s_mkpath(joinpath(devdir, "/shm"), 0755, NULL) != 0 ) {
             singularity_message(ERROR, "Failed creating temporary /dev/shm %s: %s\n", joinpath(devdir, "/shm"), strerror(errno));
             ABORT(255);
         }
 
         if ( singularity_config_get_bool_char(MOUNT_DEVPTS) > 0 ) {
             struct stat multi_instance_devpts;
             
             if( stat("/dev/pts/ptmx", &multi_instance_devpts) < 0 ) {
                 singularity_message(ERROR, "Multiple devpts instances unsupported and \"%s\" configured\n", MOUNT_DEVPTS);
                 ABORT(255);
             }
             singularity_message(DEBUG, "Creating staged /dev/pts\n");
-            if ( s_mkpath(joinpath(devdir, "/pts"), 0755) != 0 ) {
+            if ( s_mkpath(joinpath(devdir, "/pts"), 0755, NULL) != 0 ) {
                 singularity_message(ERROR, "Failed creating /dev/pts %s: %s\n", joinpath(devdir, "/pts"), strerror(errno));
                 ABORT(255);
             }
             bind_dev(sessiondir, "/dev/tty");
         }
diff --git a/src/lib/runtime/mounts/home/home.c b/src/lib/runtime/mounts/home/home.c
index ade5853..a680213 100644
--- a/src/lib/runtime/mounts/home/home.c
+++ b/src/lib/runtime/mounts/home/home.c
@@ -91,11 +91,11 @@ int _singularity_runtime_mount_home(void) {
         singularity_message(VERBOSE, "Not mounting home directory (already mounted in container): %s\n", home_dest);
         return(0);
     }
 
     singularity_message(DEBUG, "Creating temporary directory to stage home: %s\n", joinpath(session_dir, home_dest));
-    if ( s_mkpath(joinpath(session_dir, home_dest), 0755) < 0 ) {
+    if ( s_mkpath(joinpath(session_dir, home_dest), 0755, session_dir) < 0 ) {
         singularity_message(ERROR, "Failed creating home directory stage %s: %s\n", joinpath(session_dir, home_dest), strerror(errno));
         ABORT(255);
     }
 
     singularity_message(DEBUG, "Checking if SINGULARITY_CONTAIN is set\n");
@@ -143,11 +143,11 @@ int _singularity_runtime_mount_home(void) {
     } else {
         singularity_message(DEBUG, "Staging home directory\n");
 
         singularity_priv_escalate();
         singularity_message(DEBUG, "Creating home directory within container: %s\n", joinpath(container_dir, home_dest));
-        if ( s_mkpath(joinpath(container_dir, home_dest), 0755) < 0 ) {
+        if ( s_mkpath(joinpath(container_dir, home_dest), 0755, container_dir) < 0 ) {
             singularity_message(ERROR, "Failed creating home directory in container %s: %s\n", joinpath(container_dir, home_dest), strerror(errno));
             ABORT(255);
         }
         singularity_priv_drop();
 
diff --git a/src/lib/runtime/mounts/hostfs/hostfs.c b/src/lib/runtime/mounts/hostfs/hostfs.c
index a8ce8a9..0c4502e 100644
--- a/src/lib/runtime/mounts/hostfs/hostfs.c
+++ b/src/lib/runtime/mounts/hostfs/hostfs.c
@@ -149,11 +149,11 @@ int _singularity_runtime_mount_hostfs(void) {
         }
 
         if ( ( is_dir(mountpoint) == 0 ) && ( is_dir(joinpath(container_dir, mountpoint)) < 0 ) ) {
             if ( singularity_registry_get("OVERLAYFS_ENABLED") != NULL ) {
                 singularity_priv_escalate();
-                if ( s_mkpath(joinpath(container_dir, mountpoint), 0755) < 0 ) {
+                if ( s_mkpath(joinpath(container_dir, mountpoint), 0755, container_dir) < 0 ) {
                     singularity_priv_drop();
                     singularity_message(WARNING, "Could not create bind point directory in container %s: %s\n", mountpoint, strerror(errno));
                     continue;
                 }
                 singularity_priv_drop();
diff --git a/src/lib/runtime/mounts/scratch/scratch.c b/src/lib/runtime/mounts/scratch/scratch.c
index 2120492..46b9efc 100644
--- a/src/lib/runtime/mounts/scratch/scratch.c
+++ b/src/lib/runtime/mounts/scratch/scratch.c
@@ -90,20 +90,20 @@ int _singularity_runtime_mount_scratch(void) {
     while ( current != NULL ) {
 
         char *full_sourcedir_path = joinpath(sourcedir_path, basename(strdup(current)));
         char *full_destdir_path = joinpath(container_dir, current);
 
-        if ( s_mkpath(full_sourcedir_path, 0750) < 0 ) {
+        if ( s_mkpath(full_sourcedir_path, 0750, NULL) < 0 ) {
              singularity_message(ERROR, "Could not create scratch working directory %s: %s\n", full_sourcedir_path, strerror(errno));
              ABORT(255);
         }
 
         if ( is_dir(full_destdir_path) != 0 ) {
             if ( singularity_registry_get("OVERLAYFS_ENABLED") != NULL ) {
                 singularity_priv_escalate();
                 singularity_message(DEBUG, "Creating scratch directory inside container\n");
-                r = s_mkpath(full_destdir_path, 0755);
+                r = s_mkpath(full_destdir_path, 0755, container_dir);
                 singularity_priv_drop();
                 if ( r < 0 ) {
                     singularity_message(VERBOSE, "Skipping scratch directory mount, could not create dir inside container %s: %s\n", current, strerror(errno));
                     current = strtok_r(NULL, ",", &outside_token);
                     continue;
diff --git a/src/lib/runtime/mounts/tmp/tmp.c b/src/lib/runtime/mounts/tmp/tmp.c
index 5e8e941..559e789 100644
--- a/src/lib/runtime/mounts/tmp/tmp.c
+++ b/src/lib/runtime/mounts/tmp/tmp.c
@@ -79,11 +79,11 @@ int _singularity_runtime_mount_tmp(void) {
         }
         free(tmpdirpath);
     }
 
     if ( check_mounted("/tmp") < 0 ) {
-        if ( s_mkpath(tmp_source, 0755) < 0 ) {
+        if ( s_mkpath(tmp_source, 0755, NULL) < 0 ) {
             singularity_message(ERROR, "Could not create source /tmp directory %s: %s\n", tmp_source, strerror(errno));
             ABORT(255);
         }
         if ( is_dir(tmp_source) == 0 ) {
             if ( is_dir(joinpath(container_dir, "/tmp")) == 0 ) {
@@ -107,11 +107,11 @@ int _singularity_runtime_mount_tmp(void) {
     } else {
         singularity_message(VERBOSE, "Not mounting '/tmp', already mounted\n");
     }
 
     if ( check_mounted("/var/tmp") < 0 ) {
-        if ( s_mkpath(vartmp_source, 0755) < 0 ) {
+        if ( s_mkpath(vartmp_source, 0755, NULL) < 0 ) {
             singularity_message(ERROR, "Could not create source /var/tmp directory %s: %s\n", vartmp_source, strerror(errno));
             ABORT(255);
         }
         if ( is_dir(vartmp_source) == 0 ) {
             if ( is_dir(joinpath(container_dir, "/var/tmp")) == 0 ) {
diff --git a/src/lib/runtime/mounts/userbinds/userbinds.c b/src/lib/runtime/mounts/userbinds/userbinds.c
index e6fea30..c6785c6 100644
--- a/src/lib/runtime/mounts/userbinds/userbinds.c
+++ b/src/lib/runtime/mounts/userbinds/userbinds.c
@@ -91,26 +91,30 @@ int _singularity_runtime_mount_userbinds(void) {
                     singularity_message(WARNING, "Not mounting requested bind point, invalid mount option %s: %s\n", opts, dest);
                     continue;
                 }
             }
 
-
             singularity_message(DEBUG, "Checking if bind point is already mounted: %s\n", dest);
             if ( check_mounted(dest) >= 0 ) {
                 singularity_message(WARNING, "Not mounting requested bind point (already mounted in container): %s\n", dest);
                 continue;
             }
 
             if ( ( is_file(source) == 0 ) && ( is_file(joinpath(container_dir, dest)) < 0 ) ) {
                 if ( singularity_registry_get("OVERLAYFS_ENABLED") != NULL ) {
                     char *dir = dirname(strdup(dest));
+                    if ( strcmp(dir, "/") != 0 && check_mounted(dir) >= 0 ) {
+                        singularity_message(WARNING, "Nested bind detected, skip file creation\n");
+                        continue;
+                    }
+
                     if ( is_dir(joinpath(container_dir, dir)) < 0 ) {
                         singularity_message(VERBOSE3, "Creating bind directory on overlay file system: %s\n", dest);
-                        if ( s_mkpath(joinpath(container_dir, dir), 0755) < 0 ) {
+                        if ( s_mkpath(joinpath(container_dir, dir), 0755, container_dir) < 0 ) {
                             singularity_priv_escalate();
                             singularity_message(VERBOSE3, "Retrying with privileges to create bind directory on overlay file system: %s\n", dest);
-                            if ( s_mkpath(joinpath(container_dir, dir), 0755) < 0 ) {
+                            if ( s_mkpath(joinpath(container_dir, dir), 0755, container_dir) < 0 ) {
                                 singularity_message(ERROR, "Could not create basedir for file bind %s: %s\n", dest, strerror(errno));
                                 continue;
                             }
                             singularity_priv_drop();
                         }
@@ -133,14 +137,14 @@ int _singularity_runtime_mount_userbinds(void) {
                     continue;
                 }
             } else if ( ( is_dir(source) == 0 ) && ( is_dir(joinpath(container_dir, dest)) < 0 ) ) {
                 if ( singularity_registry_get("OVERLAYFS_ENABLED") != NULL ) {
                     singularity_message(VERBOSE3, "Creating bind directory on overlay file system: %s\n", dest);
-                    if ( s_mkpath(joinpath(container_dir, dest), 0755) < 0 ) {
+                    if ( s_mkpath(joinpath(container_dir, dest), 0755, container_dir) < 0 ) {
                         singularity_priv_escalate();
                         singularity_message(VERBOSE3, "Retrying with privileges to create bind directory on overlay file system: %s\n", dest);
-                        if ( s_mkpath(joinpath(container_dir, dest), 0755) < 0 ) {
+                        if ( s_mkpath(joinpath(container_dir, dest), 0755, container_dir) < 0 ) {
                             singularity_priv_drop();
                             singularity_message(WARNING, "Skipping user bind, could not create bind point %s: %s\n", dest, strerror(errno));
                             continue;
                         }
                         singularity_priv_drop();
diff --git a/src/lib/runtime/overlayfs/overlayfs.c b/src/lib/runtime/overlayfs/overlayfs.c
index d522584..62995a0 100644
--- a/src/lib/runtime/overlayfs/overlayfs.c
+++ b/src/lib/runtime/overlayfs/overlayfs.c
@@ -49,11 +49,11 @@
 
 int _singularity_runtime_overlayfs(void) {
 
     singularity_priv_escalate();
     singularity_message(DEBUG, "Creating overlay_final directory: %s\n", CONTAINER_FINALDIR);
-    if ( s_mkpath(CONTAINER_FINALDIR, 0755) < 0 ) {
+    if ( s_mkpath(CONTAINER_FINALDIR, 0755, NULL) < 0 ) {
         singularity_message(ERROR, "Failed creating overlay_final directory %s: %s\n", CONTAINER_FINALDIR, strerror(errno));
         ABORT(255);
     }
     singularity_priv_drop();
 
@@ -141,17 +141,17 @@ int _singularity_runtime_overlayfs(void) {
             ABORT(255);
         }
 
         singularity_priv_escalate();
         singularity_message(DEBUG, "Creating upper overlay directory: %s\n", overlay_upper);
-        if ( s_mkpath(overlay_upper, 0755) < 0 ) {
+        if ( s_mkpath(overlay_upper, 0755, overlay_mount) < 0 ) {
             singularity_message(ERROR, "Failed creating upper overlay directory %s: %s\n", overlay_upper, strerror(errno));
             ABORT(255);
         }
 
         singularity_message(DEBUG, "Creating overlay work directory: %s\n", overlay_work);
-        if ( s_mkpath(overlay_work, 0755) < 0 ) {
+        if ( s_mkpath(overlay_work, 0755, overlay_mount) < 0 ) {
             singularity_message(ERROR, "Failed creating overlay work directory %s: %s\n", overlay_work, strerror(errno));
             ABORT(255);
         }
         singularity_priv_drop();
 
diff --git a/src/util/daemon.c b/src/util/daemon.c
index b66c45f..2124960 100644
--- a/src/util/daemon.c
+++ b/src/util/daemon.c
@@ -149,11 +149,11 @@ void daemon_init_start(void) {
     int daemon_fd;
     int lock;
     
     /* Check if /var/tmp/.singularity-daemon-[UID]/ directory exists, if not create it */
     if ( is_dir(dirname(daemon_file_dir)) == -1 ) {
-        s_mkpath(daemon_file_dir, 0755);
+        s_mkpath(daemon_file_dir, 0755, NULL);
     }
     
     /* Attempt to open lock on daemon file */
     lock = filelock(daemon_file, &daemon_fd);
 
diff --git a/src/util/file.c b/src/util/file.c
index 21aaa50..de43001 100644
--- a/src/util/file.c
+++ b/src/util/file.c
@@ -279,33 +279,57 @@ int is_chr(char *path) {
 
     return(-1);
 }
 
 
-int s_mkpath(char *dir, mode_t mode) {
+int s_mkpath(char *dir, mode_t mode, char *base) {
+    char *dupdir;
+    char *realdir;
+
     if (!dir) {
         return(-1);
     }
 
     if (strcmp(dir, "/") == 0 ) {
         singularity_message(DEBUG, "Directory is '/', returning '0'\n");
         return(0);
     }
 
     if ( is_dir(dir) == 0 ) {
         singularity_message(DEBUG, "Directory exists, returning '0': %s\n", dir);
         return(0);
     }
 
     if ( is_dir(dirname(strdupa(dir))) < 0 ) {
         singularity_message(DEBUG, "Creating parent directory: %s\n", dirname(strdupa(dir)));
-        if ( s_mkpath(dirname(strdupa(dir)), mode) < 0 ) {
+        if ( s_mkpath(dirname(strdupa(dir)), mode, base) < 0 ) {
             singularity_message(VERBOSE, "Failed to create parent directory %s\n", dir);
             return(-1);
         }
     }
 
+    if ( base != NULL ) {
+        dupdir = strdup(dir);
+        if ( dupdir == NULL ) {
+            singularity_message(ERROR, "Failed to allocate memory\n");
+            ABORT(255);
+        }
+        realdir = realpath(dirname(dupdir), NULL); // Flawfinder: ignore
+        if ( realdir == NULL ) {
+            singularity_message(ERROR, "A component of the path is missing\n");
+            ABORT(255);
+        }
+        if ( strncmp(base, realdir, strlen(base)) != 0 ) {
+            free(dupdir);
+            free(realdir);
+            singularity_message(WARNING, "Skip creation of path, attempt to create directory outside of %s\n", base);
+            return(-1);
+        }
+        free(dupdir);
+        free(realdir);
+    }
+
     singularity_message(DEBUG, "Creating directory: %s\n", dir);
     mode_t mask = umask(0); // Flawfinder: ignore
     int ret = mkdir(dir, mode);
     umask(mask); // Flawfinder: ignore
 
diff --git a/src/util/file.h b/src/util/file.h
index d1629bb..6feaa85 100644
--- a/src/util/file.h
+++ b/src/util/file.h
@@ -37,11 +37,11 @@ int is_exec(char *path);
 int is_write(char *path);
 int is_suid(char *path);
 int is_owner(char *path, uid_t uid);
 int is_blk(char *path);
 int is_chr(char *path);
-int s_mkpath(char *dir, mode_t mode);
+int s_mkpath(char *dir, mode_t mode, char *base);
 int s_rmdir(char *dir);
 int copy_file(char * source, char * dest);
 char *filecat(char *path);
 int fileput(char *path, char *string);
 int filelock(const char *const filepath, int *const fdptr);
diff --git a/src/util/mount.c b/src/util/mount.c
index 7620fad..51bb90b 100644
--- a/src/util/mount.c
+++ b/src/util/mount.c
@@ -34,66 +34,82 @@
 
 int singularity_mount(const char *source, const char *target,
                       const char *filesystemtype, unsigned long mountflags,
                       const void *data) {
     int ret;
+    int mount_errno;
+
     uid_t fsuid = 0;
 
     if ( ( mountflags & MS_BIND ) ) {
         fsuid = singularity_priv_getuid();
     }
 
     /* don't modify user groups */
     if ( singularity_priv_userns_enabled() == 0 ) {
         if ( seteuid(0) < 0 ) {
             singularity_message(ERROR, "Failed to escalate privileges: %s\n", strerror(errno));
             ABORT(255);
         }
         /* NFS root_squash option set uid 0 to nobody, force use of real user ID */
         setfsuid(fsuid);
     }
     ret = mount(source, target, filesystemtype, mountflags, data);
+    mount_errno = errno;
+
     if ( singularity_priv_userns_enabled() == 0 && seteuid(singularity_priv_getuid()) < 0 ) {
         singularity_message(ERROR, "Failed to drop privileges: %s\n", strerror(errno));
         ABORT(255);
     }
 
+    errno = mount_errno;
     return ret;
 }
 
 int check_mounted(char *mountpoint) {
     int retval = -1;
     FILE *mounts;
     char *line = (char *)malloc(MAX_LINE_LEN);
     char *rootfs_dir = CONTAINER_FINALDIR;
     unsigned int mountpoint_len = strlength(mountpoint, PATH_MAX);
     char *real_mountpoint;
+    char procmounts[PATH_MAX];
 
     singularity_message(DEBUG, "Opening /proc/mounts\n");
     if ( ( mounts = fopen("/proc/mounts", "r") ) == NULL ) { // Flawfinder: ignore
         singularity_message(ERROR, "Could not open /proc/mounts: %s\n", strerror(errno));
         ABORT(255);
     }
 
     if ( mountpoint[mountpoint_len-1] == '/' ) {
         singularity_message(DEBUG, "Removing trailing slash from string: %s\n", mountpoint);
         mountpoint[mountpoint_len-1] = '\0';
     }
 
-    real_mountpoint = realpath(mountpoint, NULL); // Flawfinder: ignore
+    real_mountpoint = realpath(joinpath(rootfs_dir, mountpoint), NULL); // Flawfinder: ignore
     if ( real_mountpoint == NULL ) {
-        // mountpoint doesn't exists
+        // mountpoint doesn't exist
         return(retval);
     }
 
+    if ( snprintf(procmounts, PATH_MAX-1, "%s/proc/%d/mounts", rootfs_dir, getpid()) < 0 ) {
+        singularity_message(ERROR, "Can't construct path %s/proc/%d/mounts\n", rootfs_dir, getpid());
+        ABORT(255);
+    }
+
+    if ( strcmp(real_mountpoint, procmounts) == 0 ) {
+        singularity_message(ERROR, "Attempt to override /proc/mounts, aborting\n");
+        ABORT(255);
+    }
+
     singularity_message(DEBUG, "Iterating through /proc/mounts\n");
     while ( fgets(line, MAX_LINE_LEN, mounts) != NULL ) {
         (void) strtok(strdup(line), " ");
         char *mount = strtok(NULL, " ");
 
         // Check to see if mountpoint is already mounted
-        if ( strcmp(joinpath(rootfs_dir, real_mountpoint), mount) == 0 ) {
+        if ( strcmp(real_mountpoint, mount) == 0 ) {
             singularity_message(DEBUG, "Mountpoint is already mounted: %s\n", mountpoint);
             retval = 1;
             break;
         }
 
-- 
2.14.3

From 0c9d66887a81db0e7f976a7c76b80c205fe6db87 Mon Sep 17 00:00:00 2001
From: Cedric Clerget <cedric.clerget@gmail.com>
Date: Wed, 28 Mar 2018 16:33:06 +0200
Subject: [PATCH 2/3] Fix nested binds level

---
 src/lib/runtime/mounts/binds/binds.c         | 35 +++++++++++++++++++++-------
 src/lib/runtime/mounts/userbinds/userbinds.c | 35 ++++++++++++++++++++--------
 2 files changed, 51 insertions(+), 19 deletions(-)

diff --git a/src/lib/runtime/mounts/binds/binds.c b/src/lib/runtime/mounts/binds/binds.c
index eed4f04..a74a27d 100644
--- a/src/lib/runtime/mounts/binds/binds.c
+++ b/src/lib/runtime/mounts/binds/binds.c
@@ -58,40 +58,57 @@ int _singularity_runtime_mount_binds(void) {
         return(0);
     }
     while ( *tmp_config_string_list != NULL ) {
         tmp_config_string = strdup(*tmp_config_string_list);
         tmp_config_string_list++;
+        unsigned char nested = 0;
+        char *ptr;
+        char *dupdest;
         char *source = strtok(tmp_config_string, ":");
         char *dest = strtok(NULL, ":");
         chomp(source);
         if ( dest == NULL ) {
             dest = strdup(source);
         } else {
             chomp(dest);
         }
 
         singularity_message(VERBOSE2, "Found 'bind path' = %s, %s\n", source, dest);
 
         if ( ( is_file(source) < 0 ) && ( is_dir(source) < 0 ) ) {
             singularity_message(WARNING, "Non existent 'bind path' source: '%s'\n", source);
             continue;
         }
 
         singularity_message(DEBUG, "Checking if bind point is already mounted: %s\n", dest);
-        if ( check_mounted(dest) >= 0 ) {
-            singularity_message(VERBOSE, "Not mounting bind point (already mounted): %s\n", dest);
+        dupdest = strdup(dest);
+        if ( strcmp(dest, "/") == 0 ) {
+            singularity_message(WARNING, "Attempt to bind %s to container root filesystem, bind point ignored\n", source);
             continue;
         }
 
-        if ( ( is_file(source) == 0 ) && ( is_file(joinpath(container_dir, dest)) < 0 ) ) {
+        if ( dupdest == NULL ) {
+            singularity_message(ERROR, "Failed to allocate memory\n");
+            ABORT(255);
+        }
+        for ( ptr = dupdest + 1; *ptr; ptr++ ) {
+            if ( *ptr == '/' ) {
+                *ptr = '\0';
+                if ( check_mounted(dupdest) >= 0 ) {
+                    singularity_message(WARNING, "Nested bind detected for %s, skip file/directory creation\n", dupdest);
+                    nested = 1;
+                    break;
+                }
+                *ptr = '/';
+            }
+        }
+        free(dupdest);
+
+
+        if ( nested == 0 && ( is_file(source) == 0 ) && ( is_file(joinpath(container_dir, dest)) < 0 ) ) {
             if ( singularity_registry_get("OVERLAYFS_ENABLED") != NULL ) {
                 char *basedir = dirname(joinpath(container_dir, dest));
-                char *dir = dirname(strdup(dest));
-                if ( strcmp(dir, "/") != 0 && check_mounted(dir) >= 0 ) {
-                    singularity_message(WARNING, "Nested bind detected, skip file creation\n");
-                    continue;
-                }
 
                 singularity_message(DEBUG, "Checking base directory for file %s ('%s')\n", dest, basedir);
                 if ( is_dir(basedir) != 0 ) {
                     singularity_message(DEBUG, "Creating base directory for file bind\n");
                     singularity_priv_escalate();
@@ -119,11 +136,11 @@ int _singularity_runtime_mount_binds(void) {
                 singularity_message(DEBUG, "Created bind file: %s\n", dest);
             } else {
                 singularity_message(WARNING, "Non existent bind point (file) in container: '%s'\n", dest);
                 continue;
             }
-        } else if ( ( is_dir(source) == 0 ) && ( is_dir(joinpath(container_dir, dest)) < 0 ) ) {
+        } else if ( nested == 0 && ( is_dir(source) == 0 ) && ( is_dir(joinpath(container_dir, dest)) < 0 ) ) {
             if ( singularity_registry_get("OVERLAYFS_ENABLED") != NULL ) {
                 singularity_priv_escalate();
                 singularity_message(VERBOSE3, "Creating bind directory on overlay file system: %s\n", dest);
                 if ( s_mkpath(joinpath(container_dir, dest), 0755, container_dir) < 0 ) {
                     singularity_priv_drop();
diff --git a/src/lib/runtime/mounts/userbinds/userbinds.c b/src/lib/runtime/mounts/userbinds/userbinds.c
index c6785c6..3f4d8e8 100644
--- a/src/lib/runtime/mounts/userbinds/userbinds.c
+++ b/src/lib/runtime/mounts/userbinds/userbinds.c
@@ -68,10 +68,13 @@ int _singularity_runtime_mount_userbinds(void) {
 
         free(bind_path_string);
 
         while ( current != NULL ) {
             int read_only = 0;
+            unsigned char nested = 0;
+            char *dir, *ptr;
+            char *dupdest;
             char *source = strtok_r(current, ":", &inside_token);
             char *dest = strtok_r(NULL, ":", &inside_token);
             char *opts = strtok_r(NULL, ":", &inside_token);
 
             current = strtok_r(NULL, ",", &outside_token);
@@ -92,23 +95,35 @@ int _singularity_runtime_mount_userbinds(void) {
                     continue;
                 }
             }
 
             singularity_message(DEBUG, "Checking if bind point is already mounted: %s\n", dest);
-            if ( check_mounted(dest) >= 0 ) {
-                singularity_message(WARNING, "Not mounting requested bind point (already mounted in container): %s\n", dest);
+            dupdest = strdup(dest);
+            if ( dupdest == NULL ) {
+                singularity_message(ERROR, "Failed to allocate memory\n");
+                ABORT(255);
+            }
+            if ( strcmp(dest, "/") == 0 ) {
+                singularity_message(WARNING, "Attempt to bind %s to container root filesystem, bind point ignored\n", source);
                 continue;
             }
-
-            if ( ( is_file(source) == 0 ) && ( is_file(joinpath(container_dir, dest)) < 0 ) ) {
-                if ( singularity_registry_get("OVERLAYFS_ENABLED") != NULL ) {
-                    char *dir = dirname(strdup(dest));
-                    if ( strcmp(dir, "/") != 0 && check_mounted(dir) >= 0 ) {
-                        singularity_message(WARNING, "Nested bind detected, skip file creation\n");
-                        continue;
+            for ( ptr = dupdest + 1; *ptr; ptr++ ) {
+                if ( *ptr == '/' ) {
+                    *ptr = '\0';
+                    if ( check_mounted(dupdest) >= 0 ) {
+                        singularity_message(WARNING, "Nested bind detected for %s, skip file/directory creation\n", dupdest);
+                        nested = 1;
+                        break;
                     }
+                    *ptr = '/';
+                }
+            }
+            free(dupdest);
 
+            if ( nested == 0 && ( is_file(source) == 0 ) && ( is_file(joinpath(container_dir, dest)) < 0 ) ) {
+                if ( singularity_registry_get("OVERLAYFS_ENABLED") != NULL ) {
+                    dir = dirname(strdup(dest));
                     if ( is_dir(joinpath(container_dir, dir)) < 0 ) {
                         singularity_message(VERBOSE3, "Creating bind directory on overlay file system: %s\n", dest);
                         if ( s_mkpath(joinpath(container_dir, dir), 0755, container_dir) < 0 ) {
                             singularity_priv_escalate();
                             singularity_message(VERBOSE3, "Retrying with privileges to create bind directory on overlay file system: %s\n", dest);
@@ -134,11 +149,11 @@ int _singularity_runtime_mount_userbinds(void) {
                     singularity_message(DEBUG, "Created bind file: %s\n", dest);
                 } else {
                     singularity_message(WARNING, "Skipping user bind, non existent bind point (file) in container: '%s'\n", dest);
                     continue;
                 }
-            } else if ( ( is_dir(source) == 0 ) && ( is_dir(joinpath(container_dir, dest)) < 0 ) ) {
+            } else if ( nested == 0 && ( is_dir(source) == 0 ) && ( is_dir(joinpath(container_dir, dest)) < 0 ) ) {
                 if ( singularity_registry_get("OVERLAYFS_ENABLED") != NULL ) {
                     singularity_message(VERBOSE3, "Creating bind directory on overlay file system: %s\n", dest);
                     if ( s_mkpath(joinpath(container_dir, dest), 0755, container_dir) < 0 ) {
                         singularity_priv_escalate();
                         singularity_message(VERBOSE3, "Retrying with privileges to create bind directory on overlay file system: %s\n", dest);
-- 
2.14.3

From 630354db6a3e487a3a2ceb429fadede0f7bfebe7 Mon Sep 17 00:00:00 2001
From: Cedric Clerget <cedric.clerget@gmail.com>
Date: Thu, 29 Mar 2018 01:34:18 +0200
Subject: [PATCH 3/3] Fix regression for OVERLAYFS_ENABLED registry key. Modify
 order of mount stages. Add checks in singularity_mount to verify that target
 mount point is in an allowed path.

---
 src/lib/runtime/mounts/mounts.c       |  4 ++--
 src/lib/runtime/overlayfs/overlayfs.c |  1 +
 src/util/mount.c                      | 40 +++++++++++++++++++++++++++++++++--
 3 files changed, 41 insertions(+), 4 deletions(-)

diff --git a/src/lib/runtime/mounts/mounts.c b/src/lib/runtime/mounts/mounts.c
index fe2fa32..a19cf41 100644
--- a/src/lib/runtime/mounts/mounts.c
+++ b/src/lib/runtime/mounts/mounts.c
@@ -52,13 +52,13 @@ int _singularity_runtime_mounts(void) {
     retval += _singularity_runtime_mount_hostfs();
     retval += _singularity_runtime_mount_binds();
     retval += _singularity_runtime_mount_kernelfs();
     retval += _singularity_runtime_mount_dev();
     retval += _singularity_runtime_mount_home();
-    retval += _singularity_runtime_mount_userbinds();
-    retval += _singularity_runtime_mount_tmp();
     retval += _singularity_runtime_mount_scratch();
+    retval += _singularity_runtime_mount_tmp();
     retval += _singularity_runtime_mount_cwd();
+    retval += _singularity_runtime_mount_userbinds();
 
     return(retval);
 }
 
diff --git a/src/lib/runtime/overlayfs/overlayfs.c b/src/lib/runtime/overlayfs/overlayfs.c
index 62995a0..eb90499 100644
--- a/src/lib/runtime/overlayfs/overlayfs.c
+++ b/src/lib/runtime/overlayfs/overlayfs.c
@@ -46,10 +46,11 @@
 
 #include "../runtime.h"
 
 
 int _singularity_runtime_overlayfs(void) {
+    singularity_registry_set("OVERLAYFS_ENABLED", NULL);
 
     singularity_priv_escalate();
     singularity_message(DEBUG, "Creating overlay_final directory: %s\n", CONTAINER_FINALDIR);
     if ( s_mkpath(CONTAINER_FINALDIR, 0755, NULL) < 0 ) {
         singularity_message(ERROR, "Failed creating overlay_final directory %s: %s\n", CONTAINER_FINALDIR, strerror(errno));
diff --git a/src/util/mount.c b/src/util/mount.c
index 51bb90b..d2f6b0b 100644
--- a/src/util/mount.c
+++ b/src/util/mount.c
@@ -11,53 +11,89 @@
  * of Singularity, including this file, may be copied, modified, propagated, or distributed
  * except according to the terms contained in the LICENSE.md file.
  * 
 */
 
+#define _GNU_SOURCE
 #include <errno.h>
 #include <fcntl.h>
 #include <stdio.h>
 #include <string.h>
 #include <sys/stat.h>
 #include <sys/mount.h>
 #include <sys/fsuid.h>
 #include <unistd.h>
 #include <stdlib.h>
 #include <limits.h>
+#include <libgen.h>
 
 #include "config.h"
 #include "util/file.h"
 #include "util/util.h"
 #include "util/message.h"
 #include "util/privilege.h"
 
 #define MAX_LINE_LEN 2048
 
 int singularity_mount(const char *source, const char *target,
                       const char *filesystemtype, unsigned long mountflags,
                       const void *data) {
     int ret;
     int mount_errno;
-
     uid_t fsuid = 0;
+    char dest[PATH_MAX];
+    char *realdest;
+    int target_fd = open(target, O_RDONLY);
+
+    if ( target_fd < 0 ) {
+        singularity_message(ERROR, "Target %s doesn't exist\n", target);
+        ABORT(255);
+    }
+
+    if ( snprintf(dest, PATH_MAX-1, "/proc/self/fd/%d", target_fd) < 0 ) {
+        singularity_message(ERROR, "Failed to determine path for target file descriptor\n");
+        ABORT(255);
+    }
 
     if ( ( mountflags & MS_BIND ) ) {
         fsuid = singularity_priv_getuid();
     }
 
+    realdest = realpath(dest, NULL); // Flawfinder: ignore
+    if ( realdest == NULL ) {
+        singularity_message(ERROR, "Failed to get real path of %s %s\n", target, dest);
+        ABORT(255);
+    }
+
+    if ( (mountflags & MS_PRIVATE) == 0 && (mountflags & MS_SLAVE) == 0 ) {
+        if ( strncmp(realdest, CONTAINER_MOUNTDIR, strlen(CONTAINER_MOUNTDIR)) != 0 &&
+             strncmp(realdest, CONTAINER_FINALDIR, strlen(CONTAINER_FINALDIR)) != 0 &&
+             strncmp(realdest, CONTAINER_OVERLAY, strlen(CONTAINER_OVERLAY)) != 0 &&
+             strncmp(realdest, SESSIONDIR, strlen(SESSIONDIR)) != 0 ) {
+            singularity_message(VERBOSE, "Ignored, try to mount %s outside of container %s\n", target, realdest);
+            free(realdest);
+            close(target_fd);
+            return(0);
+        }
+    }
+
     /* don't modify user groups */
     if ( singularity_priv_userns_enabled() == 0 ) {
         if ( seteuid(0) < 0 ) {
             singularity_message(ERROR, "Failed to escalate privileges: %s\n", strerror(errno));
             ABORT(255);
         }
         /* NFS root_squash option set uid 0 to nobody, force use of real user ID */
         setfsuid(fsuid);
     }
-    ret = mount(source, target, filesystemtype, mountflags, data);
+
+    ret = mount(source, dest, filesystemtype, mountflags, data);
     mount_errno = errno;
 
+    close(target_fd);
+    free(realdest);
+
     if ( singularity_priv_userns_enabled() == 0 && seteuid(singularity_priv_getuid()) < 0 ) {
         singularity_message(ERROR, "Failed to drop privileges: %s\n", strerror(errno));
         ABORT(255);
     }
 
-- 
2.14.3

