From c199dd5a436cc2abe7906a8508a8974c783be6b3 Mon Sep 17 00:00:00 2001
From: Matyas Selmeci <matyas@cs.wisc.edu>
Date: Wed, 14 Feb 2018 14:38:23 -0600
Subject: [PATCH 104/105] voms-proxy-direct: drop -selfsigned

---
 doc/voms-proxy-direct.xml |   4 --
 src/utils/vomsdirect.cc   | 143 +++++++++++++++++++---------------------------
 2 files changed, 58 insertions(+), 89 deletions(-)

diff --git a/doc/voms-proxy-direct.xml b/doc/voms-proxy-direct.xml
index f05a5f6..96beb21 100644
--- a/doc/voms-proxy-direct.xml
+++ b/doc/voms-proxy-direct.xml
@@ -160,14 +160,10 @@ as a compatibility feature to ease migration while the servers upgrade to the ne
   dataEncipherment, keyAgreement, keyCertSign, cRLSign, encipherOnly,
   decipherOnly.  The default value is to copy this extensions from the
   issuer certificate while removing the keyCertSign and nonRepudiation
   bits if present.</para>
 
-<para><option>-selfsigned</option></para>
-<para>The created certificate will be a self-signed certificate and
-  have a CA=true bit in the Basic constraints Exception.</para>
-
 <para><option>-extension</option> <replaceable>oid[/criticality]value</replaceable></para>
 <para>This option allows to specified additional extensions to be put
   in the created certificate.</para>
 <para><emphasis remap='I'>oid</emphasis> is the Object Identifier of
   the extensions.  Any OID may be used even if it is not already known
diff --git a/src/utils/vomsdirect.cc b/src/utils/vomsdirect.cc
index 1575c9f..ef3d79f 100644
--- a/src/utils/vomsdirect.cc
+++ b/src/utils/vomsdirect.cc
@@ -186,11 +186,11 @@ Fake::Fake(int argc, char ** argv) :   confile(conf_file_name),
                                        aclist(NULL), voID(""),
                                        hostcert(""), hostkey(""),
                                        newformat(false),
                                        rfc(false),
                                        keyusage(""), netscape(""), exkusage(""),
-                                       newserial(""), selfsigned(false)
+                                       newserial("")
 {
 
   bool progversion = false;
   std::string crtdir;
   std::string crtfile;
@@ -257,11 +257,10 @@ Fake::Fake(int argc, char ** argv) :   confile(conf_file_name),
     "    -newserial <num>               Specifies the serial number of the generated proxy\n"\
     "                                   in hex notation.  Any length is possible.\n"\
     "                                   Default: let voms-proxy-direct choose.\n"\
     "    -extension <OID</crit><value>> Add Extension with the specified OID and with the specified value\n"\
     "    -acextension <OID</crit><value>> Add Extension to the AC with the specified OID and with the specified value\n"\
-    "    -selfsigned                    Create a self-signed certificate.\n"\
     "    -ga <id>=<value> [(context)]   Set a GA with name 'id', value 'value' and optional context.\n"\
     "\n";
 
   set_usage(LONG_USAGE);
 
@@ -308,11 +307,10 @@ Fake::Fake(int argc, char ** argv) :   confile(conf_file_name),
     {"nscert",          1, (int *)&netscape,    OPT_STRING},
     {"extkeyusage",     1, (int *)&exkusage,    OPT_STRING},
     {"newserial",       1, (int *)&newserial,   OPT_STRING},
     {"extension",       1, (int *)&extensions,  OPT_MULTI},
     {"acextension",     1, (int *)&acextensions,OPT_MULTI},
-    {"selfsigned",      0, (int *)&selfsigned,  OPT_BOOL},
     {"ga",              1, (int *)&galist,      OPT_MULTI},
 #ifdef CLASS_ADD
     {"classadd",        1, (int *)class_add_buf,OPT_STRING},
 #endif
     {0, 0, 0, 0}
@@ -612,11 +610,11 @@ bool Fake::CreateProxy(std::string data, AC ** aclist, int version)
       args->exkusage      = strdup(exkusage.c_str());
 
     if (!newserial.empty())
       args->newserial = strdup(newserial.c_str());
 
-    args->selfsigned = (selfsigned ? 1 : 0);
+    args->selfsigned = 0;
 
     /* Read through extensions */
     std::vector<std::string>::const_iterator end = extensions.end();
     for (std::vector<std::string>::const_iterator i = extensions.begin();
          i != end; ++i) {
@@ -691,37 +689,35 @@ bool Fake::WriteSeparate()
   return true;
 }
 
 void Fake::Test()
 {
-  if (!selfsigned) {
-    ASN1_UTCTIME * asn1_time = ASN1_UTCTIME_new();
-    X509_gmtime_adj(asn1_time, 0);
-    time_t time_now = ASN1_UTCTIME_mktime(asn1_time);
-    ASN1_UTCTIME_free(asn1_time);
-    time_t time_after = ASN1_UTCTIME_mktime(X509_get_notAfter(ucert));
-    time_t time_diff = time_after - time_now ;
+  ASN1_UTCTIME * asn1_time = ASN1_UTCTIME_new();
+  X509_gmtime_adj(asn1_time, 0);
+  time_t time_now = ASN1_UTCTIME_mktime(asn1_time);
+  ASN1_UTCTIME_free(asn1_time);
+  time_t time_after = ASN1_UTCTIME_mktime(X509_get_notAfter(ucert));
+  time_t time_diff = time_after - time_now ;
 
-    if (time_diff < 0)
-      Print(INFO) << std::endl << "Error: your certificate expired "
-                  << asctime(localtime(&time_after)) << std::endl << std::flush;
-    else if (hours && time_diff < hours*60*60)
-      Print(INFO) << "Warning: your certificate and proxy will expire "
-                  << asctime(localtime(&time_after))
-                  << "which is within the requested lifetime of the proxy"
-                  << std::endl << std::flush;
+  if (time_diff < 0)
+    Print(INFO) << std::endl << "Error: your certificate expired "
+                << asctime(localtime(&time_after)) << std::endl << std::flush;
+  else if (hours && time_diff < hours*60*60)
+    Print(INFO) << "Warning: your certificate and proxy will expire "
+                << asctime(localtime(&time_after))
+                << "which is within the requested lifetime of the proxy"
+                << std::endl << std::flush;
 
-    time_t time_after_proxy;
+  time_t time_after_proxy;
 
-    if (hours)
-      time_after_proxy = time_now + hours*60*60;
-    else
-      time_after_proxy = time_after;
+  if (hours)
+    time_after_proxy = time_now + hours*60*60;
+  else
+    time_after_proxy = time_after;
 
-    Print(INFO) << "Your proxy is valid until "
-                << asctime(localtime(&time_after_proxy)) << std::endl << std::flush;
-  }
+  Print(INFO) << "Your proxy is valid until "
+              << asctime(localtime(&time_after_proxy)) << std::endl << std::flush;
 }
 
 bool Fake::MakeACs(VOLIST *volist)
 {
   AC **actmplist = NULL;
@@ -858,15 +854,12 @@ bool Fake::pcdInit() {
                << " User certificate file: " << (this->certfile ? this->certfile : "none") << std::endl
                << " User key file: " << (this->keyfile ? this->keyfile : "none") << std::endl << std::flush;
 
   Print(DEBUG) << "Output to " << outfile << std::endl << std::flush;
 
-  /* No need to load certificates if we are creating a self-signed cert. */
-  if (!selfsigned) {
-    if (!load_credentials(certfile, keyfile, &ucert, &cert_chain, &upkey, pw_cb))
-      goto err;
-  }
+  if (!load_credentials(certfile, keyfile, &ucert, &cert_chain, &upkey, pw_cb))
+    goto err;
 
   status = true;
 
  err:
 
@@ -918,73 +911,53 @@ bool Fake::VerifyOptions()
     Print(DEBUG) << "Unable to discover Globus version: trying for 2.2" << std::endl;
   }
   else
     Print(DEBUG) << "Detected Globus version: " << version << std::endl;
 
-  if (!selfsigned) {
-    /* proxyversion is only significant if this is not a selfsigned certificate */
-    if (rfc && proxyver != 0)
-      exitError("Used both -rfc and --proxyver!\nChoose one or the other.");
+  if (rfc && proxyver != 0)
+    exitError("Used both -rfc and --proxyver!\nChoose one or the other.");
 
-    if (rfc)
+  if (rfc)
+    proxyver = 4;
+
+  /* set proxy version */
+
+  if (proxyver!=2 && proxyver!=3 && proxyver!=4 && proxyver!=0)
+    exitError("Error: proxyver must be 2 or 3 or 4");
+  else if (proxyver==0) {
+    Print(DEBUG) << "Unspecified proxy version, settling on version: ";
+
+    if (version<30)
+      proxyver = 2;
+    else if (version<40)
+      proxyver = 3;
+    else
       proxyver = 4;
 
-    /* set proxy version */
+    Print(DEBUG) << proxyver << std::endl;
+  }
 
-    if (proxyver!=2 && proxyver!=3 && proxyver!=4 && proxyver!=0)
-      exitError("Error: proxyver must be 2 or 3 or 4");
-    else if (proxyver==0) {
-      Print(DEBUG) << "Unspecified proxy version, settling on version: ";
-
-      if (version<30)
-        proxyver = 2;
-      else if (version<40)
-        proxyver = 3;
-      else
-        proxyver = 4;
-
-      Print(DEBUG) << proxyver << std::endl;
-    }
-
-    /* PCI extension option */
-
-    if (proxyver>3) {
-      if (!policylang.empty())
-        if (policyfile.empty())
-          exitError("Error: if you specify a policy language you also need to specify a policy file");
-    }
-
-    if (proxyver>3) {
-      Print(DEBUG) << "PCI extension info: " << std::endl << " Path length: " << pathlength << std::endl;
-
-      if (policylang.empty())
-        Print(DEBUG) << " Policy language not specified." << std::endl;
-      else
-        Print(DEBUG) << " Policy language: " << policylang << std::endl;
+  /* PCI extension option */
 
+  if (proxyver>3) {
+    if (!policylang.empty())
       if (policyfile.empty())
-        Print(DEBUG) << " Policy file not specified." << std::endl;
-      else
-        Print(DEBUG) << " Policy file: " << policyfile << std::endl;
-    }
+        exitError("Error: if you specify a policy language you also need to specify a policy file");
   }
-  else {
-    /* selfsigned is specified */
-    if (proxyver != 0 || noregen || rfc || !policyfile.empty() || !policylang.empty())
-      exitError("Error: --proxyver, --rfc, --policyfile, --policylang, --noregen are only significant when --selfsigned is not specified.");
 
-    if (newsubject.empty() && newissuer.empty())
-      exitError("Error: At least one of --newsubject and --newissuer must be specified for --selfsigned.");
+  if (proxyver>3) {
+    Print(DEBUG) << "PCI extension info: " << std::endl << " Path length: " << pathlength << std::endl;
 
-    if (newsubject.empty())
-      newsubject = newissuer;
+    if (policylang.empty())
+      Print(DEBUG) << " Policy language not specified." << std::endl;
+    else
+      Print(DEBUG) << " Policy language: " << policylang << std::endl;
 
-    if (newissuer.empty())
-      newissuer = newsubject;
-
-    if (newissuer != newsubject)
-      exitError("Error: --newsubject and --newissuer should be the same for self-signed certificates.");
+    if (policyfile.empty())
+      Print(DEBUG) << " Policy file not specified." << std::endl;
+    else
+      Print(DEBUG) << " Policy file: " << policyfile << std::endl;
   }
 
   /* controls that number of bits for the key is appropiate */
 
   if (bits == -1)
-- 
2.6.3

