diff --git a/src/condor_job_router/CMakeLists.txt b/src/condor_job_router/CMakeLists.txt
index 49a2415..382d0b0 100644
--- a/src/condor_job_router/CMakeLists.txt
+++ b/src/condor_job_router/CMakeLists.txt
@@ -19,10 +19,12 @@
 
 if (NOT WIN_EXEC_NODE_ONLY)
 
-	condor_glob(JRHdrs JRSrcs "VanillaToGrid_main.cpp")
+	condor_glob(JRHdrs JRSrcs "VanillaToGrid_main.cpp;job_router_tool.cpp")
 
 	condor_exe( condor_job_router "${JRHdrs};${JRSrcs}" ${C_LIBEXEC} "${CONDOR_LIBS}" OFF )
 
+	condor_exe( condor_job_router_tool "job_router_tool.cpp;JobRouter.cpp;VanillaToGrid.cpp" ${C_BIN} "${CONDOR_TOOL_LIBS}" OFF)
+
 	if (WINDOWS)
 
 			# windows install requires scripts have the correct extension in order 
	Modified   src/condor_job_router/JobRouter.cpp
diff --git a/src/condor_job_router/JobRouter.cpp b/src/condor_job_router/JobRouter.cpp
index d276a38..7024a0c 100644
--- a/src/condor_job_router/JobRouter.cpp
+++ b/src/condor_job_router/JobRouter.cpp
@@ -61,7 +61,10 @@ const char JR_ATTR_EDIT_JOB_IN_PLACE[] = "EditJobInPlace";
 
 const int THROTTLE_UPDATE_INTERVAL = 600;
 
-JobRouter::JobRouter(): m_jobs(5000,hashFuncStdString,rejectDuplicateKeys) {
+JobRouter::JobRouter(bool as_tool)
+	: m_jobs(5000,hashFuncStdString,rejectDuplicateKeys)
+	, m_operate_as_tool(as_tool)
+{
 	m_scheduler = NULL;
 	m_scheduler2 = NULL;
 	m_release_on_hold = true;
@@ -119,7 +122,7 @@ JobRouter::~JobRouter() {
 		delete m_hook_mgr;
 	}
 #endif
-	InvalidatePublicAd();
+	if ( ! m_operate_as_tool) { InvalidatePublicAd(); }
 
 	m_scheduler->stop();
 	delete m_scheduler;
@@ -138,7 +141,7 @@ JobRouter::init() {
 	m_hook_mgr->initialize();
 #endif
 	config();
-	GetInstanceLock();
+	if ( ! m_operate_as_tool) { GetInstanceLock(); }
 }
 
 void
@@ -177,8 +180,7 @@ JobRouter::config() {
 	m_enable_job_routing = true;
 
 	if( !m_scheduler ) {
-		NewClassAdJobLogConsumer *log_consumer = new NewClassAdJobLogConsumer();
-		m_scheduler = new Scheduler(log_consumer,"JOB_ROUTER_SCHEDD1_SPOOL");
+		m_scheduler = new Scheduler("JOB_ROUTER_SCHEDD1_SPOOL");
 		m_scheduler->init();
 	}
 
@@ -187,8 +189,7 @@ JobRouter::config() {
 		if( !m_scheduler2 ) {
 				// schedd2_spool is configured, but we have no schedd2, so create it
 			dprintf(D_ALWAYS,"Reading destination schedd spool %s\n",spool2.c_str());
-			NewClassAdJobLogConsumer *log_consumer2 = new NewClassAdJobLogConsumer();
-			m_scheduler2 = new Scheduler(log_consumer2,"JOB_ROUTER_SCHEDD2_SPOOL");
+			m_scheduler2 = new Scheduler("JOB_ROUTER_SCHEDD2_SPOOL");
 			m_scheduler2->init();
 		}
 	}
@@ -354,29 +355,31 @@ JobRouter::config() {
 	m_job_router_polling_period = param_integer("JOB_ROUTER_POLLING_PERIOD",10);
 
 		// clear previous timers
-	if (m_job_router_polling_timer >= 0) {
-		daemonCore->Cancel_Timer(m_job_router_polling_timer);
-	}
-	if (m_periodic_timer_id >= 0) {
-		daemonCore->Cancel_Timer(m_periodic_timer_id);
-	}
-		// register timer handlers
-	m_job_router_polling_timer = daemonCore->Register_Timer(
-								  0, 
-								  m_job_router_polling_period,
-								  (TimerHandlercpp)&JobRouter::Poll, 
-								  "JobRouter::Poll", this);
-
-	if (periodic_interval.getMinInterval() > 0) {
-		m_periodic_timer_id = daemonCore->Register_Timer(periodic_interval, 
-								(TimerHandlercpp)&JobRouter::EvalAllSrcJobPeriodicExprs,
-								"JobRouter::EvalAllSrcJobPeriodicExprs",
-								this);
-		dprintf(D_FULLDEBUG, "JobRouter: Registered EvalAllSrcJobPeriodicExprs() to evaluate periodic expressions.\n");
-	}
-	else {
-		dprintf(D_FULLDEBUG, "JobRouter: Evaluation of periodic expressions disabled.\n");
-	}
+	if ( ! m_operate_as_tool) {
+		if (m_job_router_polling_timer >= 0) {
+			daemonCore->Cancel_Timer(m_job_router_polling_timer);
+		}
+		if (m_periodic_timer_id >= 0) {
+			daemonCore->Cancel_Timer(m_periodic_timer_id);
+		}
+			// register timer handlers
+		m_job_router_polling_timer = daemonCore->Register_Timer(
+										0,
+										m_job_router_polling_period,
+										(TimerHandlercpp)&JobRouter::Poll,
+										"JobRouter::Poll", this);
+
+		if (periodic_interval.getMinInterval() > 0) {
+			m_periodic_timer_id = daemonCore->Register_Timer(periodic_interval, 
+									(TimerHandlercpp)&JobRouter::EvalAllSrcJobPeriodicExprs,
+									"JobRouter::EvalAllSrcJobPeriodicExprs",
+									this);
+			dprintf(D_FULLDEBUG, "JobRouter: Registered EvalAllSrcJobPeriodicExprs() to evaluate periodic expressions.\n");
+		}
+		else {
+			dprintf(D_FULLDEBUG, "JobRouter: Evaluation of periodic expressions disabled.\n");
+		}
+	} // ! m_operate_as_tool
 
 		// NOTE: if you change the default name, then you are breaking
 		// JobRouter's ability to adopt jobs ("orphans") left behind
@@ -390,25 +393,27 @@ JobRouter::config() {
 		EXCEPT("JOB_ROUTER_NAME must not be empty");
 	}
 
-	InitPublicAd();
+	if ( ! m_operate_as_tool) {
+		InitPublicAd();
 
-	int update_interval = param_integer("UPDATE_INTERVAL", 60);
-	if(m_public_ad_update_interval != update_interval) {
-		m_public_ad_update_interval = update_interval;
+		int update_interval = param_integer("UPDATE_INTERVAL", 60);
+		if(m_public_ad_update_interval != update_interval) {
+			m_public_ad_update_interval = update_interval;
 
-		if(m_public_ad_update_timer >= 0) {
-			daemonCore->Cancel_Timer(m_public_ad_update_timer);
-			m_public_ad_update_timer = -1;
+			if(m_public_ad_update_timer >= 0) {
+				daemonCore->Cancel_Timer(m_public_ad_update_timer);
+				m_public_ad_update_timer = -1;
+			}
+			dprintf(D_FULLDEBUG, "Setting update interval to %d\n",
+				m_public_ad_update_interval);
+			m_public_ad_update_timer = daemonCore->Register_Timer(
+				0,
+				m_public_ad_update_interval,
+				(TimerHandlercpp)&JobRouter::TimerHandler_UpdateCollector,
+				"JobRouter::TimerHandler_UpdateCollector",
+				this);
 		}
-		dprintf(D_FULLDEBUG, "Setting update interval to %d\n",
-			m_public_ad_update_interval);
-		m_public_ad_update_timer = daemonCore->Register_Timer(
-			0,
-			m_public_ad_update_interval,
-			(TimerHandlercpp)&JobRouter::TimerHandler_UpdateCollector,
-			"JobRouter::TimerHandler_UpdateCollector",
-			this);
-	}
+	} // ! m_operate_as_tool
 
 	param(m_schedd2_name_buf,"JOB_ROUTER_SCHEDD2_NAME");
 	param(m_schedd2_pool_buf,"JOB_ROUTER_SCHEDD2_POOL");
@@ -429,6 +434,54 @@ JobRouter::config() {
 	}
 }
 
+void JobRouter::dump_routes(FILE* hf) // dump the routing information to the given file.
+{
+	int ixRoute = 1;
+	JobRoute *route;
+	m_routes->startIterations();
+	while(m_routes->iterate(route)) {
+		/*
+		classad::ClassAd *RouteAd() {return &m_route_ad;}
+		char const *Name() {return m_name.c_str();}
+		int MaxJobs() {return m_max_jobs;}
+		int MaxIdleJobs() {return m_max_idle_jobs;}
+		int CurrentRoutedJobs() {return m_num_jobs;}
+		int TargetUniverse() {return m_target_universe;}
+		char const *GridResource() {return m_grid_resource.c_str();}
+		classad::ExprTree *RouteRequirementExpr() {return m_route_requirements;}
+		char const *RouteRequirementsString() {return m_route_requirements_str.c_str();}
+		std::string RouteString(); // returns a string describing the route
+		*/
+		fprintf(hf, "Route %d\n", ixRoute);
+		fprintf(hf, "Name         : \"%s\"\n", route->Name());
+		fprintf(hf, "Universe     : %d\n", route->TargetUniverse());
+		//fprintf(hf, "RoutedJobs   : %d\n", route->CurrentRoutedJobs());
+		fprintf(hf, "MaxJobs      : %d\n", route->MaxJobs());
+		fprintf(hf, "MaxIdleJobs  : %d\n", route->MaxIdleJobs());
+		fprintf(hf, "GridResource : %s\n", route->GridResource());
+		fprintf(hf, "Requirements : %s\n", route->RouteRequirementsString());
+
+		fprintf(hf, "ClassAd      : ");
+		std::string route_ad_string;
+		if (route->RouteStringPretty(route_ad_string)) {
+			fprintf(hf, "%s", route_ad_string.c_str());
+		}
+		fprintf(hf, "\n");
+
+		fprintf(hf, "\n");
+		++ixRoute;
+	}
+}
+
+
+void
+JobRouter::set_schedds(Scheduler* schedd, Scheduler* schedd2)
+{
+	ASSERT(m_operate_as_tool);
+	m_scheduler = schedd;
+	m_scheduler2 = schedd2;
+}
+
 classad::ClassAdCollection *
 JobRouter::GetSchedd1ClassAds() {
 	return m_scheduler->GetClassAds();
@@ -441,6 +494,7 @@ JobRouter::GetSchedd2ClassAds() {
 void
 JobRouter::InitPublicAd()
 {
+	ASSERT( ! m_operate_as_tool);
 	ASSERT (m_job_router_name.size() > 0);
 
 	char *valid_name = build_valid_daemon_name(m_job_router_name.c_str());
@@ -1202,6 +1256,7 @@ JobRouter::GetCandidateJobs() {
 	}
 	delete constraint_tree;
 
+	int cJobsAdded = 0;
     query.ToFirst();
     if( query.Current(key) ) do {
 		if(!AcceptingMoreJobs()) {
@@ -1249,8 +1304,13 @@ JobRouter::GetCandidateJobs() {
 
 		dprintf(D_FULLDEBUG,"JobRouter (%s): found candidate job\n",job->JobDesc().c_str());
 		AddJob(job);
+		++cJobsAdded;
 
     } while (query.Next(key));
+
+	if (m_operate_as_tool) {
+		dprintf(D_ALWAYS, "JobRouter: %d candidate jobs found\n", cJobsAdded);
+	}
 }
 
 JobRoute *
@@ -2253,6 +2313,8 @@ JobRouter::InvalidatePublicAd() {
 	ClassAd invalidate_ad;
 	MyString line;
 
+	ASSERT( ! m_operate_as_tool);
+
 	SetMyTypeName(invalidate_ad, QUERY_ADTYPE);
 	SetTargetTypeName(invalidate_ad, "Job_Router");
 
@@ -2441,6 +2503,14 @@ JobRoute::RouteString() {
 	return route_string;
 }
 
+bool JobRoute::RouteStringPretty(std::string & str) {
+	if (m_route_ad.size() <= 0)
+		return false;
+	classad::PrettyPrint unparser;
+	unparser.Unparse(str, &m_route_ad);
+	return !str.empty();
+}
+
 bool
 JobRoute::ParseClassAd(std::string routing_string,int &offset,classad::ClassAd const *router_defaults_ad,bool allow_empty_requirements) {
 	classad::ClassAdParser parser;
	Modified   src/condor_job_router/JobRouter.h
diff --git a/src/condor_job_router/JobRouter.h b/src/condor_job_router/JobRouter.h
index 15ba57c..d4dee66 100644
--- a/src/condor_job_router/JobRouter.h
+++ b/src/condor_job_router/JobRouter.h
@@ -46,7 +46,7 @@ typedef HashTable<std::string,JobRoute *> RoutingTable;
 
 class JobRouter: public Service {
  public:
-	JobRouter();
+	JobRouter(bool as_tool=false);
 	virtual ~JobRouter();
 
 	// Add a new job to be managed by JobRouter.
@@ -72,6 +72,8 @@ class JobRouter: public Service {
 	void EvalAllSrcJobPeriodicExprs();
 
 	void config();
+	void set_schedds(Scheduler* schedd, Scheduler* schedd2); // let the tool mode push simulated schedulers
+	void dump_routes(FILE* hf); // dump the routing information to the given file.
 	void init();
 
 	//The JobRouter name is used to distinguish this daemon from
@@ -156,6 +158,8 @@ class JobRouter: public Service {
 
 	ClassAd m_public_ad;
 
+	bool m_operate_as_tool;
+
 	// Count jobs being managed.  (Excludes RETIRED jobs.)
 	int NumManagedJobs();
 
@@ -165,8 +169,10 @@ class JobRouter: public Service {
 	// the source schedd.
 	bool RemoveJob(RoutedJob *job);
 
+public:
 	// Find jobs to route.  Function calls AddJob() on each one.
 	void GetCandidateJobs();
+private:
 
 	// Resume management of any jobs we were routing in a previous life.
 	void AdoptOrphans();
	Modified   src/condor_job_router/RoutedJob.h
diff --git a/src/condor_job_router/RoutedJob.h b/src/condor_job_router/RoutedJob.h
index 21ac89f..a6ab634 100644
--- a/src/condor_job_router/RoutedJob.h
+++ b/src/condor_job_router/RoutedJob.h
@@ -101,6 +101,7 @@ class JobRoute {
 	classad::ExprTree *RouteRequirementExpr() {return m_route_requirements;}
 	char const *RouteRequirementsString() {return m_route_requirements_str.c_str();}
 	std::string RouteString(); // returns a string describing the route
+	bool RouteStringPretty(std::string & str); // prints the route classad into str
 
 	// copy state from another route
 	void CopyState(JobRoute *route);
	Modified   src/condor_job_router/Scheduler.h
diff --git a/src/condor_job_router/Scheduler.h b/src/condor_job_router/Scheduler.h
index 3fe0d43..dfce764 100644
--- a/src/condor_job_router/Scheduler.h
+++ b/src/condor_job_router/Scheduler.h
@@ -22,6 +22,27 @@
 
 #include "condor_common.h"
 
+#if 1
+
+class JobLogMirror;
+class NewClassAdJobLogConsumer;
+class Scheduler {
+public:
+	Scheduler(char const *_alt_spool_param=NULL, int id=0);
+	~Scheduler();
+	classad::ClassAdCollection *GetClassAds();
+	void init();
+	void config();
+	void stop();
+	int id();
+
+private:
+
+	NewClassAdJobLogConsumer * m_consumer;
+	JobLogMirror * m_mirror;
+	int m_id; // id of this instance
+};
+#else
 #include "JobLogMirror.h"
 #include "NewClassAdJobLogConsumer.h"
 
@@ -40,5 +61,6 @@ public:
 private:
 	NewClassAdJobLogConsumer *m_consumer;
 };
+#endif
 
 #endif
	New        src/condor_job_router/job_router_tool.cpp
diff --git a/src/condor_job_router/job_router_tool.cpp b/src/condor_job_router/job_router_tool.cpp
new file mode 100644
index 0000000..e699259
--- /dev/null
+++ b/src/condor_job_router/job_router_tool.cpp
@@ -0,0 +1,573 @@
+/***************************************************************
+ *
+ * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+ * University of Wisconsin-Madison, WI.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#include "condor_common.h"
+//#include "condor_daemon_core.h"
+#include "condor_debug.h"
+#include "condor_config.h"
+#include "subsystem_info.h"
+#include "match_prefix.h"
+#include "condor_distribution.h"
+#include "write_user_log.h"
+#include "dprintf_internal.h" // for dprintf_set_outputs
+#include "condor_version.h"
+
+#include "Scheduler.h"
+#include "JobRouter.h"
+#include "submit_job.h"
+
+#ifdef __GNUC__
+#if __GNUC__ >= 4
+  #pragma GCC diagnostic ignored "-Wunused-parameter"
+  #pragma GCC diagnostic ignored "-Wunused-variable"
+  #pragma GCC diagnostic ignored "-Wunused-value"
+#endif
+#endif
+
+
+//JobRouter *job_router = NULL;
+
+//-------------------------------------------------------------
+const char * MyName = NULL;
+classad::ClassAdCollection * g_jobs = NULL;
+
+static bool read_classad_file(const char *filename, classad::ClassAdCollection &classads, const char * constr);
+
+void PREFAST_NORETURN
+my_exit( int status )
+{
+	fflush(stdout);
+	fflush(stderr);
+	exit(status);
+}
+
+void
+usage(int retval = 1)
+{
+	fprintf(stderr, "Usage: %s [options]\n", MyName);
+	fprintf(stderr,
+		"    where [options] is one or more of:\n"
+		"\t-help\t\tPrint this screen and exit\n"
+		"\t-version\tPrint HTCondor version and exit\n"
+		"\t-config\t\tPrint configured routes\n"
+		"\t-match-jobs\tMatch jobs to routes and print the first match\n"
+		"\t-job-ads <file>\tWhen operation requires job ClassAds, Read them from <file>\n"
+		"\n"
+		);
+	my_exit(retval);
+}
+
+static const char * use_next_arg(const char * arg, const char * argv[], int & i)
+{
+	if (argv[i+1]) {
+		return argv[++i];
+	}
+
+	fprintf(stderr, "-%s requires an argument\n", arg);
+	//usage(1);
+	my_exit(1);
+	return NULL;
+}
+
+bool g_silence_dprintf = false;
+void _dprintf_intercept(int cat_and_flags, int hdr_flags, DebugHeaderInfo & info, const char* message, DebugFileInfo* dbgInfo)
+{
+	//if (cat_and_flags & D_FULLDEBUG) return;
+	if (g_silence_dprintf) return;
+	if (is_arg_prefix("JobRouter", message, 9)) { message += 9; if (*message == ':') ++message; if (*message == ' ') ++message; }
+	int cch = strlen(message);
+	fprintf(stdout, &"\n%s"[(cch > 150) ? 0 : 1], message);
+}
+
+static void dprintf_set_output_intercept (
+	int cat_and_flags,
+	DebugOutputChoice choice,
+	DprintfFuncPtr fn)
+{
+
+	dprintf_output_settings my_output;
+	my_output.choice = choice;
+	my_output.accepts_all = true;
+	my_output.logPath = ">BUFFER";	// this is a special case of intercept
+	my_output.HeaderOpts = (cat_and_flags & ~(D_CATEGORY_RESERVED_MASK | D_FULLDEBUG | D_VERBOSE_MASK));
+	my_output.VerboseCats = (cat_and_flags & (D_FULLDEBUG | D_VERBOSE_MASK)) ? choice : 0;
+	dprintf_set_outputs(&my_output, 1);
+
+	// throw away any dprintf messages up to this point.
+	bool was_silent = g_silence_dprintf;
+	g_silence_dprintf = true;
+	dprintf_WriteOnErrorBuffer(NULL, true);
+	g_silence_dprintf = was_silent;
+
+	// PRAGMA_REMIND("tj: fix this hack when the dprintf code has a proper way to register an intercept.")
+	// HACK!!! there is no properly exposed way to set an intercept function, so for now, we reach into
+	// the dprintf internal data structures and just set one. 
+	extern std::vector<DebugFileInfo> * DebugLogs;
+	if (DebugLogs) { (*DebugLogs)[0].dprintfFunc = fn; }
+}
+
+
+int main(int argc, const char *argv[])
+{
+	MyName = argv[0];
+    myDistro->Init( argc, argv );
+	config();
+	set_mySubSystem("TOOL", SUBSYSTEM_TYPE_TOOL);
+
+	StringList bare_args;
+	StringList job_files;
+	bool dash_config = false;
+	bool dash_match_jobs = false;
+	bool dash_diagnostic = false;
+	bool dash_d_always = true;
+	//bool dash_d_fulldebug = false;
+
+	g_jobs = new classad::ClassAdCollection();
+
+	for (int i = 1; i < argc; ++i) {
+
+		const char * pcolon = NULL;
+		if (is_dash_arg_prefix(argv[i], "help", 1)) {
+			usage(0);
+		} else if (is_dash_arg_prefix(argv[i], "version", 1)) {
+			printf( "%s\n%s\n", CondorVersion(), CondorPlatform() );
+			my_exit(0);
+		} else if (is_dash_arg_colon_prefix(argv[i], "debug", &pcolon, 1)) {
+			dash_d_always = true;
+			if (pcolon && (is_arg_prefix(pcolon+1, "verbose", 1) || is_arg_prefix(pcolon+1, "full", 1))) {
+				//dash_d_fulldebug = true;
+			}
+		} else if (is_dash_arg_colon_prefix(argv[i], "diagnostic", &pcolon, 4)) {
+			dash_diagnostic = true;
+		} else if (is_dash_arg_prefix(argv[i], "config", 2)) {
+			dash_config = true;
+		} else if (is_dash_arg_prefix(argv[i], "match-jobs", 2)) {
+			dash_match_jobs = true;
+		} else if (is_dash_arg_prefix(argv[i], "job-ads", 1)) {
+			const char * filename = use_next_arg("job-ads", argv, i);
+			job_files.append(filename);
+		} else if (*argv[i] != '-') {
+			// arguments that don't begin with "-" are bare arguments
+			bare_args.append(argv[i]);
+			continue;
+		} else {
+			fprintf(stderr, "ERROR: %s is not a valid argument\n", argv[i]);
+			usage(1);
+		}
+	}
+
+
+	// tell the dprintf code to had messages to our callback function.
+	unsigned int cat_and_flags = D_FULLDEBUG | D_CAT;
+	//if (dash_d_fulldebug) { cat_and_flags |= D_FULLDEBUG; }
+	DebugOutputChoice choice=1<<D_ERROR;
+	if (dash_d_always || dash_diagnostic) { choice |= 1<<D_ALWAYS; }
+	dprintf_set_output_intercept(cat_and_flags, choice, _dprintf_intercept);
+
+
+	// before we call init() for the router, we need to install a pseudo-schedd object
+	// so that init() doesn't install a real schedd object.
+	Scheduler* schedd = new Scheduler("JOB_ROUTER_SCHEDD1_SPOOL");
+	Scheduler* schedd2 = NULL;
+	std::string spool2;
+	if (param(spool2, "JOB_ROUTER_SCHEDD2_SPOOL")) {
+		schedd2 = new Scheduler("JOB_ROUTER_SCHEDD2_SPOOL");
+	}
+
+	g_silence_dprintf = dash_diagnostic ? false : true;
+	JobRouter job_router(true);
+	job_router.set_schedds(schedd, schedd2);
+	job_router.init();
+	g_silence_dprintf = false;
+
+	if (dash_config) {
+		fprintf (stdout, "\n\n");
+		job_router.dump_routes(stdout);
+	}
+
+	if ( ! job_files.isEmpty()) {
+		job_files.rewind();
+		const char * filename;
+		while ((filename = job_files.next())) {
+			 read_classad_file(filename, *g_jobs, NULL);
+		}
+	}
+
+	if (dash_match_jobs) {
+		fprintf(stdout, "\nMatching jobs against routes to find candidate jobs.\n");
+		const classad::View *root_view = g_jobs->GetView("root");
+		if (root_view && (root_view->begin() != root_view->end())) {
+			job_router.GetCandidateJobs();
+		} else {
+			fprintf(stdout, "There are no jobs to match\n");
+		}
+	}
+
+	return 0;
+}
+
+class CondorQClassAdFileParseHelper : public compat_classad::ClassAdFileParseHelper
+{
+ public:
+	virtual int PreParse(std::string & line, ClassAd & ad, FILE* file);
+	virtual int OnParseError(std::string & line, ClassAd & ad, FILE* file);
+	std::string schedd_name;
+	std::string schedd_addr;
+};
+
+// this method is called before each line is parsed. 
+// return 0 to skip (is_comment), 1 to parse line, 2 for end-of-classad, -1 for abort
+int CondorQClassAdFileParseHelper::PreParse(std::string & line, ClassAd & /*ad*/, FILE* /*file*/)
+{
+	// treat blank lines as delimiters.
+	if (line.size() <= 0) {
+		return 2; // end of classad.
+	}
+
+	// standard delimitors are ... and ***
+	if (starts_with(line,"\n") || starts_with(line,"...") || starts_with(line,"***")) {
+		return 2; // end of classad.
+	}
+
+	// the normal output of condor_q -long is "-- schedd-name <addr>"
+	// we want to treat that as a delimiter, and also capture the schedd name and addr
+	if (starts_with(line, "-- ")) {
+		if (starts_with(line.substr(3), "Schedd:")) {
+			schedd_name = line.substr(3+8);
+			size_t ix1 = schedd_name.find_first_of(": \t\n");
+			if (ix1 != std::string::npos) {
+				size_t ix2 = schedd_name.find_first_not_of(": \t\n", ix1);
+				if (ix2 != std::string::npos) {
+					schedd_addr = schedd_name.substr(ix2);
+					ix2 = schedd_addr.find_first_of(" \t\n");
+					if (ix2 != std::string::npos) {
+						schedd_addr = schedd_addr.substr(0,ix2);
+					}
+				}
+				schedd_name = schedd_name.substr(0,ix1);
+			}
+		}
+		return 2;
+	}
+
+
+	// check for blank lines or lines whose first character is #
+	// tell the parser to skip those lines, otherwise tell the parser to
+	// parse the line.
+	for (size_t ix = 0; ix < line.size(); ++ix) {
+		if (line[ix] == '#' || line[ix] == '\n')
+			return 0; // skip this line, but don't stop parsing.
+		if (line[ix] != ' ' && line[ix] != '\t')
+			break;
+	}
+	return 1; // parse this line
+}
+
+// this method is called when the parser encounters an error
+// return 0 to skip and continue, 1 to re-parse line, 2 to quit parsing with success, -1 to abort parsing.
+int CondorQClassAdFileParseHelper::OnParseError(std::string & line, ClassAd & ad, FILE* file)
+{
+	// when we get a parse error, skip ahead to the start of the next classad.
+	int ee = this->PreParse(line, ad, file);
+	while (1 == ee) {
+		if ( ! readLine(line, file, false) || feof(file)) {
+			ee = 2;
+			break;
+		}
+		ee = this->PreParse(line, ad, file);
+	}
+	return ee;
+}
+
+// -----------------------------
+static bool read_classad_file(const char *filename, classad::ClassAdCollection &classads, const char * constr)
+{
+	bool success = false;
+
+	FILE* file = safe_fopen_wrapper_follow(filename, "r");
+	if (file == NULL) {
+		fprintf(stderr, "Can't open file of job ads: %s\n", filename);
+		return false;
+	} else {
+		// this helps us parse the output of condor_q -long
+		CondorQClassAdFileParseHelper parse_helper;
+
+		for (;;) {
+			ClassAd* classad = new ClassAd();
+
+			int error;
+			bool is_eof;
+			int cAttrs = classad->InsertFromFile(file, is_eof, error, &parse_helper);
+
+			bool include_classad = cAttrs > 0 && error >= 0;
+			if (include_classad && constr) {
+				classad::Value val;
+				if (classad->EvaluateExpr(constr,val)) {
+					if ( ! val.IsBooleanValueEquiv(include_classad)) {
+						include_classad = false;
+					}
+				}
+			}
+			if (include_classad) {
+				int cluster, proc = -1;
+				if (classad->LookupInteger(ATTR_CLUSTER_ID, cluster) && classad->LookupInteger(ATTR_PROC_ID, proc)) {
+					std::string key;
+					formatstr(key, "%d,%d", cluster, proc);
+					if (classads.AddClassAd(key, classad)) {
+						classad = NULL; // this is now owned by the collection.
+					}
+				} else {
+					fprintf(stderr, "Skipping ad because it doesn't have a ClusterId and/or ProcId attribute\n");
+				}
+			}
+			if (classad) {
+				delete classad;
+			}
+
+			if (is_eof) {
+				success = true;
+				break;
+			}
+			if (error < 0) {
+				success = false;
+				break;
+			}
+		}
+
+		fclose(file);
+	}
+	return success;
+}
+
+
+// this is how we will feed job ad's into the router
+//
+class JobLogMirror {
+public:
+	JobLogMirror(char const *spool_param=NULL) {}
+	~JobLogMirror() {}
+
+	void init() {}
+	void config() {}
+	void stop() {}
+
+private:
+};
+
+Scheduler::Scheduler(char const *_alt_spool_param /*=NULL*/, int id /*=0*/)
+	: m_consumer(NULL)
+	, m_mirror(NULL)
+	, m_id(id)
+{ 
+}
+
+Scheduler::~Scheduler()
+{
+	delete m_mirror;
+	m_mirror = NULL;
+	m_consumer = NULL;
+}
+
+classad::ClassAdCollection *Scheduler::GetClassAds()
+{
+	if (m_id == 0) {
+		return g_jobs;
+	}
+	return NULL;
+}
+
+void Scheduler::init() {  m_mirror->init(); }
+void Scheduler::config() { m_mirror->config(); }
+void Scheduler::stop()  { m_mirror->stop(); }
+int  Scheduler::id() { return m_id; }
+
+
+// needed by JobRouter
+unsigned int hashFuncStdString( std::string const & key)
+{
+    return hashFuncChars(key.c_str());
+}
+
+// 
+JobRouterHookMgr::JobRouterHookMgr() : HookClientMgr(), NUM_HOOKS(0), UNDEFINED("UNDEFINED"), m_hook_paths(MyStringHash) {}
+JobRouterHookMgr::~JobRouterHookMgr() {};
+bool JobRouterHookMgr::initialize() { reconfig(); return true; /*HookClientMgr::initialize()*/; }
+bool JobRouterHookMgr::reconfig() { m_default_hook_keyword = param("JOB_ROUTER_HOOK_KEYWORD"); return true; }
+
+int JobRouterHookMgr::hookTranslateJob(RoutedJob* r_job, std::string &route_info) { return 1; }
+int JobRouterHookMgr::hookUpdateJobInfo(RoutedJob* r_job) { return 1; }
+int JobRouterHookMgr::hookJobExit(RoutedJob* r_job) { return 1; }
+int JobRouterHookMgr::hookJobCleanup(RoutedJob* r_job) { return 1; }
+
+std::string
+JobRouterHookMgr::getHookKeyword(classad::ClassAd ad)
+{
+	std::string hook_keyword;
+
+	if (false == ad.EvaluateAttrString(ATTR_HOOK_KEYWORD, hook_keyword))
+	{
+		if ( m_default_hook_keyword ) {
+			hook_keyword = m_default_hook_keyword;
+		}
+	}
+	return hook_keyword;
+}
+
+
+
+
+ClaimJobResult claim_job(int cluster, int proc, MyString * error_details, const char * my_identity)
+{
+	return CJR_OK;
+}
+
+
+
+ClaimJobResult claim_job(classad::ClassAd const &ad, const char * pool_name, const char * schedd_name, int cluster, int proc, MyString * error_details, const char * my_identity, bool target_is_sandboxed)
+{
+	return CJR_OK;
+}
+
+bool yield_job(bool done, int cluster, int proc, classad::ClassAd const &job_ad, MyString * error_details, const char * my_identity, bool target_is_sandboxed, bool release_on_hold, bool *keep_trying) {
+	return true;
+}
+
+
+bool yield_job(classad::ClassAd const &ad,const char * pool_name,
+	const char * schedd_name, bool done, int cluster, int proc,
+	MyString * error_details, const char * my_identity, bool target_is_sandboxed,
+        bool release_on_hold, bool *keep_trying)
+{
+	return true;
+}
+
+bool submit_job( ClassAd & src, const char * schedd_name, const char * pool_name, bool is_sandboxed, int * cluster_out /*= 0*/, int * proc_out /*= 0 */)
+{
+	return true;
+}
+
+bool submit_job( classad::ClassAd & src, const char * schedd_name, const char * pool_name, bool is_sandboxed, int * cluster_out /*= 0*/, int * proc_out /*= 0 */)
+{
+	return true;
+}
+
+/*
+	Push the dirty attributes in src into the queue.  Does _not_ clear
+	the dirty attributes.
+	Assumes the existance of an open qmgr connection (via ConnectQ).
+*/
+bool push_dirty_attributes(classad::ClassAd & src)
+{
+	return true;
+}
+
+/*
+	Push the dirty attributes in src into the queue.  Does _not_ clear
+	the dirty attributes.
+	Establishes (and tears down) a qmgr connection.
+*/
+bool push_dirty_attributes(classad::ClassAd & src, const char * schedd_name, const char * pool_name)
+{
+	return true;
+}
+
+/*
+	Update src in the queue so that it ends up looking like dest.
+    This handles attribute deletion as well as change of value.
+	Assumes the existance of an open qmgr connection (via ConnectQ).
+*/
+bool push_classad_diff(classad::ClassAd & src,classad::ClassAd & dest)
+{
+	return true;
+}
+
+/*
+	Update src in the queue so that it ends up looking like dest.
+    This handles attribute deletion as well as change of value.
+	Establishes (and tears down) a qmgr connection.
+*/
+bool push_classad_diff(classad::ClassAd & src, classad::ClassAd & dest, const char * schedd_name, const char * pool_name)
+{
+	return true;
+}
+
+bool finalize_job(classad::ClassAd const &ad,int cluster, int proc, const char * schedd_name, const char * pool_name, bool is_sandboxed)
+{
+	return true;
+}
+
+bool remove_job(classad::ClassAd const &ad, int cluster, int proc, char const *reason, const char * schedd_name, const char * pool_name, MyString &error_desc)
+{
+	return true;
+}
+
+bool InitializeUserLog( classad::ClassAd const &job_ad, WriteUserLog *ulog, bool *no_ulog )
+{
+	return true;
+}
+
+bool InitializeAbortedEvent( JobAbortedEvent *event, classad::ClassAd const &job_ad )
+{
+	return true;
+}
+
+bool InitializeTerminateEvent( TerminatedEvent *event, classad::ClassAd const &job_ad )
+{
+	return true;
+}
+
+bool InitializeHoldEvent( JobHeldEvent *event, classad::ClassAd const &job_ad )
+{
+	return true;
+}
+
+bool WriteEventToUserLog( ULogEvent const &event, classad::ClassAd const &ad )
+{
+	return true;
+}
+
+bool WriteTerminateEventToUserLog( classad::ClassAd const &ad )
+{
+	return true;
+}
+
+bool WriteAbortEventToUserLog( classad::ClassAd const &ad )
+{
+	return true;
+}
+
+bool WriteHoldEventToUserLog( classad::ClassAd const &ad )
+{
+	return true;
+}
+
+
+
+// The following is copied from gridmanager/basejob.C
+// TODO: put the code into a shared file.
+
+void
+EmailTerminateEvent(ClassAd * job_ad, bool   /*exit_status_known*/)
+{
+}
+
+bool EmailTerminateEvent( classad::ClassAd const &ad )
+{
+	return true;
+}
	Modified   src/condor_job_router/schedd_main.cpp
diff --git a/src/condor_job_router/schedd_main.cpp b/src/condor_job_router/schedd_main.cpp
index 544b80f..c6c7eef 100644
--- a/src/condor_job_router/schedd_main.cpp
+++ b/src/condor_job_router/schedd_main.cpp
@@ -26,11 +26,39 @@
 #include "ClassAdLogReader.h"
 #include "Scheduler.h"
 #include "JobRouter.h"
+#include "JobLogMirror.h"
+#include "NewClassAdJobLogConsumer.h"
 
 
 JobRouter *job_router;
 
 //-------------------------------------------------------------
+Scheduler::Scheduler(char const *_alt_spool_param /*=NULL*/, int id /*=0*/)
+	: m_id(id)
+{
+	m_consumer = new NewClassAdJobLogConsumer();
+	m_mirror = new JobLogMirror(m_consumer, _alt_spool_param);
+}
+
+Scheduler::~Scheduler()
+{
+	delete m_mirror; // this has the side effect of deleting m_consumer.
+	m_mirror = NULL;
+	m_consumer = NULL;
+}
+
+classad::ClassAdCollection *Scheduler::GetClassAds()
+{
+	return m_consumer->GetClassAds();
+}
+
+void Scheduler::init() { m_mirror->init(); }
+void Scheduler::config() { m_mirror->config(); }
+void Scheduler::stop()  { m_mirror->stop(); }
+int  Scheduler::id() { return m_id; }
+
+
+//-------------------------------------------------------------
 
 void main_init(int   /*argc*/, char ** /*argv*/)
 {

--- a/src/condor_job_router/JobRouter.cpp
+++ b/src/condor_job_router/JobRouter.cpp
@@ -63,6 +63,10 @@ const int THROTTLE_UPDATE_INTERVAL = 600;
 
 JobRouter::JobRouter(bool as_tool)
 	: m_jobs(5000,hashFuncStdString,rejectDuplicateKeys)
+	, m_schedd2_name(NULL)
+	, m_schedd2_pool(NULL)
+	, m_schedd1_name(NULL)
+	, m_schedd1_pool(NULL)
 	, m_operate_as_tool(as_tool)
 {
 	m_scheduler = NULL;
	Modified   src/condor_job_router/job_router_tool.cpp
diff --git a/src/condor_job_router/job_router_tool.cpp b/src/condor_job_router/job_router_tool.cpp
index e699259..34cc585 100644
--- a/src/condor_job_router/job_router_tool.cpp
+++ b/src/condor_job_router/job_router_tool.cpp
@@ -405,7 +405,7 @@ unsigned int hashFuncStdString( std::string const & key)
 }
 
 // 
-JobRouterHookMgr::JobRouterHookMgr() : HookClientMgr(), NUM_HOOKS(0), UNDEFINED("UNDEFINED"), m_hook_paths(MyStringHash) {}
+JobRouterHookMgr::JobRouterHookMgr() : HookClientMgr(), NUM_HOOKS(0), UNDEFINED("UNDEFINED"), m_default_hook_keyword(NULL), m_hook_paths(MyStringHash) {}
 JobRouterHookMgr::~JobRouterHookMgr() {};
 bool JobRouterHookMgr::initialize() { reconfig(); return true; /*HookClientMgr::initialize()*/; }
 bool JobRouterHookMgr::reconfig() { m_default_hook_keyword = param("JOB_ROUTER_HOOK_KEYWORD"); return true; }

--- a/src/condor_includes/condor_debug.h
+++ b/src/condor_includes/condor_debug.h
@@ -177,6 +177,7 @@ int dprintf_config(
 	int c_info = 0); // in: number of entries in p_info array on input.                  
 
 int dprintf_config_tool(const char* subsys = NULL, int flags = 0);
+int dprintf_config_tool_on_error(int flags = 0);
 
 // parse strflags and cat_and_flags and merge them into the in,out args
 // for backward compatibility, the D_ALWAYS bit will always be set in basic
@@ -234,6 +235,18 @@ double dprintf_get_lock_delay(void);
 */
 int dprintf_getCount(void);
 
+/* flush the buffered output that is created when TOOL_DEBUG_ON_ERROR is set
+ */
+int dprintf_WriteOnErrorBuffer(FILE * out, int fClearBuffer);
+
+/* flush the buffered output that is created when TOOL_DEBUG_ON_ERROR is set
+ * to this file on exit (during global class destruction), if code passed to 
+ * dprintf_SetExitCode is 0, the OnErrorBuffer is discarded, otherwise it is 
+ * written to out
+ */
+FILE * dprintf_OnExitDumpOnErrorBuffer(FILE * out);
+int dprintf_SetExitCode(int code);
+
 /* wrapper for fclose() that soaks up EINTRs up to maxRetries number of times.
  */
 int fclose_wrapper( FILE *stream, int maxRetries );
	Modified   src/condor_includes/dprintf_internal.h
diff --git a/src/condor_includes/dprintf_internal.h b/src/condor_includes/dprintf_internal.h
index 7509e94..e256c7a 100644
--- a/src/condor_includes/dprintf_internal.h
+++ b/src/condor_includes/dprintf_internal.h
@@ -129,9 +129,12 @@ struct dprintf_output_settings
 
 void dprintf_set_outputs(const struct dprintf_output_settings *p_info, int c_info);
 
+void * dprintf_get_onerror_data();
+
 const char* _format_global_header(int cat_and_flags, int hdr_flags, DebugHeaderInfo & info);
 //Global dprint functions meant as fallbacks.
 void _dprintf_global_func(int cat_and_flags, int hdr_flags, DebugHeaderInfo & info, const char* message, DebugFileInfo* dbgInfo);
+void _dprintf_to_buffer(int cat_and_flags, int hdr_flags, DebugHeaderInfo & info, const char* message, DebugFileInfo* dbgInfo);
 
 #ifdef WIN32
 //Output to dbg string
	Modified   src/condor_q.V6/queue.cpp
diff --git a/src/condor_q.V6/queue.cpp b/src/condor_q.V6/queue.cpp
index 9983a59..1bc4a9e 100644
--- a/src/condor_q.V6/queue.cpp
+++ b/src/condor_q.V6/queue.cpp
@@ -57,13 +57,9 @@
 #include "../classad_analysis/analysis.h"
 #include "classad/classadCache.h" // for CachedExprEnvelope
 
-/*
-#ifndef WIN32
-#include <sys/types.h>
-#include <unistd.h>
-#include <pwd.h>
-#endif
-*/
+// pass the exit code through dprintf_SetExitCode so that it knows
+// whether to print out the on-error buffer or not.
+#define exit(n) (exit)(dprintf_SetExitCode(n))
 
 #ifdef HAVE_EXT_POSTGRESQL
 #include "sqlquery.h"
@@ -593,8 +589,9 @@ int main (int argc, char **argv)
 	// load up configuration file
 	myDistro->Init( argc, argv );
 	config();
-
-	classad::ClassAdSetExpressionCaching( param_boolean( "ENABLE_CLASSAD_CACHING", false ) );
+	dprintf_config_tool_on_error(0);
+	dprintf_OnExitDumpOnErrorBuffer(stderr);
+	//classad::ClassAdSetExpressionCaching( param_boolean( "ENABLE_CLASSAD_CACHING", false ) );
 
 #ifdef HAVE_EXT_POSTGRESQL
 		/* by default check the configuration for local database */
	Modified   src/condor_scripts/CondorPersonal.pm
diff --git a/src/condor_scripts/CondorPersonal.pm b/src/condor_scripts/CondorPersonal.pm
index 1b1653e..33bc533 100755
--- a/src/condor_scripts/CondorPersonal.pm
+++ b/src/condor_scripts/CondorPersonal.pm
@@ -935,4 +935,7 @@ debug( "HMMMMMMMMMMM opening to write <$topleveldir/$personal_local>\n",$debugle
 	print NEW "DAGMAN_USER_LOG_SCAN_INTERVAL = 1\n";
+ 	# bill make tools more forgiving of being busy
+ 	print NEW "TOOL_TIMEOUT_MULTIPLIER = 10\n";
+	print NEW "TOOL_DEBUG_ON_ERROR = D_ANY D_ALWAYS:2\n";
 
 	if($personal_daemons ne "")
 	{
	Modified   src/condor_status.V6/status.cpp
diff --git a/src/condor_status.V6/status.cpp b/src/condor_status.V6/status.cpp
index 56380b4..7b446ed 100644
--- a/src/condor_status.V6/status.cpp
+++ b/src/condor_status.V6/status.cpp
@@ -134,6 +134,7 @@ main (int argc, char *argv[])
 	myDistro->Init( argc, argv );
 	myName = argv[0];
 	config();
+	dprintf_config_tool_on_error(0);
 
 	// The arguments take two passes to process --- the first pass
 	// figures out the mode, after which we can instantiate the required
@@ -148,6 +149,7 @@ main (int argc, char *argv[])
 
 	// instantiate query object
 	if (!(query = new CondorQuery (type))) {
+		dprintf_WriteOnErrorBuffer(stderr, true);
 		fprintf (stderr, "Error:  Out of memory\n");
 		exit (1);
 	}
@@ -428,11 +430,12 @@ main (int argc, char *argv[])
 				addr = d->addr();
 				requested_daemon = d;
 			} else {
-			        const char* id = d->idStr();
-                                if (NULL == id) id = d->name();
+				const char* id = d->idStr();
+				if (NULL == id) id = d->name();
+				dprintf_WriteOnErrorBuffer(stderr, true);
 				if (NULL == id) id = "daemon";
-           	                fprintf(stderr, "Error: Failed to locate %s\n", id);
-                                fprintf(stderr, "%s\n", d->error());
+				fprintf(stderr, "Error: Failed to locate %s\n", id);
+				fprintf(stderr, "%s\n", d->error());
 				exit( 1 );
 			}
 		}
@@ -455,6 +458,7 @@ main (int argc, char *argv[])
 
 	// if any error was encountered during the query, report it and exit 
         if (Q_OK != q) {
+            dprintf_WriteOnErrorBuffer(stderr, true);
                 // we can always provide these messages:
 	        fprintf( stderr, "Error: %s\n", getStrQueryResult(q) );
 		fprintf( stderr, "%s\n", errstack.getFullText(true).c_str() );
@@ -620,6 +624,7 @@ firstPass (int argc, char *argv[])
 			}
 			pool = new DCCollector( argv[i] );
 			if( !pool->addr() ) {
+				dprintf_WriteOnErrorBuffer(stderr, true);
 				fprintf( stderr, "Error: %s\n", pool->error() );
 				if (!expert) {
 					printf("\n");
@@ -1087,6 +1092,7 @@ secondPass (int argc, char *argv[])
 					// use what we are given and do not flag an error.
 					daemonname = strnewp(argv[i]);
 				} else {
+					dprintf_WriteOnErrorBuffer(stderr, true);
 					fprintf( stderr, "%s: unknown host %s\n",
 								 argv[0], get_host_part(argv[i]) );
 					exit(1);
diff --git a/src/condor_utils/dprintf.cpp b/src/condor_utils/dprintf.cpp
index b12744b..34af8d1 100644
--- a/src/condor_utils/dprintf.cpp
+++ b/src/condor_utils/dprintf.cpp
@@ -125,6 +125,45 @@ int		DebugUseTimestamps = 0;
 char *	DebugTimeFormat = NULL;
 
 /*
+ * if TOOL_DEBUG_ON_ERROR is set, then every dprintf writes to this buffer
+ * in addition to anything defined in TOOL_DEBUG.  The contents of this buffer
+ * can be flushed and written by calling dprintf_WriteOnErrorBuffer
+ */
+static std::stringstream DebugOnErrorBuffer;
+void * dprintf_get_onerror_data() { return (void*)&DebugOnErrorBuffer; }
+int dprintf_WriteOnErrorBuffer(FILE * out, int fClearBuffer) {
+	int cch = 0;
+	if (out) {
+		if ( ! DebugOnErrorBuffer.str().empty()) {
+			cch = (int)fwrite(DebugOnErrorBuffer.str().c_str(), 1, DebugOnErrorBuffer.str().length(), out);
+		}
+	}
+	if (fClearBuffer) {
+		DebugOnErrorBuffer.clear();
+	}
+	return cch;
+}
+
+static class dpf_on_error_trigger {
+	FILE * file;
+	int    code; // write if code is non-zero
+public:
+	dpf_on_error_trigger() : file(NULL), code(1) {}
+	~dpf_on_error_trigger() {
+		if (code && file && ! DebugOnErrorBuffer.str().empty()) {
+			fprintf(file, "\n---------------- TOOL_DEBUG_ON_ERROR output -----------------\n");
+			dprintf_WriteOnErrorBuffer(file, true);
+			fprintf(file, "---------------- TOOL_DEBUG_ON_ERROR ends -------------------\n");
+		}
+	}
+	FILE * WriteOnErrorExit(FILE * out) { FILE * tmp = file; file = out; return tmp; }
+	int ExitCode(int n) { return code = n; }
+} _dprintf_on_error_trigger;
+FILE * dprintf_OnExitDumpOnErrorBuffer(FILE * out) { return _dprintf_on_error_trigger.WriteOnErrorExit(out); }
+int dprintf_SetExitCode(int code) { return _dprintf_on_error_trigger.ExitCode(code); }
+
+
+/*
  * When true, don't exit even if we fail to open the debug output file.
  * Added so that on Win32 the kbdd (which is running as a user) won't quit 
  * if it does't have access to the directory where log files live.
@@ -1910,6 +1949,19 @@ dprintf_dump_stack(void) {
 }
 #endif
 
+void _dprintf_to_buffer(int cat_and_flags, int hdr_flags, DebugHeaderInfo & info, const char* message, DebugFileInfo* dbgInfo)
+{
+	void * pvUser = dbgInfo->userData;
+	if (pvUser) {
+		std::stringstream * pstm = (std::stringstream *)pvUser;
+		const char* header = _format_global_header(cat_and_flags, hdr_flags, info);
+		if (header) {
+			(*pstm) << header;
+		}
+		(*pstm) << message;
+	}
+}
+
 #ifdef WIN32
 void dprintf_to_outdbgstr(int cat_and_flags, int hdr_flags, DebugHeaderInfo & info, const char* message, DebugFileInfo* dbgInfo)
 {
	Modified   src/condor_utils/dprintf_common.cpp
diff --git a/src/condor_utils/dprintf_common.cpp b/src/condor_utils/dprintf_common.cpp
index 292b7f2..43e80a6 100644
--- a/src/condor_utils/dprintf_common.cpp
+++ b/src/condor_utils/dprintf_common.cpp
@@ -233,16 +233,16 @@ _condor_parse_merge_debug_flags(
 	}
 }
 
-// set global debug global flags and header options
+// convert old style flags to DebugOutputChoice
 //
 void
-_condor_set_debug_flags( const char *strflags, int cat_and_flags )
+_condor_set_debug_flags_ex(
+	const char *strflags,
+	int cat_and_flags,
+	unsigned int & header,
+	DebugOutputChoice & choice,
+	DebugOutputChoice & verbose)
 {
-	// set default values for flags and header options before we parse the passed in args
-	unsigned int      header = 0;
-	DebugOutputChoice choice = (1<<D_ALWAYS) | (1<<D_ERROR) | (1<<D_STATUS);
-	DebugOutputChoice verbose = 0;
-
 	// special case. if a single category to be passed in cat_and_flags
 	// in practice, this category is always D_ALWAYS which is set above anyway.
 	choice |= 1<<(cat_and_flags & D_CATEGORY_MASK);
@@ -251,7 +251,18 @@ _condor_set_debug_flags( const char *strflags, int cat_and_flags )
 
 	// parse and merge strflags and cat_and_flags into header & choice
 	_condor_parse_merge_debug_flags(strflags, (cat_and_flags & ~D_CATEGORY_RESERVED_MASK), header, choice, verbose);
+}
 
+// set global debug global flags and header options
+//
+void
+_condor_set_debug_flags( const char *strflags, int cat_and_flags )
+{
+	// set default values for flags and header options before we parse the passed in args
+	unsigned int      header = 0;
+	DebugOutputChoice choice = (1<<D_ALWAYS) | (1<<D_ERROR) | (1<<D_STATUS);
+	DebugOutputChoice verbose = 0;
+	_condor_set_debug_flags_ex(strflags, cat_and_flags, header, choice, verbose);
 	DebugHeaderOptions = header;
 	AnyDebugBasicListener = choice;
 	AnyDebugVerboseListener = verbose;
	Modified   src/condor_utils/dprintf_config.cpp
diff --git a/src/condor_utils/dprintf_config.cpp b/src/condor_utils/dprintf_config.cpp
index bde8806..0edfff0 100644
--- a/src/condor_utils/dprintf_config.cpp
+++ b/src/condor_utils/dprintf_config.cpp
@@ -54,6 +54,49 @@ dprintf_config_ContinueOnFailure ( int fContinue )
 	return fOld;
 }
 
+// configure tool_on_error output from cat_and_flags, or if cat_and_flags is 0
+// configure it from the TOOL_ON_ERROR_DEBUG parameter.
+int
+dprintf_config_tool_on_error(int cat_and_flags)
+{
+	dprintf_output_settings tool_output[1];
+	int cOutputs = 0;
+
+	if (cat_and_flags) {
+		extern void _condor_set_debug_flags_ex(const char *, int, unsigned int &, DebugOutputChoice &, DebugOutputChoice &);
+		tool_output[cOutputs].logPath = ">BUFFER";
+		tool_output[cOutputs].HeaderOpts = 0;
+		tool_output[cOutputs].choice = 0;
+		tool_output[cOutputs].VerboseCats = 0;
+		_condor_set_debug_flags_ex(NULL, cat_and_flags,
+			tool_output[cOutputs].HeaderOpts,
+			tool_output[cOutputs].choice,
+			tool_output[cOutputs].VerboseCats);
+		if (tool_output[cOutputs].choice & 1<<D_ALWAYS) tool_output[cOutputs].accepts_all = true;
+		++cOutputs;
+	} else {
+		char * pval = param("TOOL_DEBUG_ON_ERROR");
+		if (pval) {
+			tool_output[cOutputs].logPath = ">BUFFER";
+			tool_output[cOutputs].HeaderOpts = 0;
+			tool_output[cOutputs].choice |= (1<<D_ALWAYS | 1<<D_ERROR);
+			tool_output[cOutputs].VerboseCats = 0;
+			tool_output[cOutputs].accepts_all = true;
+			_condor_parse_merge_debug_flags( pval, 0,
+				tool_output[cOutputs].HeaderOpts,
+				tool_output[cOutputs].choice,
+				tool_output[cOutputs].VerboseCats);
+			++cOutputs;
+			free(pval);
+		}
+	}
+
+	if (cOutputs > 0) {
+		dprintf_set_outputs(tool_output, cOutputs);
+	}
+	return cOutputs;
+}
+
 int
 dprintf_config_tool(const char* subsys, int /*flags*/)
 {
@@ -64,16 +107,16 @@ dprintf_config_tool(const char* subsys, int /*flags*/)
 
 	PRAGMA_REMIND("TJ: allow callers of dprintf_config_tool to pass logging verbosity and flags");
 
-	dprintf_output_settings tool_output;
-	tool_output.choice = 1<<D_ALWAYS | 1<<D_ERROR;
-	tool_output.accepts_all = true;
+	dprintf_output_settings tool_output[2];
+	tool_output[0].choice = 1<<D_ALWAYS | 1<<D_ERROR;
+	tool_output[0].accepts_all = true;
 	
 	/*
 	** First, add the debug flags that are shared by everyone.
 	*/
 	pval = param("ALL_DEBUG");//dprintf_param_funcs->param("ALL_DEBUG");
 	if( pval ) {
-		_condor_parse_merge_debug_flags( pval, 0, HeaderOpts, tool_output.choice, verbose);
+		_condor_parse_merge_debug_flags( pval, 0, HeaderOpts, tool_output[0].choice, verbose);
 		free( pval );
 	}
 
@@ -86,7 +129,7 @@ dprintf_config_tool(const char* subsys, int /*flags*/)
 		pval = param("DEFAULT_DEBUG");//dprintf_param_funcs->param("DEFAULT_DEBUG");
 	}
 	if( pval ) {
-		_condor_parse_merge_debug_flags( pval, 0, HeaderOpts, tool_output.choice, verbose);
+		_condor_parse_merge_debug_flags( pval, 0, HeaderOpts, tool_output[0].choice, verbose);
 		free( pval );
 	}
 
@@ -112,11 +155,12 @@ dprintf_config_tool(const char* subsys, int /*flags*/)
 		}
 	}
 
-	tool_output.logPath = "2>";
-	tool_output.HeaderOpts = HeaderOpts;
-	tool_output.VerboseCats = verbose;
+	tool_output[0].logPath = "2>";
+	tool_output[0].HeaderOpts = HeaderOpts;
+	tool_output[0].VerboseCats = verbose;
+	int cOutputs = 1;
 
-	dprintf_set_outputs(&tool_output, 1);
+	dprintf_set_outputs(tool_output, cOutputs);
 
 	return 0;
 }
	Modified   src/condor_utils/dprintf_setup.cpp
diff --git a/src/condor_utils/dprintf_setup.cpp b/src/condor_utils/dprintf_setup.cpp
index 251b735..d6448e7 100644
--- a/src/condor_utils/dprintf_setup.cpp
+++ b/src/condor_utils/dprintf_setup.cpp
@@ -145,6 +145,12 @@ void dprintf_set_outputs(const struct dprintf_output_settings *p_info, int c_inf
 					it->userData = static_cast<void*>(DprintfSyslogFactory::NewLog(LOG_DAEMON));
 				}
 #endif
+				else if (logPath == ">BUFFER")
+				{
+					it->outputTarget = OUTPUT_DEBUG_STR;
+					it->dprintfFunc = _dprintf_to_buffer;
+					it->userData = dprintf_get_onerror_data();
+				}
 				else
 				{
 					it->outputTarget = FILE_OUT;

--- a/src/condor_utils/dprintf.cpp
+++ b/src/condor_utils/dprintf.cpp
@@ -664,10 +664,8 @@ _condor_dprintf_va( int cat_and_flags, DPF_IDENT ident, const char* fmt, va_list
 					debug_lock_it(&(*it), NULL, 0, it->dont_panic);
 					funlock_it = true;
 					break;
-			   #ifdef WIN32
-				case OUTPUT_DEBUG_STR:
+				case OUTPUT_DEBUG_STR: // recognise this on linux, it's part of the >BUFFER special case
 					break;
-			   #endif
 			}
 			
 			it->dprintfFunc(cat_and_flags, DebugHeaderOptions, info, message_buffer, &(*it));
--- a/src/condor_includes/match_prefix.h
+++ b/src/condor_includes/match_prefix.h
@@ -46,5 +46,11 @@ bool is_arg_prefix(const char * parg, const char * pval, int must_match_length =
 // use this when you want to tack qualifiers onto arguments rather than supplying them as separate arguments.
 bool is_arg_colon_prefix(const char * parg, const char * pval, const char ** ppcolon, int must_match_length = 0);
 
-// return true of parg begins with '-' and is_arg_prefix(parg,pval,mml) is true
+// return true of parg begins with '-' or '--' and is_arg_prefix(parg,pval,mml) is true
+// if parg begins with '--' then parg and pval must match exactly (i.e. must_match_length is set to -1)
 bool is_dash_arg_prefix(const char * parg, const char * pval, int must_match_length = 0);
+
+// return true if parg with '-' or '--' and is_arg_colon_prefix(parg,pval,ppc,mml) is true
+// if parg begins with '--' then parg and pval must match exactly (i.e. must_match_length is set to -1)
+bool is_dash_arg_colon_prefix(const char * parg, const char * pval, const char ** ppcolon, int must_match_length = 0);
+
--- a/src/condor_utils/match_prefix.cpp
+++ b/src/condor_utils/match_prefix.cpp
@@ -92,3 +92,14 @@ is_dash_arg_prefix(const char * parg, const char * pval, int must_match_length /
 	return is_arg_prefix(parg, pval, must_match_length);
 }
 
+bool
+is_dash_arg_colon_prefix(const char * parg, const char * pval, const char ** ppcolon, int must_match_length /*= 0*/)
+{
+	if (*parg != '-') return false;
+	++parg;
+	// if arg begins with --, then we require an exact match for pval.
+	if (*parg == '-') { ++parg; must_match_length = -1; }
+	return is_arg_colon_prefix(parg, pval, ppcolon, must_match_length);
+}
+
+

	Modified   src/condor_job_router/job_router_tool.cpp
diff --git a/src/condor_job_router/job_router_tool.cpp b/src/condor_job_router/job_router_tool.cpp
index 34cc585..991c329 100644
--- a/src/condor_job_router/job_router_tool.cpp
+++ b/src/condor_job_router/job_router_tool.cpp
@@ -67,7 +67,8 @@ usage(int retval = 1)
 		"\t-version\tPrint HTCondor version and exit\n"
 		"\t-config\t\tPrint configured routes\n"
 		"\t-match-jobs\tMatch jobs to routes and print the first match\n"
-		"\t-job-ads <file>\tWhen operation requires job ClassAds, Read them from <file>\n"
+		"\t-ignore-prior-routing\tRemove routing attributes from the job ClassAd and set JobStatus to IDLE before matching\n"
+		"\t-jobads <file>\tWhen operation requires job ClassAds, Read them from <file>\n\t\t\tIf <file> is -, read from stdin\n"
 		"\n"
 		);
 	my_exit(retval);
@@ -136,6 +137,7 @@ int main(int argc, const char *argv[])
 	bool dash_match_jobs = false;
 	bool dash_diagnostic = false;
 	bool dash_d_always = true;
+	bool dash_ignore_prior_routing = false;
 	//bool dash_d_fulldebug = false;
 
 	g_jobs = new classad::ClassAdCollection();
@@ -159,8 +161,10 @@ int main(int argc, const char *argv[])
 			dash_config = true;
 		} else if (is_dash_arg_prefix(argv[i], "match-jobs", 2)) {
 			dash_match_jobs = true;
-		} else if (is_dash_arg_prefix(argv[i], "job-ads", 1)) {
-			const char * filename = use_next_arg("job-ads", argv, i);
+		} else if (is_dash_arg_prefix(argv[i], "ignore-prior-routing", 2)) {
+			dash_ignore_prior_routing = true;
+		} else if (is_dash_arg_prefix(argv[i], "jobads", 1)) {
+			const char * filename = use_next_arg("jobads", argv, i);
 			job_files.append(filename);
 		} else if (*argv[i] != '-') {
 			// arguments that don't begin with "-" are bare arguments
@@ -205,10 +209,27 @@ int main(int argc, const char *argv[])
 		job_files.rewind();
 		const char * filename;
 		while ((filename = job_files.next())) {
-			 read_classad_file(filename, *g_jobs, NULL);
+			read_classad_file(filename, *g_jobs, NULL);
 		}
 	}
 
+	if (dash_ignore_prior_routing) {
+		// strip attributes that indicate that the job has already been routed
+		std::string key;
+		classad::LocalCollectionQuery query;
+		query.Bind(g_jobs);
+		query.Query("root");
+		query.ToFirst();
+		if (query.Current(key)) do {
+			classad::ClassAd *ad = g_jobs->GetClassAd(key);
+			ad->Delete("Managed");
+			ad->Delete("RoutedBy");
+			ad->Delete("StageInStart");
+			ad->Delete("StageInFinish");
+			ad->InsertAttr("JobStatus", 1); // pretend job is idle so that it will route.
+		} while (query.Next(key));
+	}
+
 	if (dash_match_jobs) {
 		fprintf(stdout, "\nMatching jobs against routes to find candidate jobs.\n");
 		const classad::View *root_view = g_jobs->GetView("root");
@@ -300,7 +321,14 @@ static bool read_classad_file(const char *filename, classad::ClassAdCollection &
 {
 	bool success = false;
 
-	FILE* file = safe_fopen_wrapper_follow(filename, "r");
+	FILE* file = NULL;
+	bool  read_from_stdin = false;
+	if (MATCH == strcmp(filename, "-")) {
+		read_from_stdin = true;
+		file = stdin;
+	} else {
+		file = safe_fopen_wrapper_follow(filename, "r");
+	}
 	if (file == NULL) {
 		fprintf(stderr, "Can't open file of job ads: %s\n", filename);
 		return false;
@@ -350,7 +378,7 @@ static bool read_classad_file(const char *filename, classad::ClassAdCollection &
 			}
 		}
 
-		fclose(file);
+		if ( ! read_from_stdin) { fclose(file); }
 	}
 	return success;
 }

