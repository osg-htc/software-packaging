diff --git a/src/condor_job_router/CMakeLists.txt b/src/condor_job_router/CMakeLists.txt
index 49a2415..382d0b0 100644
--- a/src/condor_job_router/CMakeLists.txt
+++ b/src/condor_job_router/CMakeLists.txt
@@ -19,10 +19,12 @@
 
 if (NOT WIN_EXEC_NODE_ONLY)
 
-	condor_glob(JRHdrs JRSrcs "VanillaToGrid_main.cpp")
+	condor_glob(JRHdrs JRSrcs "VanillaToGrid_main.cpp;job_router_tool.cpp")
 
 	condor_exe( condor_job_router "${JRHdrs};${JRSrcs}" ${C_LIBEXEC} "${CONDOR_LIBS}" OFF )
 
+	condor_exe( condor_job_router_tool "job_router_tool.cpp;JobRouter.cpp;VanillaToGrid.cpp" ${C_BIN} "${CONDOR_TOOL_LIBS}" OFF)
+
 	if (WINDOWS)
 
 			# windows install requires scripts have the correct extension in order 
	Modified   src/condor_job_router/JobRouter.cpp
diff --git a/src/condor_job_router/JobRouter.cpp b/src/condor_job_router/JobRouter.cpp
index d276a38..7024a0c 100644
--- a/src/condor_job_router/JobRouter.cpp
+++ b/src/condor_job_router/JobRouter.cpp
@@ -61,7 +61,10 @@ const char JR_ATTR_EDIT_JOB_IN_PLACE[] = "EditJobInPlace";
 
 const int THROTTLE_UPDATE_INTERVAL = 600;
 
-JobRouter::JobRouter(): m_jobs(5000,hashFuncStdString,rejectDuplicateKeys) {
+JobRouter::JobRouter(bool as_tool)
+	: m_jobs(5000,hashFuncStdString,rejectDuplicateKeys)
+	, m_operate_as_tool(as_tool)
+{
 	m_scheduler = NULL;
 	m_scheduler2 = NULL;
 	m_release_on_hold = true;
@@ -119,7 +122,7 @@ JobRouter::~JobRouter() {
 		delete m_hook_mgr;
 	}
 #endif
-	InvalidatePublicAd();
+	if ( ! m_operate_as_tool) { InvalidatePublicAd(); }
 
 	m_scheduler->stop();
 	delete m_scheduler;
@@ -138,7 +141,7 @@ JobRouter::init() {
 	m_hook_mgr->initialize();
 #endif
 	config();
-	GetInstanceLock();
+	if ( ! m_operate_as_tool) { GetInstanceLock(); }
 }
 
 void
@@ -177,8 +180,7 @@ JobRouter::config() {
 	m_enable_job_routing = true;
 
 	if( !m_scheduler ) {
-		NewClassAdJobLogConsumer *log_consumer = new NewClassAdJobLogConsumer();
-		m_scheduler = new Scheduler(log_consumer,"JOB_ROUTER_SCHEDD1_SPOOL");
+		m_scheduler = new Scheduler("JOB_ROUTER_SCHEDD1_SPOOL");
 		m_scheduler->init();
 	}
 
@@ -187,8 +189,7 @@ JobRouter::config() {
 		if( !m_scheduler2 ) {
 				// schedd2_spool is configured, but we have no schedd2, so create it
 			dprintf(D_ALWAYS,"Reading destination schedd spool %s\n",spool2.c_str());
-			NewClassAdJobLogConsumer *log_consumer2 = new NewClassAdJobLogConsumer();
-			m_scheduler2 = new Scheduler(log_consumer2,"JOB_ROUTER_SCHEDD2_SPOOL");
+			m_scheduler2 = new Scheduler("JOB_ROUTER_SCHEDD2_SPOOL");
 			m_scheduler2->init();
 		}
 	}
@@ -354,29 +355,31 @@ JobRouter::config() {
 	m_job_router_polling_period = param_integer("JOB_ROUTER_POLLING_PERIOD",10);
 
 		// clear previous timers
-	if (m_job_router_polling_timer >= 0) {
-		daemonCore->Cancel_Timer(m_job_router_polling_timer);
-	}
-	if (m_periodic_timer_id >= 0) {
-		daemonCore->Cancel_Timer(m_periodic_timer_id);
-	}
-		// register timer handlers
-	m_job_router_polling_timer = daemonCore->Register_Timer(
-								  0, 
-								  m_job_router_polling_period,
-								  (TimerHandlercpp)&JobRouter::Poll, 
-								  "JobRouter::Poll", this);
-
-	if (periodic_interval.getMinInterval() > 0) {
-		m_periodic_timer_id = daemonCore->Register_Timer(periodic_interval, 
-								(TimerHandlercpp)&JobRouter::EvalAllSrcJobPeriodicExprs,
-								"JobRouter::EvalAllSrcJobPeriodicExprs",
-								this);
-		dprintf(D_FULLDEBUG, "JobRouter: Registered EvalAllSrcJobPeriodicExprs() to evaluate periodic expressions.\n");
-	}
-	else {
-		dprintf(D_FULLDEBUG, "JobRouter: Evaluation of periodic expressions disabled.\n");
-	}
+	if ( ! m_operate_as_tool) {
+		if (m_job_router_polling_timer >= 0) {
+			daemonCore->Cancel_Timer(m_job_router_polling_timer);
+		}
+		if (m_periodic_timer_id >= 0) {
+			daemonCore->Cancel_Timer(m_periodic_timer_id);
+		}
+			// register timer handlers
+		m_job_router_polling_timer = daemonCore->Register_Timer(
+										0,
+										m_job_router_polling_period,
+										(TimerHandlercpp)&JobRouter::Poll,
+										"JobRouter::Poll", this);
+
+		if (periodic_interval.getMinInterval() > 0) {
+			m_periodic_timer_id = daemonCore->Register_Timer(periodic_interval, 
+									(TimerHandlercpp)&JobRouter::EvalAllSrcJobPeriodicExprs,
+									"JobRouter::EvalAllSrcJobPeriodicExprs",
+									this);
+			dprintf(D_FULLDEBUG, "JobRouter: Registered EvalAllSrcJobPeriodicExprs() to evaluate periodic expressions.\n");
+		}
+		else {
+			dprintf(D_FULLDEBUG, "JobRouter: Evaluation of periodic expressions disabled.\n");
+		}
+	} // ! m_operate_as_tool
 
 		// NOTE: if you change the default name, then you are breaking
 		// JobRouter's ability to adopt jobs ("orphans") left behind
@@ -390,25 +393,27 @@ JobRouter::config() {
 		EXCEPT("JOB_ROUTER_NAME must not be empty");
 	}
 
-	InitPublicAd();
+	if ( ! m_operate_as_tool) {
+		InitPublicAd();
 
-	int update_interval = param_integer("UPDATE_INTERVAL", 60);
-	if(m_public_ad_update_interval != update_interval) {
-		m_public_ad_update_interval = update_interval;
+		int update_interval = param_integer("UPDATE_INTERVAL", 60);
+		if(m_public_ad_update_interval != update_interval) {
+			m_public_ad_update_interval = update_interval;
 
-		if(m_public_ad_update_timer >= 0) {
-			daemonCore->Cancel_Timer(m_public_ad_update_timer);
-			m_public_ad_update_timer = -1;
+			if(m_public_ad_update_timer >= 0) {
+				daemonCore->Cancel_Timer(m_public_ad_update_timer);
+				m_public_ad_update_timer = -1;
+			}
+			dprintf(D_FULLDEBUG, "Setting update interval to %d\n",
+				m_public_ad_update_interval);
+			m_public_ad_update_timer = daemonCore->Register_Timer(
+				0,
+				m_public_ad_update_interval,
+				(TimerHandlercpp)&JobRouter::TimerHandler_UpdateCollector,
+				"JobRouter::TimerHandler_UpdateCollector",
+				this);
 		}
-		dprintf(D_FULLDEBUG, "Setting update interval to %d\n",
-			m_public_ad_update_interval);
-		m_public_ad_update_timer = daemonCore->Register_Timer(
-			0,
-			m_public_ad_update_interval,
-			(TimerHandlercpp)&JobRouter::TimerHandler_UpdateCollector,
-			"JobRouter::TimerHandler_UpdateCollector",
-			this);
-	}
+	} // ! m_operate_as_tool
 
 	param(m_schedd2_name_buf,"JOB_ROUTER_SCHEDD2_NAME");
 	param(m_schedd2_pool_buf,"JOB_ROUTER_SCHEDD2_POOL");
@@ -429,6 +434,54 @@ JobRouter::config() {
 	}
 }
 
+void JobRouter::dump_routes(FILE* hf) // dump the routing information to the given file.
+{
+	int ixRoute = 1;
+	JobRoute *route;
+	m_routes->startIterations();
+	while(m_routes->iterate(route)) {
+		/*
+		classad::ClassAd *RouteAd() {return &m_route_ad;}
+		char const *Name() {return m_name.c_str();}
+		int MaxJobs() {return m_max_jobs;}
+		int MaxIdleJobs() {return m_max_idle_jobs;}
+		int CurrentRoutedJobs() {return m_num_jobs;}
+		int TargetUniverse() {return m_target_universe;}
+		char const *GridResource() {return m_grid_resource.c_str();}
+		classad::ExprTree *RouteRequirementExpr() {return m_route_requirements;}
+		char const *RouteRequirementsString() {return m_route_requirements_str.c_str();}
+		std::string RouteString(); // returns a string describing the route
+		*/
+		fprintf(hf, "Route %d\n", ixRoute);
+		fprintf(hf, "Name         : \"%s\"\n", route->Name());
+		fprintf(hf, "Universe     : %d\n", route->TargetUniverse());
+		//fprintf(hf, "RoutedJobs   : %d\n", route->CurrentRoutedJobs());
+		fprintf(hf, "MaxJobs      : %d\n", route->MaxJobs());
+		fprintf(hf, "MaxIdleJobs  : %d\n", route->MaxIdleJobs());
+		fprintf(hf, "GridResource : %s\n", route->GridResource());
+		fprintf(hf, "Requirements : %s\n", route->RouteRequirementsString());
+
+		fprintf(hf, "ClassAd      : ");
+		std::string route_ad_string;
+		if (route->RouteStringPretty(route_ad_string)) {
+			fprintf(hf, "%s", route_ad_string.c_str());
+		}
+		fprintf(hf, "\n");
+
+		fprintf(hf, "\n");
+		++ixRoute;
+	}
+}
+
+
+void
+JobRouter::set_schedds(Scheduler* schedd, Scheduler* schedd2)
+{
+	ASSERT(m_operate_as_tool);
+	m_scheduler = schedd;
+	m_scheduler2 = schedd2;
+}
+
 classad::ClassAdCollection *
 JobRouter::GetSchedd1ClassAds() {
 	return m_scheduler->GetClassAds();
@@ -441,6 +494,7 @@ JobRouter::GetSchedd2ClassAds() {
 void
 JobRouter::InitPublicAd()
 {
+	ASSERT( ! m_operate_as_tool);
 	ASSERT (m_job_router_name.size() > 0);
 
 	char *valid_name = build_valid_daemon_name(m_job_router_name.c_str());
@@ -1160,7 +1214,7 @@ JobRouter::GetCandidateJobs() {
 	umbrella_constraint += m_job_router_name;
 	umbrella_constraint += "\")";
 
-	if(!can_switch_ids()) {
+	if (m_operate_as_tool || !can_switch_ids()) {
 			// We are not running as root.  Ensure that we only try to
 			// manage jobs submitted by the same user we are running as.
 
@@ -1202,6 +1256,7 @@ JobRouter::GetCandidateJobs() {
 	}
 	delete constraint_tree;
 
+	int cJobsAdded = 0;
     query.ToFirst();
     if( query.Current(key) ) do {
 		if(!AcceptingMoreJobs()) {
@@ -1249,8 +1304,13 @@ JobRouter::GetCandidateJobs() {
 
 		dprintf(D_FULLDEBUG,"JobRouter (%s): found candidate job\n",job->JobDesc().c_str());
 		AddJob(job);
+		++cJobsAdded;
 
     } while (query.Next(key));
+
+	if (m_operate_as_tool) {
+		dprintf(D_ALWAYS, "JobRouter: %d candidate jobs found\n", cJobsAdded);
+	}
 }
 
 JobRoute *
@@ -2253,6 +2313,8 @@ JobRouter::InvalidatePublicAd() {
 	ClassAd invalidate_ad;
 	MyString line;
 
+	ASSERT( ! m_operate_as_tool);
+
 	SetMyTypeName(invalidate_ad, QUERY_ADTYPE);
 	SetTargetTypeName(invalidate_ad, "Job_Router");
 
@@ -2441,6 +2503,14 @@ JobRoute::RouteString() {
 	return route_string;
 }
 
+bool JobRoute::RouteStringPretty(std::string & str) {
+	if (m_route_ad.size() <= 0)
+		return false;
+	classad::PrettyPrint unparser;
+	unparser.Unparse(str, &m_route_ad);
+	return !str.empty();
+}
+
 bool
 JobRoute::ParseClassAd(std::string routing_string,int &offset,classad::ClassAd const *router_defaults_ad,bool allow_empty_requirements) {
 	classad::ClassAdParser parser;
	Modified   src/condor_job_router/JobRouter.h
diff --git a/src/condor_job_router/JobRouter.h b/src/condor_job_router/JobRouter.h
index 15ba57c..d4dee66 100644
--- a/src/condor_job_router/JobRouter.h
+++ b/src/condor_job_router/JobRouter.h
@@ -46,7 +46,7 @@ typedef HashTable<std::string,JobRoute *> RoutingTable;
 
 class JobRouter: public Service {
  public:
-	JobRouter();
+	JobRouter(bool as_tool=false);
 	virtual ~JobRouter();
 
 	// Add a new job to be managed by JobRouter.
@@ -72,6 +72,8 @@ class JobRouter: public Service {
 	void EvalAllSrcJobPeriodicExprs();
 
 	void config();
+	void set_schedds(Scheduler* schedd, Scheduler* schedd2); // let the tool mode push simulated schedulers
+	void dump_routes(FILE* hf); // dump the routing information to the given file.
 	void init();
 
 	//The JobRouter name is used to distinguish this daemon from
@@ -156,6 +158,8 @@ class JobRouter: public Service {
 
 	ClassAd m_public_ad;
 
+	bool m_operate_as_tool;
+
 	// Count jobs being managed.  (Excludes RETIRED jobs.)
 	int NumManagedJobs();
 
@@ -165,8 +169,10 @@ class JobRouter: public Service {
 	// the source schedd.
 	bool RemoveJob(RoutedJob *job);
 
+public:
 	// Find jobs to route.  Function calls AddJob() on each one.
 	void GetCandidateJobs();
+private:
 
 	// Resume management of any jobs we were routing in a previous life.
 	void AdoptOrphans();
	Modified   src/condor_job_router/RoutedJob.h
diff --git a/src/condor_job_router/RoutedJob.h b/src/condor_job_router/RoutedJob.h
index 21ac89f..a6ab634 100644
--- a/src/condor_job_router/RoutedJob.h
+++ b/src/condor_job_router/RoutedJob.h
@@ -101,6 +101,7 @@ class JobRoute {
 	classad::ExprTree *RouteRequirementExpr() {return m_route_requirements;}
 	char const *RouteRequirementsString() {return m_route_requirements_str.c_str();}
 	std::string RouteString(); // returns a string describing the route
+	bool RouteStringPretty(std::string & str); // prints the route classad into str
 
 	// copy state from another route
 	void CopyState(JobRoute *route);
	Modified   src/condor_job_router/Scheduler.h
diff --git a/src/condor_job_router/Scheduler.h b/src/condor_job_router/Scheduler.h
index 3fe0d43..dfce764 100644
--- a/src/condor_job_router/Scheduler.h
+++ b/src/condor_job_router/Scheduler.h
@@ -22,6 +22,27 @@
 
 #include "condor_common.h"
 
+#if 1
+
+class JobLogMirror;
+class NewClassAdJobLogConsumer;
+class Scheduler {
+public:
+	Scheduler(char const *_alt_spool_param=NULL, int id=0);
+	~Scheduler();
+	classad::ClassAdCollection *GetClassAds();
+	void init();
+	void config();
+	void stop();
+	int id();
+
+private:
+
+	NewClassAdJobLogConsumer * m_consumer;
+	JobLogMirror * m_mirror;
+	int m_id; // id of this instance
+};
+#else
 #include "JobLogMirror.h"
 #include "NewClassAdJobLogConsumer.h"
 
@@ -40,5 +61,6 @@ public:
 private:
 	NewClassAdJobLogConsumer *m_consumer;
 };
+#endif
 
 #endif
	New        src/condor_job_router/job_router_tool.cpp
diff --git a/src/condor_job_router/job_router_tool.cpp b/src/condor_job_router/job_router_tool.cpp
new file mode 100644
index 0000000..e699259
--- /dev/null
+++ b/src/condor_job_router/job_router_tool.cpp
@@ -0,0 +1,573 @@
+/***************************************************************
+ *
+ * Copyright (C) 1990-2007, Condor Team, Computer Sciences Department,
+ * University of Wisconsin-Madison, WI.
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you
+ * may not use this file except in compliance with the License.  You may
+ * obtain a copy of the License at
+ * 
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ ***************************************************************/
+
+#include "condor_common.h"
+//#include "condor_daemon_core.h"
+#include "condor_debug.h"
+#include "condor_config.h"
+#include "subsystem_info.h"
+#include "match_prefix.h"
+#include "condor_distribution.h"
+#include "write_user_log.h"
+#include "dprintf_internal.h" // for dprintf_set_outputs
+#include "condor_version.h"
+
+#include "Scheduler.h"
+#include "JobRouter.h"
+#include "submit_job.h"
+
+#ifdef __GNUC__
+#if __GNUC__ >= 4
+  #pragma GCC diagnostic ignored "-Wunused-parameter"
+  #pragma GCC diagnostic ignored "-Wunused-variable"
+  #pragma GCC diagnostic ignored "-Wunused-value"
+#endif
+#endif
+
+
+//JobRouter *job_router = NULL;
+
+//-------------------------------------------------------------
+const char * MyName = NULL;
+classad::ClassAdCollection * g_jobs = NULL;
+
+static bool read_classad_file(const char *filename, classad::ClassAdCollection &classads, const char * constr);
+
+void PREFAST_NORETURN
+my_exit( int status )
+{
+	fflush(stdout);
+	fflush(stderr);
+	exit(status);
+}
+
+void
+usage(int retval = 1)
+{
+	fprintf(stderr, "Usage: %s [options]\n", MyName);
+	fprintf(stderr,
+		"    where [options] is one or more of:\n"
+		"\t-help\t\tPrint this screen and exit\n"
+		"\t-version\tPrint HTCondor version and exit\n"
+		"\t-config\t\tPrint configured routes\n"
+		"\t-match-jobs\tMatch jobs to routes and print the first match\n"
+		"\t-job-ads <file>\tWhen operation requires job ClassAds, Read them from <file>\n"
+		"\n"
+		);
+	my_exit(retval);
+}
+
+static const char * use_next_arg(const char * arg, const char * argv[], int & i)
+{
+	if (argv[i+1]) {
+		return argv[++i];
+	}
+
+	fprintf(stderr, "-%s requires an argument\n", arg);
+	//usage(1);
+	my_exit(1);
+	return NULL;
+}
+
+bool g_silence_dprintf = false;
+void _dprintf_intercept(int cat_and_flags, int hdr_flags, DebugHeaderInfo & info, const char* message, DebugFileInfo* dbgInfo)
+{
+	//if (cat_and_flags & D_FULLDEBUG) return;
+	if (g_silence_dprintf) return;
+	if (is_arg_prefix("JobRouter", message, 9)) { message += 9; if (*message == ':') ++message; if (*message == ' ') ++message; }
+	int cch = strlen(message);
+	fprintf(stdout, &"\n%s"[(cch > 150) ? 0 : 1], message);
+}
+
+static void dprintf_set_output_intercept (
+	int cat_and_flags,
+	DebugOutputChoice choice,
+	DprintfFuncPtr fn)
+{
+
+	dprintf_output_settings my_output;
+	my_output.choice = choice;
+	my_output.accepts_all = true;
+	my_output.logPath = ">BUFFER";	// this is a special case of intercept
+	my_output.HeaderOpts = (cat_and_flags & ~(D_CATEGORY_RESERVED_MASK | D_FULLDEBUG | D_VERBOSE_MASK));
+	my_output.VerboseCats = (cat_and_flags & (D_FULLDEBUG | D_VERBOSE_MASK)) ? choice : 0;
+	dprintf_set_outputs(&my_output, 1);
+
+	// throw away any dprintf messages up to this point.
+	bool was_silent = g_silence_dprintf;
+	g_silence_dprintf = true;
+	dprintf_WriteOnErrorBuffer(NULL, true);
+	g_silence_dprintf = was_silent;
+
+	// PRAGMA_REMIND("tj: fix this hack when the dprintf code has a proper way to register an intercept.")
+	// HACK!!! there is no properly exposed way to set an intercept function, so for now, we reach into
+	// the dprintf internal data structures and just set one. 
+	extern std::vector<DebugFileInfo> * DebugLogs;
+	if (DebugLogs) { (*DebugLogs)[0].dprintfFunc = fn; }
+}
+
+
+int main(int argc, const char *argv[])
+{
+	MyName = argv[0];
+    myDistro->Init( argc, argv );
+	config();
+	set_mySubSystem("TOOL", SUBSYSTEM_TYPE_TOOL);
+
+	StringList bare_args;
+	StringList job_files;
+	bool dash_config = false;
+	bool dash_match_jobs = false;
+	bool dash_diagnostic = false;
+	bool dash_d_always = true;
+	//bool dash_d_fulldebug = false;
+
+	g_jobs = new classad::ClassAdCollection();
+
+	for (int i = 1; i < argc; ++i) {
+
+		const char * pcolon = NULL;
+		if (is_dash_arg_prefix(argv[i], "help", 1)) {
+			usage(0);
+		} else if (is_dash_arg_prefix(argv[i], "version", 1)) {
+			printf( "%s\n%s\n", CondorVersion(), CondorPlatform() );
+			my_exit(0);
+		} else if (is_dash_arg_colon_prefix(argv[i], "debug", &pcolon, 1)) {
+			dash_d_always = true;
+			if (pcolon && (is_arg_prefix(pcolon+1, "verbose", 1) || is_arg_prefix(pcolon+1, "full", 1))) {
+				//dash_d_fulldebug = true;
+			}
+		} else if (is_dash_arg_colon_prefix(argv[i], "diagnostic", &pcolon, 4)) {
+			dash_diagnostic = true;
+		} else if (is_dash_arg_prefix(argv[i], "config", 2)) {
+			dash_config = true;
+		} else if (is_dash_arg_prefix(argv[i], "match-jobs", 2)) {
+			dash_match_jobs = true;
+		} else if (is_dash_arg_prefix(argv[i], "job-ads", 1)) {
+			const char * filename = use_next_arg("job-ads", argv, i);
+			job_files.append(filename);
+		} else if (*argv[i] != '-') {
+			// arguments that don't begin with "-" are bare arguments
+			bare_args.append(argv[i]);
+			continue;
+		} else {
+			fprintf(stderr, "ERROR: %s is not a valid argument\n", argv[i]);
+			usage(1);
+		}
+	}
+
+
+	// tell the dprintf code to had messages to our callback function.
+	unsigned int cat_and_flags = D_FULLDEBUG | D_CAT;
+	//if (dash_d_fulldebug) { cat_and_flags |= D_FULLDEBUG; }
+	DebugOutputChoice choice=1<<D_ERROR;
+	if (dash_d_always || dash_diagnostic) { choice |= 1<<D_ALWAYS; }
+	dprintf_set_output_intercept(cat_and_flags, choice, _dprintf_intercept);
+
+
+	// before we call init() for the router, we need to install a pseudo-schedd object
+	// so that init() doesn't install a real schedd object.
+	Scheduler* schedd = new Scheduler("JOB_ROUTER_SCHEDD1_SPOOL");
+	Scheduler* schedd2 = NULL;
+	std::string spool2;
+	if (param(spool2, "JOB_ROUTER_SCHEDD2_SPOOL")) {
+		schedd2 = new Scheduler("JOB_ROUTER_SCHEDD2_SPOOL");
+	}
+
+	g_silence_dprintf = dash_diagnostic ? false : true;
+	JobRouter job_router(true);
+	job_router.set_schedds(schedd, schedd2);
+	job_router.init();
+	g_silence_dprintf = false;
+
+	if (dash_config) {
+		fprintf (stdout, "\n\n");
+		job_router.dump_routes(stdout);
+	}
+
+	if ( ! job_files.isEmpty()) {
+		job_files.rewind();
+		const char * filename;
+		while ((filename = job_files.next())) {
+			 read_classad_file(filename, *g_jobs, NULL);
+		}
+	}
+
+	if (dash_match_jobs) {
+		fprintf(stdout, "\nMatching jobs against routes to find candidate jobs.\n");
+		const classad::View *root_view = g_jobs->GetView("root");
+		if (root_view && (root_view->begin() != root_view->end())) {
+			job_router.GetCandidateJobs();
+		} else {
+			fprintf(stdout, "There are no jobs to match\n");
+		}
+	}
+
+	return 0;
+}
+
+class CondorQClassAdFileParseHelper : public compat_classad::ClassAdFileParseHelper
+{
+ public:
+	virtual int PreParse(std::string & line, ClassAd & ad, FILE* file);
+	virtual int OnParseError(std::string & line, ClassAd & ad, FILE* file);
+	std::string schedd_name;
+	std::string schedd_addr;
+};
+
+// this method is called before each line is parsed. 
+// return 0 to skip (is_comment), 1 to parse line, 2 for end-of-classad, -1 for abort
+int CondorQClassAdFileParseHelper::PreParse(std::string & line, ClassAd & /*ad*/, FILE* /*file*/)
+{
+	// treat blank lines as delimiters.
+	if (line.size() <= 0) {
+		return 2; // end of classad.
+	}
+
+	// standard delimitors are ... and ***
+	if (starts_with(line,"\n") || starts_with(line,"...") || starts_with(line,"***")) {
+		return 2; // end of classad.
+	}
+
+	// the normal output of condor_q -long is "-- schedd-name <addr>"
+	// we want to treat that as a delimiter, and also capture the schedd name and addr
+	if (starts_with(line, "-- ")) {
+		if (starts_with(line.substr(3), "Schedd:")) {
+			schedd_name = line.substr(3+8);
+			size_t ix1 = schedd_name.find_first_of(": \t\n");
+			if (ix1 != std::string::npos) {
+				size_t ix2 = schedd_name.find_first_not_of(": \t\n", ix1);
+				if (ix2 != std::string::npos) {
+					schedd_addr = schedd_name.substr(ix2);
+					ix2 = schedd_addr.find_first_of(" \t\n");
+					if (ix2 != std::string::npos) {
+						schedd_addr = schedd_addr.substr(0,ix2);
+					}
+				}
+				schedd_name = schedd_name.substr(0,ix1);
+			}
+		}
+		return 2;
+	}
+
+
+	// check for blank lines or lines whose first character is #
+	// tell the parser to skip those lines, otherwise tell the parser to
+	// parse the line.
+	for (size_t ix = 0; ix < line.size(); ++ix) {
+		if (line[ix] == '#' || line[ix] == '\n')
+			return 0; // skip this line, but don't stop parsing.
+		if (line[ix] != ' ' && line[ix] != '\t')
+			break;
+	}
+	return 1; // parse this line
+}
+
+// this method is called when the parser encounters an error
+// return 0 to skip and continue, 1 to re-parse line, 2 to quit parsing with success, -1 to abort parsing.
+int CondorQClassAdFileParseHelper::OnParseError(std::string & line, ClassAd & ad, FILE* file)
+{
+	// when we get a parse error, skip ahead to the start of the next classad.
+	int ee = this->PreParse(line, ad, file);
+	while (1 == ee) {
+		if ( ! readLine(line, file, false) || feof(file)) {
+			ee = 2;
+			break;
+		}
+		ee = this->PreParse(line, ad, file);
+	}
+	return ee;
+}
+
+// -----------------------------
+static bool read_classad_file(const char *filename, classad::ClassAdCollection &classads, const char * constr)
+{
+	bool success = false;
+
+	FILE* file = safe_fopen_wrapper_follow(filename, "r");
+	if (file == NULL) {
+		fprintf(stderr, "Can't open file of job ads: %s\n", filename);
+		return false;
+	} else {
+		// this helps us parse the output of condor_q -long
+		CondorQClassAdFileParseHelper parse_helper;
+
+		for (;;) {
+			ClassAd* classad = new ClassAd();
+
+			int error;
+			bool is_eof;
+			int cAttrs = classad->InsertFromFile(file, is_eof, error, &parse_helper);
+
+			bool include_classad = cAttrs > 0 && error >= 0;
+			if (include_classad && constr) {
+				classad::Value val;
+				if (classad->EvaluateExpr(constr,val)) {
+					if ( ! val.IsBooleanValueEquiv(include_classad)) {
+						include_classad = false;
+					}
+				}
+			}
+			if (include_classad) {
+				int cluster, proc = -1;
+				if (classad->LookupInteger(ATTR_CLUSTER_ID, cluster) && classad->LookupInteger(ATTR_PROC_ID, proc)) {
+					std::string key;
+					formatstr(key, "%d,%d", cluster, proc);
+					if (classads.AddClassAd(key, classad)) {
+						classad = NULL; // this is now owned by the collection.
+					}
+				} else {
+					fprintf(stderr, "Skipping ad because it doesn't have a ClusterId and/or ProcId attribute\n");
+				}
+			}
+			if (classad) {
+				delete classad;
+			}
+
+			if (is_eof) {
+				success = true;
+				break;
+			}
+			if (error < 0) {
+				success = false;
+				break;
+			}
+		}
+
+		fclose(file);
+	}
+	return success;
+}
+
+
+// this is how we will feed job ad's into the router
+//
+class JobLogMirror {
+public:
+	JobLogMirror(char const *spool_param=NULL) {}
+	~JobLogMirror() {}
+
+	void init() {}
+	void config() {}
+	void stop() {}
+
+private:
+};
+
+Scheduler::Scheduler(char const *_alt_spool_param /*=NULL*/, int id /*=0*/)
+	: m_consumer(NULL)
+	, m_mirror(NULL)
+	, m_id(id)
+{ 
+}
+
+Scheduler::~Scheduler()
+{
+	delete m_mirror;
+	m_mirror = NULL;
+	m_consumer = NULL;
+}
+
+classad::ClassAdCollection *Scheduler::GetClassAds()
+{
+	if (m_id == 0) {
+		return g_jobs;
+	}
+	return NULL;
+}
+
+void Scheduler::init() {  m_mirror->init(); }
+void Scheduler::config() { m_mirror->config(); }
+void Scheduler::stop()  { m_mirror->stop(); }
+int  Scheduler::id() { return m_id; }
+
+
+// needed by JobRouter
+unsigned int hashFuncStdString( std::string const & key)
+{
+    return hashFuncChars(key.c_str());
+}
+
+// 
+JobRouterHookMgr::JobRouterHookMgr() : HookClientMgr(), NUM_HOOKS(0), UNDEFINED("UNDEFINED"), m_hook_paths(MyStringHash) {}
+JobRouterHookMgr::~JobRouterHookMgr() {};
+bool JobRouterHookMgr::initialize() { reconfig(); return true; /*HookClientMgr::initialize()*/; }
+bool JobRouterHookMgr::reconfig() { m_default_hook_keyword = param("JOB_ROUTER_HOOK_KEYWORD"); return true; }
+
+int JobRouterHookMgr::hookTranslateJob(RoutedJob* r_job, std::string &route_info) { return 1; }
+int JobRouterHookMgr::hookUpdateJobInfo(RoutedJob* r_job) { return 1; }
+int JobRouterHookMgr::hookJobExit(RoutedJob* r_job) { return 1; }
+int JobRouterHookMgr::hookJobCleanup(RoutedJob* r_job) { return 1; }
+
+std::string
+JobRouterHookMgr::getHookKeyword(classad::ClassAd ad)
+{
+	std::string hook_keyword;
+
+	if (false == ad.EvaluateAttrString(ATTR_HOOK_KEYWORD, hook_keyword))
+	{
+		if ( m_default_hook_keyword ) {
+			hook_keyword = m_default_hook_keyword;
+		}
+	}
+	return hook_keyword;
+}
+
+
+
+
+ClaimJobResult claim_job(int cluster, int proc, MyString * error_details, const char * my_identity)
+{
+	return CJR_OK;
+}
+
+
+
+ClaimJobResult claim_job(classad::ClassAd const &ad, const char * pool_name, const char * schedd_name, int cluster, int proc, MyString * error_details, const char * my_identity, bool target_is_sandboxed)
+{
+	return CJR_OK;
+}
+
+bool yield_job(bool done, int cluster, int proc, classad::ClassAd const &job_ad, MyString * error_details, const char * my_identity, bool target_is_sandboxed, bool release_on_hold, bool *keep_trying) {
+	return true;
+}
+
+
+bool yield_job(classad::ClassAd const &ad,const char * pool_name,
+	const char * schedd_name, bool done, int cluster, int proc,
+	MyString * error_details, const char * my_identity, bool target_is_sandboxed,
+        bool release_on_hold, bool *keep_trying)
+{
+	return true;
+}
+
+bool submit_job( ClassAd & src, const char * schedd_name, const char * pool_name, bool is_sandboxed, int * cluster_out /*= 0*/, int * proc_out /*= 0 */)
+{
+	return true;
+}
+
+bool submit_job( classad::ClassAd & src, const char * schedd_name, const char * pool_name, bool is_sandboxed, int * cluster_out /*= 0*/, int * proc_out /*= 0 */)
+{
+	return true;
+}
+
+/*
+	Push the dirty attributes in src into the queue.  Does _not_ clear
+	the dirty attributes.
+	Assumes the existance of an open qmgr connection (via ConnectQ).
+*/
+bool push_dirty_attributes(classad::ClassAd & src)
+{
+	return true;
+}
+
+/*
+	Push the dirty attributes in src into the queue.  Does _not_ clear
+	the dirty attributes.
+	Establishes (and tears down) a qmgr connection.
+*/
+bool push_dirty_attributes(classad::ClassAd & src, const char * schedd_name, const char * pool_name)
+{
+	return true;
+}
+
+/*
+	Update src in the queue so that it ends up looking like dest.
+    This handles attribute deletion as well as change of value.
+	Assumes the existance of an open qmgr connection (via ConnectQ).
+*/
+bool push_classad_diff(classad::ClassAd & src,classad::ClassAd & dest)
+{
+	return true;
+}
+
+/*
+	Update src in the queue so that it ends up looking like dest.
+    This handles attribute deletion as well as change of value.
+	Establishes (and tears down) a qmgr connection.
+*/
+bool push_classad_diff(classad::ClassAd & src, classad::ClassAd & dest, const char * schedd_name, const char * pool_name)
+{
+	return true;
+}
+
+bool finalize_job(classad::ClassAd const &ad,int cluster, int proc, const char * schedd_name, const char * pool_name, bool is_sandboxed)
+{
+	return true;
+}
+
+bool remove_job(classad::ClassAd const &ad, int cluster, int proc, char const *reason, const char * schedd_name, const char * pool_name, MyString &error_desc)
+{
+	return true;
+}
+
+bool InitializeUserLog( classad::ClassAd const &job_ad, WriteUserLog *ulog, bool *no_ulog )
+{
+	return true;
+}
+
+bool InitializeAbortedEvent( JobAbortedEvent *event, classad::ClassAd const &job_ad )
+{
+	return true;
+}
+
+bool InitializeTerminateEvent( TerminatedEvent *event, classad::ClassAd const &job_ad )
+{
+	return true;
+}
+
+bool InitializeHoldEvent( JobHeldEvent *event, classad::ClassAd const &job_ad )
+{
+	return true;
+}
+
+bool WriteEventToUserLog( ULogEvent const &event, classad::ClassAd const &ad )
+{
+	return true;
+}
+
+bool WriteTerminateEventToUserLog( classad::ClassAd const &ad )
+{
+	return true;
+}
+
+bool WriteAbortEventToUserLog( classad::ClassAd const &ad )
+{
+	return true;
+}
+
+bool WriteHoldEventToUserLog( classad::ClassAd const &ad )
+{
+	return true;
+}
+
+
+
+// The following is copied from gridmanager/basejob.C
+// TODO: put the code into a shared file.
+
+void
+EmailTerminateEvent(ClassAd * job_ad, bool   /*exit_status_known*/)
+{
+}
+
+bool EmailTerminateEvent( classad::ClassAd const &ad )
+{
+	return true;
+}
	Modified   src/condor_job_router/schedd_main.cpp
diff --git a/src/condor_job_router/schedd_main.cpp b/src/condor_job_router/schedd_main.cpp
index 544b80f..c6c7eef 100644
--- a/src/condor_job_router/schedd_main.cpp
+++ b/src/condor_job_router/schedd_main.cpp
@@ -26,11 +26,39 @@
 #include "ClassAdLogReader.h"
 #include "Scheduler.h"
 #include "JobRouter.h"
+#include "JobLogMirror.h"
+#include "NewClassAdJobLogConsumer.h"
 
 
 JobRouter *job_router;
 
 //-------------------------------------------------------------
+Scheduler::Scheduler(char const *_alt_spool_param /*=NULL*/, int id /*=0*/)
+	: m_id(id)
+{
+	m_consumer = new NewClassAdJobLogConsumer();
+	m_mirror = new JobLogMirror(m_consumer, _alt_spool_param);
+}
+
+Scheduler::~Scheduler()
+{
+	delete m_mirror; // this has the side effect of deleting m_consumer.
+	m_mirror = NULL;
+	m_consumer = NULL;
+}
+
+classad::ClassAdCollection *Scheduler::GetClassAds()
+{
+	return m_consumer->GetClassAds();
+}
+
+void Scheduler::init() { m_mirror->init(); }
+void Scheduler::config() { m_mirror->config(); }
+void Scheduler::stop()  { m_mirror->stop(); }
+int  Scheduler::id() { return m_id; }
+
+
+//-------------------------------------------------------------
 
 void main_init(int   /*argc*/, char ** /*argv*/)
 {

--- a/src/condor_job_router/JobRouter.cpp
+++ b/src/condor_job_router/JobRouter.cpp
@@ -63,6 +63,10 @@ const int THROTTLE_UPDATE_INTERVAL = 600;
 
 JobRouter::JobRouter(bool as_tool)
 	: m_jobs(5000,hashFuncStdString,rejectDuplicateKeys)
+	, m_schedd2_name(NULL)
+	, m_schedd2_pool(NULL)
+	, m_schedd1_name(NULL)
+	, m_schedd1_pool(NULL)
 	, m_operate_as_tool(as_tool)
 {
 	m_scheduler = NULL;
	Modified   src/condor_job_router/job_router_tool.cpp
diff --git a/src/condor_job_router/job_router_tool.cpp b/src/condor_job_router/job_router_tool.cpp
index e699259..34cc585 100644
--- a/src/condor_job_router/job_router_tool.cpp
+++ b/src/condor_job_router/job_router_tool.cpp
@@ -405,7 +405,7 @@ unsigned int hashFuncStdString( std::string const & key)
 }
 
 // 
-JobRouterHookMgr::JobRouterHookMgr() : HookClientMgr(), NUM_HOOKS(0), UNDEFINED("UNDEFINED"), m_hook_paths(MyStringHash) {}
+JobRouterHookMgr::JobRouterHookMgr() : HookClientMgr(), NUM_HOOKS(0), UNDEFINED("UNDEFINED"), m_default_hook_keyword(NULL), m_hook_paths(MyStringHash) {}
 JobRouterHookMgr::~JobRouterHookMgr() {};
 bool JobRouterHookMgr::initialize() { reconfig(); return true; /*HookClientMgr::initialize()*/; }
 bool JobRouterHookMgr::reconfig() { m_default_hook_keyword = param("JOB_ROUTER_HOOK_KEYWORD"); return true; }

diff --git a/src/condor_job_router/JobRouter.cpp b/src/condor_job_router/JobRouter.cpp
index dfa35c9..134a646 100644
--- a/src/condor_job_router/JobRouter.cpp
+++ b/src/condor_job_router/JobRouter.cpp
@@ -746,7 +746,8 @@ JobRouter::ParseRoutingEntries( std::string const &routing_string, char const *p
 				break;
 			}
 
-			dprintf(D_ALWAYS,"JobRouter CONFIGURATION ERROR: Ignoring the malformed route entry in %s, starting here: %s\n",param_name,routing_string.c_str() + this_offset);
+			dprintf(D_ALWAYS,"JobRouter CONFIGURATION ERROR: Ignoring the malformed route entry in %s, at offset %d starting here:\n%s\n",
+				param_name, this_offset, routing_string.substr(this_offset, 79).c_str());
 
 			// skip any junk and try parsing the next route in the list
 			while((int)routing_string.size() > offset && routing_string[offset] != '[') offset++;
@@ -762,7 +763,8 @@ JobRouter::ParseRoutingEntries( std::string const &routing_string, char const *p
 
 			int override = route.OverrideRoutingEntry();
 			if( override < 0 ) {
-				dprintf(D_ALWAYS,"JobRouter CONFIGURATION WARNING while parsing %s: two route entries have the same name '%s' so the second one will override the first one; if you have not already explicitly given these routes a name with name=\"blah\", you may want to give them different names.  If you just want to suppress this warning, then define OverrideRoutingEntry=True/False in the second routing entry.\n",param_name,route.Name());
+				dprintf(D_ALWAYS,"JobRouter CONFIGURATION WARNING: while parsing %s two route entries have the same name '%s' so the second one will override the first one; if you have not already explicitly given these routes a name with name=\"blah\", you may want to give them different names.  If you just want to suppress this warning, then define OverrideRoutingEntry=True/False in the second routing entry.\n",
+					param_name,route.Name());
 				override = 1;
 			}
 			if( override > 0 ) {  // OverrideRoutingEntry=true
@@ -1151,20 +1153,34 @@ JobRouter::GetCandidateJobs() {
 	HashTable<std::string,std::string> constraint_list(200,hashFuncStdString,rejectDuplicateKeys);
 	std::string umbrella_constraint;
 
+	std::string dbuf("JobRouter: Checking for candidate jobs. routing table is:\n"
+		"Route Name             Submitted/Max        Idle/Max     Throttle");
+	if ( ! m_operate_as_tool) {
+		dbuf += " Recent: Started Succeeded Failed\n";
+	} else {
+		dbuf += "\n";
+	}
 	m_routes->startIterations();
 	while(m_routes->iterate(route)) {
-		dprintf(D_ALWAYS,
-		      "JobRouter (route=%s): %d submitted (max %d), %d idle (max %d), throttle: %s, recent stats: %d started, %d succeeded, %d failed.\n",
+		formatstr_cat(dbuf, "%-24s %7d/%7d %7d/%7d %8s",
 		      route->Name(),
 		      route->CurrentRoutedJobs(),
 		      route->MaxJobs(),
 		      route->CurrentIdleJobs(),
 		      route->MaxIdleJobs(),
-		      route->ThrottleDesc().c_str(),
+		      route->ThrottleDesc().c_str());
+		if ( ! m_operate_as_tool) {
+			formatstr_cat(dbuf, "         %7d %9d %6d\n",
 			  route->RecentRoutedJobs(),
 		      route->RecentSuccesses(),
-			  route->RecentFailures());
+			  route->RecentFailures()
+			);
+		} else {
+			dbuf += "\n";
+		}
 	}
+	dprintf(D_ALWAYS, "%s", dbuf.c_str());
+
 
 	if(!AcceptingMoreJobs()) return; //router is full
 
@@ -1246,11 +1262,11 @@ JobRouter::GetCandidateJobs() {
 		free(domain);
 	}
 
-	dprintf(D_FULLDEBUG,"JobRouter: umbrella constraint: %s\n",umbrella_constraint.c_str());
+	dprintf(D_FULLDEBUG,"JobRouter: Umbrella constraint: %s\n",umbrella_constraint.c_str());
 
 	constraint_tree = parser.ParseExpression(umbrella_constraint);
 	if(!constraint_tree) {
-		EXCEPT("JobRouter: Failed to parse umbrella constraint: '%s'\n",umbrella_constraint.c_str());
+		EXCEPT("JobRouter: Failed to parse umbrella constraint: %s\n",umbrella_constraint.c_str());
 	}
 
     query.Bind(ad_collection);
@@ -1277,6 +1293,8 @@ JobRouter::GetCandidateJobs() {
 		ad = ad_collection->GetClassAd(key);
 		ASSERT(ad);
 
+		if (m_operate_as_tool) { dprintf(D_FULLDEBUG, "JobRouter: Checking Job src=%s against all routes\n", key.c_str()); }
+
 		bool all_routes_full;
 		route = ChooseRoute(ad,&all_routes_full);
 		if(!route) {
@@ -1284,7 +1302,7 @@ JobRouter::GetCandidateJobs() {
 				dprintf(D_FULLDEBUG,"JobRouter: all routes are full (%d managed jobs).  Skipping further searches for candidate jobs.\n",NumManagedJobs());
 				break;
 			}
-			dprintf(D_FULLDEBUG,"JobRouter (src=%s): no route found\n",key.c_str());
+			dprintf(D_FULLDEBUG,"JobRouter: no route found for src=%s\n",key.c_str());
 			continue;
 		}
 
@@ -1307,7 +1325,7 @@ JobRouter::GetCandidateJobs() {
 		dprintf(D_FULLDEBUG,"JobRouter DEBUG (%s): combined = %s\n",job->JobDesc().c_str(),ClassAdToString(&job->src_ad).c_str());
 		*/
 
-		dprintf(D_FULLDEBUG,"JobRouter (%s): found candidate job\n",job->JobDesc().c_str());
+		dprintf(D_FULLDEBUG,"JobRouter: Found candidate job %s\n",job->JobDesc().c_str());
 		AddJob(job);
 		++cJobsAdded;
 
@@ -1336,6 +1354,7 @@ JobRouter::ChooseRoute(classad::ClassAd *job_ad,bool *all_routes_full) {
 
 		if(mad.EvaluateAttrBool("RightMatchesLeft", match) && match) {
 			matches.push_back(route);
+			if (m_operate_as_tool) { dprintf(D_FULLDEBUG, "JobRouter: \tRoute Matches: %s\n", route->Name()); }
 		}
 
 		mad.RemoveLeftAd();

