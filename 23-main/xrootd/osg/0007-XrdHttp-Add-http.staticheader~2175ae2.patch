From cb016c10292a5a7ac254ace849b4b3cee72f53c5 Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelman@morgridge.org>
Date: Wed, 15 Jan 2025 08:17:10 -0600
Subject: [PATCH 07/11] [XrdHttp] Add http.staticheader

---
 src/XrdHttp/XrdHttpProtocol.cc                |  92 ++++++++++++
 src/XrdHttp/XrdHttpProtocol.cc.orig           | 132 +++++++++++++++++-
 src/XrdHttp/XrdHttpProtocol.hh                |   9 ++
 ...ttpProtocol.hh => XrdHttpProtocol.hh.orig} |   0
 tests/XRootD/http.cfg                         |   6 +
 tests/XRootD/http.sh                          |  23 +++
 6 files changed, 259 insertions(+), 3 deletions(-)
 copy src/XrdHttp/{XrdHttpProtocol.hh => XrdHttpProtocol.hh.orig} (100%)

diff --git a/src/XrdHttp/XrdHttpProtocol.cc b/src/XrdHttp/XrdHttpProtocol.cc
index 146e39c1d..18a626b95 100644
--- a/src/XrdHttp/XrdHttpProtocol.cc
+++ b/src/XrdHttp/XrdHttpProtocol.cc
@@ -117,6 +117,9 @@ XrdHttpChecksumHandler XrdHttpProtocol::cksumHandler = XrdHttpChecksumHandler();
 XrdHttpReadRangeHandler::Configuration XrdHttpProtocol::ReadRangeConfig;
 bool XrdHttpProtocol::tpcForwardCreds = false;
 
+decltype(XrdHttpProtocol::m_staticheader_map) XrdHttpProtocol::m_staticheader_map;
+decltype(XrdHttpProtocol::m_staticheaders) XrdHttpProtocol::m_staticheaders;
+
 XrdSysTrace XrdHttpTrace("http");
 
 namespace
@@ -1154,6 +1157,7 @@ int XrdHttpProtocol::Config(const char *ConfigFN, XrdOucEnv *myEnv) {
       else if TS_Xeq("listingredir", xlistredir);
       else if TS_Xeq("staticredir", xstaticredir);
       else if TS_Xeq("staticpreload", xstaticpreload);
+      else if TS_Xeq("staticheader", xstaticheader);
       else if TS_Xeq("listingdeny", xlistdeny);
       else if TS_Xeq("header2cgi", xheader2cgi);
       else if TS_Xeq("httpsmode", xhttpsmode);
@@ -1188,6 +1192,24 @@ int XrdHttpProtocol::Config(const char *ConfigFN, XrdOucEnv *myEnv) {
 // Test if XrdEC is loaded
    if (getenv("XRDCL_EC")) usingEC = true;
 
+// Pre-compute the static headers
+//
+  const auto default_verb = m_staticheader_map.find("");
+  std::string default_static_headers;
+  if (default_verb != m_staticheader_map.end()) {
+    for (const auto &header_entry : default_verb->second) {
+      default_static_headers += header_entry.first + ": " + header_entry.second + "\r\n";
+    }
+  }
+  for (const auto &item : m_staticheader_map) {
+    auto headers = default_static_headers;
+    for (const auto &header_entry : item.second) {
+      headers += header_entry.first + ": " + header_entry.second + "\r\n";
+    }
+
+    m_staticheaders[item.first] = headers;
+  }
+
 // If https was disabled, then issue a warning message if xrdtls configured
 // of it's disabled because httpsmode was auto and xrdtls was not configured.
 // If we get past this point then we know https is a plausible option but we
@@ -1672,6 +1694,11 @@ int XrdHttpProtocol::StartSimpleResp(int code, const char *desc, const char *hea
     ss << "Connection: Close" << crlf;
 
   ss << "Server: XrootD/" << XrdVSTRING << crlf;
+
+  const auto iter = m_staticheaders.find(CurrentReq.requestverb);
+  if (iter != m_staticheaders.end()) {
+    ss << iter->second;
+  }
   
   if ((bodylen >= 0) && (code != 100))
     ss << "Content-Length: " << bodylen << crlf;
@@ -2625,6 +2652,71 @@ int XrdHttpProtocol::xstaticpreload(XrdOucStream & Config) {
   return 0;
 }
 
+/******************************************************************************/
+/*                             x s t a t i c h e a d e r                      */
+/******************************************************************************/
+
+//
+// xstaticheader parses the http.staticheader director with the following syntax:
+//
+// http.staticheader [-verb=[GET|HEAD|...]]* header [value]
+//
+// When set, this will cause XrdHttp to always return the specified header and
+// value.
+//
+// Setting this option multiple times is additive (multiple headers may be set).
+// Omitting the value will cause the static header setting to be unset.
+//
+// Omitting the -verb argument will cause it the header to be set unconditionally
+// for all requests.
+int XrdHttpProtocol::xstaticheader(XrdOucStream & Config) {
+  auto val = Config.GetWord();
+  std::vector<std::string> verbs;
+  while (true) {
+    if (!val || !val[0]) {
+      eDest.Emsg("Config", "http.staticheader requires the header to be set to be specified");
+      return 1;
+    }
+
+    std::string match_verb;
+    std::string_view val_str(val);
+    if (val_str.substr(0, 6) == "-verb=") {
+      verbs.emplace_back(val_str.substr(6));
+    } else if (val_str == "-") {
+      eDest.Emsg("Config", "http.staticheader is ignoring unknown flag: ", val_str.data());
+    } else {
+      break;
+    }
+
+    val = Config.GetWord();
+  }
+  if (verbs.empty()) {
+    verbs.emplace_back();
+  }
+
+  std::string header = val;
+
+  val = Config.GetWord();
+  std::string header_value;
+  if (val && val[0]) {
+    header_value = val;
+  }
+
+  for (const auto &verb : verbs) {
+    auto iter = m_staticheader_map.find(verb);
+    if (iter == m_staticheader_map.end() && !header_value.empty()) {
+      m_staticheader_map.insert(iter, {verb, {{header, header_value}}});
+    } else if (header_value.empty()) {
+      iter->second.clear();
+    } else {
+      iter->second.emplace_back(header, header_value);
+    }
+  }
+
+  return 0;
+}
+
+
 /******************************************************************************/
 /*                          x s e l f h t t p s 2 h t t p                     */
 /******************************************************************************/
diff --git a/src/XrdHttp/XrdHttpProtocol.cc.orig b/src/XrdHttp/XrdHttpProtocol.cc.orig
index ba8af7435..146e39c1d 100644
--- a/src/XrdHttp/XrdHttpProtocol.cc.orig
+++ b/src/XrdHttp/XrdHttpProtocol.cc.orig
@@ -135,6 +135,8 @@ static const int hsmOn   =  1; // Dual purpose but use a meaningful varname
 
 int  httpsmode = hsmAuto;
 int  tlsCache  = XrdTlsContext::scOff;
+XrdTlsContext::ClientAuthSetting tlsClientAuth = XrdTlsContext::ClientAuthSetting::kOn;
+std::vector<std::string> tlsAuthRequestPrefixes;
 bool httpsspec = false;
 bool xrdctxVer = false;
 }
@@ -448,6 +450,23 @@ static long BIO_XrdLink_ctrl(BIO *bio, int cmd, long num, void * ptr)
   case BIO_CTRL_FLUSH:
     ret = 1;
     break;
+  case BIO_C_SET_NBIO:
+  {
+    auto link = static_cast<XrdLink*>(BIO_get_data(bio));
+    if (link) {
+      struct timeval tv;
+      tv.tv_sec = 10;
+      tv.tv_usec = 0;
+      if (num) {
+        tv.tv_sec = 0;
+        tv.tv_usec = 1;
+      }
+      setsockopt(link->FDnum(), SOL_SOCKET, SO_RCVTIMEO, (struct timeval *)&tv, sizeof(struct timeval));
+      setsockopt(link->FDnum(), SOL_SOCKET, SO_SNDTIMEO, (struct timeval *)&tv, sizeof(struct timeval));
+    }
+    ret = 1;
+    break;
+  }
   default:
     ret = 0;
     break;
@@ -506,7 +525,11 @@ int XrdHttpProtocol::Process(XrdLink *lp) // We ignore the argument here
       if (!ssl) {
           sbio = CreateBIO(Link);
           BIO_set_nbio(sbio, 1);
+          xrdctx->SetTlsClientAuth(tlsClientAuth);
           ssl = (SSL*)xrdctx->Session();
+          postheaderauth = false;
+          postheaderwait = false;
+          postheaderauthdone = false;
         }
 
       if (!ssl) {
@@ -553,7 +576,7 @@ int XrdHttpProtocol::Process(XrdLink *lp) // We ignore the argument here
       strcpy(SecEntity.prot, "https");
 
       // Get the voms string and auth information
-      if (HandleAuthentication(Link)) {
+      if (tlsClientAuth == XrdTlsContext::ClientAuthSetting::kOn && HandleAuthentication(Link)) {
           SSL_free(ssl);
           ssl = 0;
           return -1;
@@ -585,7 +608,7 @@ int XrdHttpProtocol::Process(XrdLink *lp) // We ignore the argument here
 
     } else
       CurrentReq.reqstate++;
-  } else if (!DoneSetInfo && !CurrentReq.userAgent().empty()) { // DoingLogin is true, meaning the login finished.
+  } else if (!DoneSetInfo && !postheaderwait && !postheaderauth && !CurrentReq.userAgent().empty()) { // DoingLogin is true, meaning the login finished.
     std::string mon_info = "monitor info " + CurrentReq.userAgent();
     DoneSetInfo = true;
     if (mon_info.size() >= 1024) {
@@ -605,7 +628,7 @@ int XrdHttpProtocol::Process(XrdLink *lp) // We ignore the argument here
       }
       return 0;
     }
-  } else {
+  } else if (!postheaderwait) {
     DoingLogin = false;
   }
 
@@ -635,6 +658,21 @@ int XrdHttpProtocol::Process(XrdLink *lp) // We ignore the argument here
           TRACE(DEBUG, " Parsing of first line failed with " << result);
           return -1;
         }
+
+#if OPENSSL_VERSION_NUMBER >= 0x10100010L
+        // We permit TLS client auth to be deferred until after the request path is sent.
+        // If this is a path requiring client auth, then do that now.
+        if (!postheaderauthdone && tlsClientAuth == XrdTlsContext::ClientAuthSetting::kDefer)
+           {for (const auto &prefix : tlsAuthRequestPrefixes) {
+               {if (!strncmp(prefix.c_str(), CurrentReq.resource.c_str(), prefix.length()))
+                   {postheaderwait = true;
+                    DoingLogin = true;
+                    break;
+                   }
+               }
+            }
+           }
+#endif
       } else {
         int result = CurrentReq.parseLine((char *) tmpline.c_str(), rc);
         if(result < 0) {
@@ -669,6 +707,50 @@ int XrdHttpProtocol::Process(XrdLink *lp) // We ignore the argument here
 
   }
 
+
+#if OPENSSL_VERSION_NUMBER >= 0x10100010L
+  if (postheaderwait) {
+    postheaderwait = false;
+    if (SSL_verify_client_post_handshake(ssl) != 1) {
+      // This is hit if the remote client doesn't support the post-handshake authentication
+      // (curl, Mac OSX) or TLS v1.3 (RHEL7).
+      TRACEI(ALL, "Unable to request client X.509 authentication");
+      ERR_print_errors(sslbio_err);
+    } else {
+      // We must invoke an empty write to trigger the authentication request in the TLS layer.
+      size_t write_size;
+      auto res = SSL_write_ex(ssl, nullptr, 0, &write_size);
+      if (res <= 0) {
+        TRACEI(DEBUG, " SSL post-handshake auth failed; err:" << SSL_get_error(ssl, res));
+        ERR_print_errors(sslbio_err);
+        SendSimpleResp(500, nullptr, nullptr, "Failed post-handshake authentication", 0, false);
+        return -1;
+      } else {
+        TRACEI(DEBUG, " SSL post-handshake auth finished successfully");
+        postheaderauth = true;
+        return 1;
+      }
+    }
+  }
+  if (postheaderauth) {
+    postheaderauth = false;
+    postheaderauthdone = true;
+    size_t readbytes;
+    TRACEI(REQ, "Reading out response to post-handshake authentication");
+    BIO_set_nbio(sbio, 1);
+    auto res = SSL_peek_ex(ssl, nullptr, 0, &readbytes);
+    if ((res <= 0) && SSL_get_error(ssl, res) != SSL_ERROR_WANT_READ) {
+      SendSimpleResp(500, nullptr, nullptr, "Failed to process authentication frames", 0, false);
+      return -1;
+    }
+    BIO_set_nbio(sbio, 0);
+    if (HandleAuthentication(Link)) {
+      SendSimpleResp(500, nullptr, nullptr, "Failed to extract authentication information from handshake", 0, false);
+      return -1;
+    }
+  }
+#endif
+
   // If we are in self-redirect mode, then let's do it
   // Do selfredirect only with 'simple' requests, otherwise poor clients may misbehave
   if (ishttps && ssldone && selfhttps2http &&
@@ -1077,6 +1159,8 @@ int XrdHttpProtocol::Config(const char *ConfigFN, XrdOucEnv *myEnv) {
       else if TS_Xeq("httpsmode", xhttpsmode);
       else if TS_Xeq("tlsreuse", xtlsreuse);
       else if TS_Xeq("auth", xauth);
+      else if TS_Xeq("tlsclientauth", xtlsclientauth);
+      else if TS_Xeq("tlsrequiredprefix", xtlsrequiredprefix);
       else {
         eDest.Say("Config warning: ignoring unknown directive '", var, "'.");
         Config.Echo();
@@ -1944,6 +2028,8 @@ void XrdHttpProtocol::Reset() {
 
   DoingLogin = false;
   DoneSetInfo = false;
+  postheaderauth = false;
+  postheaderwait = false;
 
   ResumeBytes = 0;
   Resume = 0;
@@ -2845,6 +2931,46 @@ int XrdHttpProtocol::xtlsreuse(XrdOucStream & Config) {
    return 1;
 }
 
+int XrdHttpProtocol::xtlsclientauth(XrdOucStream &Config) {
+  auto val = Config.GetWord();
+  if (!val || !val[0])
+     {eDest.Emsg("Config", "tlsclientauth argument not specified"); return 1;}
+
+  if (!strcmp(val, "off"))
+     {tlsClientAuth = XrdTlsContext::ClientAuthSetting::kOff;
+      return 0;
+     }
+  if (!strcmp(val, "on"))
+     {tlsClientAuth = XrdTlsContext::ClientAuthSetting::kOn;
+      return 0;
+     }
+  if (!strcmp(val, "defer"))
+     {
+#if OPENSSL_VERSION_NUMBER >= 0x10100010L
+     tlsClientAuth = XrdTlsContext::ClientAuthSetting::kDefer;
+     return 0;
+#else
+     eDest.Emsg("config", "http.tlsclientauth defer is not supported on this platform");
+     return 1;
+#endif
+     }
+
+  eDest.Emsg("config", "invalid tlsclientauth parameter -", val);
+  return 1;
+}
+
+int XrdHttpProtocol::xtlsrequiredprefix(XrdOucStream &Config) {
+  auto val = Config.GetWord();
+  if (!val || !val[0])
+     {eDest.Emsg("Config", "tlsrequiredprefix argument not specified"); return 1;}
+
+  if (val[0] != '/')
+     {eDest.Emsg("Config", "http.tlsrequiredprefix argument must be an absolute path"); return 1;}
+
+  tlsAuthRequestPrefixes.push_back(val);
+  return 0;
+}
+
 int XrdHttpProtocol::xauth(XrdOucStream &Config) {
   char *val = Config.GetWord();
   if(val) {
diff --git a/src/XrdHttp/XrdHttpProtocol.hh b/src/XrdHttp/XrdHttpProtocol.hh
index 78fd24b45..a93c4e936 100644
--- a/src/XrdHttp/XrdHttpProtocol.hh
+++ b/src/XrdHttp/XrdHttpProtocol.hh
@@ -52,6 +52,7 @@
 
 #include <openssl/ssl.h>
 
+#include <unordered_map>
 #include <vector>
 
 #include "XrdHttpReq.hh"
@@ -213,6 +214,7 @@ class XrdHttpProtocol : public XrdProtocol {
   static int xlistredir(XrdOucStream &Config);
   static int xselfhttps2http(XrdOucStream &Config);
   static int xembeddedstatic(XrdOucStream &Config);
+  static int xstaticheader(XrdOucStream &Config);
   static int xstaticredir(XrdOucStream &Config);
   static int xstaticpreload(XrdOucStream &Config);
   static int xgmap(XrdOucStream &Config);
@@ -464,5 +466,12 @@ class XrdHttpProtocol : public XrdProtocol {
 
   /// If set to true, the HTTP TPC transfers will forward the credentials to redirected hosts
   static bool tpcForwardCreds;
+
+  /// The static headers to always return; map is from verb to a list of (header, val) pairs.
+  static std::unordered_map<std::string, std::vector<std::pair<std::string, std::string>>> m_staticheader_map;
+
+  /// The static string version of m_staticheader_map.  After config parsing is done, this is
+  /// computed and we won't need to reference m_staticheader_map in the response path.
+  static std::unordered_map<std::string, std::string> m_staticheaders;
 };
 #endif
diff --git a/src/XrdHttp/XrdHttpProtocol.hh b/src/XrdHttp/XrdHttpProtocol.hh.orig
similarity index 100%
copy from src/XrdHttp/XrdHttpProtocol.hh
copy to src/XrdHttp/XrdHttpProtocol.hh.orig
diff --git a/tests/XRootD/http.cfg b/tests/XRootD/http.cfg
index 302b6e5a1..c43798fb1 100644
--- a/tests/XRootD/http.cfg
+++ b/tests/XRootD/http.cfg
@@ -16,4 +16,10 @@ http.exthandler xrdtpc libXrdHttpTPC.so
 http.exthandler xrdmacaroons libXrdMacaroons.so
 macaroons.secretkey $pwd/macaroons-secret
 
+# Verify static headers are appropriately appended to responses
+http.staticheader -verb=OPTIONS Access-Control-Allow-Origin *
+http.staticheader -verb=GET Foo Bar
+http.staticheader -verb=GET Foo Baz
+http.staticheader Test 1
+
 continue $src/common.cfg
diff --git a/tests/XRootD/http.sh b/tests/XRootD/http.sh
index 2b0ace4ef..2eb5b991c 100755
--- a/tests/XRootD/http.sh
+++ b/tests/XRootD/http.sh
@@ -135,4 +135,27 @@ function test_http() {
   receivedDigest=$(grep -i "Digest" "$outputFilePath")
   assert_eq "$expectedDigest" "$receivedDigest" "HEAD request test failed (digest not supported)"
 	wait
+
+  ## OPTIONS has appropriate static headers
+  curl -s -X OPTIONS -v --raw "${HOST}/$alphabetFilePath" 2>&1 | tr -d '\r' > "$outputFilePath"
+  cat "$outputFilePath"
+  expectedHeader='< Access-Control-Allow-Origin: *'
+  receivedHeader=$(grep -i 'Access-Control-Allow-Origin:' "$outputFilePath")
+  assert_eq "$expectedHeader" "$receivedHeader" "OPTIONS is missing statically-defined Access-Control-Allow-Origin"
+  expectedHeader='< Test: 1'
+  receivedHeader=$(grep -i 'Test:' "$outputFilePath")
+  assert_eq "$expectedHeader" "$receivedHeader" "OPTIONS is missing statically-defined Test header"
+
+  ## GET has appropriate static headers
+  curl -s -v --raw "${HOST}/$alphabetFilePath" 2>&1 | tr -d '\r' > "$outputFilePath"
+  cat "$outputFilePath"
+  expectedHeader='< Foo: Bar'
+  receivedHeader=$(grep -i 'Foo: Bar' "$outputFilePath")
+  assert_eq "$expectedHeader" "$receivedHeader" "GET is missing statically-defined 'Foo: Bar' header"
+  expectedHeader='< Foo: Baz'
+  receivedHeader=$(grep -i 'Foo: Baz' "$outputFilePath")
+  assert_eq "$expectedHeader" "$receivedHeader" "GET is missing statically-defined 'Foo: Baz' header"
+  expectedHeader='< Test: 1'
+  receivedHeader=$(grep -i 'Test:' "$outputFilePath")
+  assert_eq "$expectedHeader" "$receivedHeader" "GET is missing statically-defined Test header"
 }
-- 
2.43.5

