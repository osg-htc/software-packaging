From 83063d0a7caa332bac3c8a366507414fdea6681c Mon Sep 17 00:00:00 2001
From: Brian Bockelman <bbockelman@morgridge.org>
Date: Wed, 15 Jan 2025 08:15:53 -0600
Subject: [PATCH 6/9] [XrdSciTokens] Handle multiple authorization token setups

---
 src/XrdHttp/XrdHttpReq.cc                     |   2 +-
 .../{XrdHttpReq.cc => XrdHttpReq.cc.orig}     |   0
 src/XrdMacaroons/XrdMacaroonsAuthz.cc         |   4 +
 src/XrdOuc/XrdOucEnv.cc                       |  60 +-
 src/XrdOuc/XrdOucUtils.cc                     |   2 +-
 .../{XrdOucUtils.cc => XrdOucUtils.cc.orig}   |   0
 src/XrdSciTokens.cmake                        |  26 +-
 src/XrdSciTokens/README.md                    |  11 +
 src/XrdSciTokens/XrdSciTokensAccess.cc        | 663 ++++++++++--------
 src/XrdSciTokens/XrdSciTokensAccess.hh        | 222 ++++++
 src/XrdTpc/XrdTpcUtils.cc                     |   5 +-
 tests/CMakeLists.txt                          |   4 +
 tests/XRootD/CMakeLists.txt                   |  18 +-
 tests/XRootD/scitokens-module.cfg             |  12 +
 tests/XRootD/scitokens.authdb                 |   1 +
 tests/XRootD/scitokens.cfg                    |  26 +
 tests/XRootD/scitokens.sh                     | 159 +++++
 tests/XrdOucTests/CMakeLists.txt              |   2 +-
 tests/XrdOucTests/XrdOucEnvTests.cc           |  28 +
 tests/XrdOucTests/XrdOucUtilsTests.cc         |   3 +
 tests/scitokens/CMakeLists.txt                |  34 +
 tests/scitokens/XrdSciTokens.cc               |  73 ++
 tests/scitokens/XrdScitokensCreateJwks.cc     | 215 ++++++
 tests/scitokens/XrdScitokensCreateToken.cc    | 145 ++++
 tests/scitokens/one-openid-configuration      |   3 +
 tests/scitokens/setup.sh                      | 127 ++++
 tests/scitokens/teardown.sh                   |  11 +
 tests/scitokens/two-openid-configuration      |   3 +
 28 files changed, 1529 insertions(+), 330 deletions(-)
 copy src/XrdHttp/{XrdHttpReq.cc => XrdHttpReq.cc.orig} (100%)
 copy src/XrdOuc/{XrdOucUtils.cc => XrdOucUtils.cc.orig} (100%)
 create mode 100644 src/XrdSciTokens/XrdSciTokensAccess.hh
 create mode 100644 tests/XRootD/scitokens-module.cfg
 create mode 100644 tests/XRootD/scitokens.authdb
 create mode 100644 tests/XRootD/scitokens.cfg
 create mode 100644 tests/XRootD/scitokens.sh
 create mode 100644 tests/XrdOucTests/XrdOucEnvTests.cc
 create mode 100644 tests/scitokens/CMakeLists.txt
 create mode 100644 tests/scitokens/XrdSciTokens.cc
 create mode 100644 tests/scitokens/XrdScitokensCreateJwks.cc
 create mode 100644 tests/scitokens/XrdScitokensCreateToken.cc
 create mode 100644 tests/scitokens/one-openid-configuration
 create mode 100644 tests/scitokens/setup.sh
 create mode 100644 tests/scitokens/teardown.sh
 create mode 100644 tests/scitokens/two-openid-configuration

diff --git a/src/XrdHttp/XrdHttpReq.cc b/src/XrdHttp/XrdHttpReq.cc
index aaa90899e..ae0dbcb44 100644
--- a/src/XrdHttp/XrdHttpReq.cc
+++ b/src/XrdHttp/XrdHttpReq.cc
@@ -2350,7 +2350,7 @@ int XrdHttpReq::PostProcessHTTPReq(bool final_) {
 
         if (ntohs(xrdreq.header.requestid) == kXR_close) {
           if (xrdresp == kXR_ok) {
-            prot->SendSimpleResp(200, NULL, NULL, (char *) ":-)", 0, keepalive);
+            prot->SendSimpleResp(201, NULL, NULL, (char *) ":-)", 0, keepalive);
             return keepalive ? 1 : -1;
           } else {
             prot->SendSimpleResp(httpStatusCode, NULL, NULL,
diff --git a/src/XrdHttp/XrdHttpReq.cc b/src/XrdHttp/XrdHttpReq.cc.orig
similarity index 100%
copy from src/XrdHttp/XrdHttpReq.cc
copy to src/XrdHttp/XrdHttpReq.cc.orig
diff --git a/src/XrdMacaroons/XrdMacaroonsAuthz.cc b/src/XrdMacaroons/XrdMacaroonsAuthz.cc
index df771b06c..aee058442 100644
--- a/src/XrdMacaroons/XrdMacaroonsAuthz.cc
+++ b/src/XrdMacaroons/XrdMacaroonsAuthz.cc
@@ -173,6 +173,10 @@ Authz::Access(const XrdSecEntity *Entity, const char *path,
 
     const char *authz = env ? env->Get("authz") : nullptr;
     if (authz && !strncmp(authz, "Bearer%20", 9))
+    {
+        authz += 9;
+    }
+    else if (!authz && (authz = env ? env->Get("access_token") : nullptr) && !strncmp(authz, "Bearer%20", 9))
     {
         authz += 9;
     }
diff --git a/src/XrdOuc/XrdOucEnv.cc b/src/XrdOuc/XrdOucEnv.cc
index b8b65d9bc..a27813077 100644
--- a/src/XrdOuc/XrdOucEnv.cc
+++ b/src/XrdOuc/XrdOucEnv.cc
@@ -102,37 +102,55 @@ char *XrdOucEnv::Delimit(char *value)
 
 void XrdOucEnv::EnvBuildTidy()
 {
-   char *tidyEnv, *authInfo;
-   int aBeg, aEnd;
+   char *tidyEnv, *authInfo, *accessAuthInfo = nullptr, *working=global_env;
+   int aBeg, aEnd, aCount = 6;
 
 // We need to sanitize the current env string by removing auth info. If there
-// is no auth informationn, then we can short cicuit this.
+// is no auth information, then we can short circuit this.
 //
-   if ((authInfo = strstr(global_env, "authz=")) == 0)
+   if ((authInfo = strstr(global_env, "authz=")) == 0 && (accessAuthInfo = strstr(global_env, "access_token=")) == 0)
       {Put(TIDY_ENVVAR, "");
        return;
       }
 
 // Get position of the auth string and check if we can do a fast deletion.
 // Otherwise, we must trudge along.
 //
-   aBeg = authInfo - global_env;
-   if (aBeg && global_env[aBeg-1] == '&') aBeg--;
-   if (!(tidyEnv = index(authInfo+6, '&')))
-      {char aSave = global_env[aBeg];
-       global_env[aBeg] = 0;
-       Put(TIDY_ENVVAR, global_env);
-       global_env[aBeg] = aSave;
-      } else {
-       XrdOucString tidyStr(global_env);
-       do{if ((aEnd = tidyStr.find('&', aBeg+6)) == STR_NPOS)
-             {tidyStr.erase(aBeg);
-              break;
-             }
-          tidyStr.erase(aBeg, aEnd-aBeg);
-         } while((aBeg = tidyStr.find("&authz=")) != STR_NPOS);
-       Put(TIDY_ENVVAR, tidyStr.c_str());
-      }
+   for (int idx = 0; idx < 2; idx++)
+       {if (idx == 1)
+           {if (authInfo)
+               {working=Get(TIDY_ENVVAR);
+                accessAuthInfo = strstr(working, "access_token=");
+               }
+            aCount = 13;
+            authInfo = accessAuthInfo;
+           }
+        if (!authInfo) continue;
+        aBeg = authInfo - working;
+        if (aBeg && working[aBeg-1] == '&') aBeg--;
+        if (!(tidyEnv = index(authInfo+aCount, '&')))
+           {char aSave = working[aBeg];
+            if (aBeg) {
+                working[aBeg] = 0;
+                Put(TIDY_ENVVAR, working);
+                working[aBeg] = aSave;
+               } else {
+                Put(TIDY_ENVVAR, "&");
+               }
+           } else {
+            XrdOucString tidyStr(working);
+            do{if ((aEnd = tidyStr.find('&', aBeg+aCount)) == STR_NPOS)
+                  {tidyStr.erase(aBeg);
+                   break;
+                  }
+               tidyStr.erase(aBeg, aEnd-aBeg);
+              } while((aBeg = tidyStr.find(idx ? "&access_token=" : "&authz=")) != STR_NPOS);
+             if (!tidyStr.length())
+                Put(TIDY_ENVVAR, "&");
+             else
+                Put(TIDY_ENVVAR, tidyStr.c_str());
+           }
+       }
 }
  
 /******************************************************************************/
diff --git a/src/XrdOuc/XrdOucUtils.cc b/src/XrdOuc/XrdOucUtils.cc
index 40d4e811f..1f80a72a0 100644
--- a/src/XrdOuc/XrdOucUtils.cc
+++ b/src/XrdOuc/XrdOucUtils.cc
@@ -1448,7 +1448,7 @@ std::string obfuscateAuth(const std::string& input)
 {
   static const regex_t auth_regex = []() {
     constexpr char re[] =
-      "(authz=|(transferheader)?(www-|proxy-)?auth(orization|enticate)[[:space:]]*:[[:space:]]*)"
+      "(access_token=|authz=|(transferheader)?(www-|proxy-)?auth(orization|enticate)[[:space:]]*:[[:space:]]*)"
       "(Bearer([[:space:]]|%20)?(token([[:space:]]|%20)?)?)?";
 
     regex_t regex;
diff --git a/src/XrdOuc/XrdOucUtils.cc b/src/XrdOuc/XrdOucUtils.cc.orig
similarity index 100%
copy from src/XrdOuc/XrdOucUtils.cc
copy to src/XrdOuc/XrdOucUtils.cc.orig
diff --git a/src/XrdSciTokens.cmake b/src/XrdSciTokens.cmake
index f2def352e..e6360b0ab 100644
--- a/src/XrdSciTokens.cmake
+++ b/src/XrdSciTokens.cmake
@@ -7,34 +7,48 @@ find_package( SciTokensCpp REQUIRED )
 set( LIB_XRD_SCITOKENS  XrdAccSciTokens-${PLUGIN_VERSION} )
 
 #-------------------------------------------------------------------------------
-# The XrdPfc library
+# The XrdSciTokens object library
+#
+# This separate object library is created so unit tests can link directly to it
+# (linking against a MODULE is forbidden)
 #-------------------------------------------------------------------------------
 add_library(
-   ${LIB_XRD_SCITOKENS}
-   MODULE
+   XrdSciTokensObj
+   OBJECT
    XrdSciTokens/XrdSciTokensAccess.cc
                                        XrdSciTokens/XrdSciTokensHelper.hh
    XrdSciTokens/XrdSciTokensMon.cc     XrdSciTokens/XrdSciTokensMon.hh )
 target_link_libraries(
-   ${LIB_XRD_SCITOKENS}
+   XrdSciTokensObj
    PRIVATE
    ${SCITOKENS_CPP_LIBRARIES}
    XrdUtils
    XrdServer
    ${CMAKE_DL_LIBS}
    ${CMAKE_THREAD_LIBS_INIT} )
 
 target_include_directories(
-   ${LIB_XRD_SCITOKENS}
+   XrdSciTokensObj
    PRIVATE
    ${SCITOKENS_CPP_INCLUDE_DIR}
    XrdSciTokens/vendor/picojson
    XrdSciTokens/vendor/inih )
 
+set_target_properties(XrdSciTokensObj PROPERTIES POSITION_INDEPENDENT_CODE ON)
 if (HAVE_SCITOKEN_CONFIG_SET_STR)
-   target_compile_definitions(${LIB_XRD_SCITOKENS} PRIVATE HAVE_SCITOKEN_CONFIG_SET_STR)
+   target_compile_definitions(XrdSciTokensObj PRIVATE HAVE_SCITOKEN_CONFIG_SET_STR)
 endif()
 
+#-------------------------------------------------------------------------------
+# The XrdSciTokens module
+#-------------------------------------------------------------------------------
+add_library(
+   ${LIB_XRD_SCITOKENS}
+   MODULE
+   "$<TARGET_OBJECTS:XrdSciTokensObj>")
+
+target_link_libraries(${LIB_XRD_SCITOKENS} XrdSciTokensObj)
+
 #-------------------------------------------------------------------------------
 # Install
 #-------------------------------------------------------------------------------
diff --git a/src/XrdSciTokens/README.md b/src/XrdSciTokens/README.md
index 1edecf944..ab47f60e2 100644
--- a/src/XrdSciTokens/README.md
+++ b/src/XrdSciTokens/README.md
@@ -129,19 +129,30 @@ are:
       For the `group` and `mapping` cases, the username and group are set in the internal XRootD request credential,
       but the final authorization must be done by a subsequent plugin.  The default value is `capability group mapping`.
       *Note*: if `mapping` is present, then a token without a capability may still have authorized actions.
+   -  `required_authorization` (optional): In some configurations, there may be multiple possible issuers for a given path; by
+      default, authorization from any one issuer is sufficient.  This option indicates the issuer's authorization is _required_
+      for the path (meaning that a token from this issuer is always required for the paths it manages, regardless of what
+      other issuers may authorize).  Valid values are `none`, `read`, `write`, or `all`; default is `none`.
+   -  `acceptable_authorization` (optional): Whether a valid token from this issuer is acceptable for the XRootD authorization
+      framework.  If so, the user, issuer, and group information will be extracted from the token and passed to the
+      XRootD credential (the username may, for example, be used by a subsequent OSS plugin for interacting with the
+      filesystem).  This may be useful in cases where a token is required from a given issuer but shouldn't be used
+      to populate the username.  Valid values are `none`, `read`, `write`, or `all`; default is `all`.
 
 
 Group- and Scope-based authorization
 ------------------------------------
 
 WLCG tokens can contain either group- or scope-based attributes.  The scope-based attributes specify a path the user
 is allowed to access (relative to one of the base paths).  If a request is permitted via a scope-based attribute, then
 it is approved immediately by the plugin.
 
 If there is a group-based attribute, then the contents are copied into XRootD's internal credential.  The plugin does
 not necessarily immediately authorize (see the `onmissing` attribute) but rather can be used by a further authorization
 plugin.
 
+If there are multiple tokens in the request, they are processed in order until an acceptable authorization is found.
+
 Mapfile format
 --------------
 
diff --git a/src/XrdSciTokens/XrdSciTokensAccess.cc b/src/XrdSciTokens/XrdSciTokensAccess.cc
index 944149a0d..d4f6373e9 100644
--- a/src/XrdSciTokens/XrdSciTokensAccess.cc
+++ b/src/XrdSciTokens/XrdSciTokensAccess.cc
@@ -24,31 +24,27 @@
 #include "picojson.h"
 
 #include "scitokens/scitokens.h"
+#include "XrdSciTokens/XrdSciTokensAccess.hh"
 #include "XrdSciTokens/XrdSciTokensHelper.hh"
 #include "XrdSciTokens/XrdSciTokensMon.hh"
 
 // The status-quo to retrieve the default object is to copy/paste the
 // linker definition and invoke directly.
 XrdVERSIONINFO(XrdAccAuthorizeObject, XrdAccSciTokens);
 XrdVERSIONINFO(XrdAccAuthorizeObjAdd, XrdAccSciTokens);
 
+XrdSciTokensHelper *SciTokensHelper = nullptr;
+
 namespace {
 
 enum LogMask {
     Debug = 0x01,
     Info = 0x02,
     Warning = 0x04,
     Error = 0x08,
     All = 0xff
 };
 
-enum IssuerAuthz {
-    Capability = 0x01,
-    Group = 0x02,
-    Mapping = 0x04,
-    Default = 0x07
-};
-
 std::string LogMaskToString(int mask) {
     if (mask == LogMask::All) {return "all";}
 
@@ -73,8 +69,6 @@ std::string LogMaskToString(int mask) {
     return ss.str();
 }
 
-typedef std::vector<std::pair<Access_Operation, std::string>> AccessRulesRaw;
-
 inline uint64_t monotonic_time() {
   struct timespec tp;
 #ifdef CLOCK_MONOTONIC_COARSE
@@ -224,92 +218,48 @@ void ParseCanonicalPaths(const std::string &path, std::vector<std::string> &resu
     } while (pos != std::string::npos);
 }
 
-struct MapRule
-{
-    MapRule(const std::string &sub,
-            const std::string &username,
-            const std::string &path_prefix,
-            const std::string &group,
-            const std::string &result)
-        : m_sub(sub),
-          m_username(username),
-          m_path_prefix(path_prefix),
-          m_group(group),
-          m_result(result)
-    {
-        //std::cerr << "Making a rule {sub=" << sub << ", username=" << username << ", path=" << path_prefix << ", group=" << group << ", result=" << name << "}" << std::endl;
-    }
-
-    const std::string match(const std::string &sub,
-                            const std::string &username,
-                            const std::string &req_path,
-                            const std::vector<std::string> &groups) const
-    {
-        if (!m_sub.empty() && sub != m_sub) {return "";}
-
-        if (!m_username.empty() && username != m_username) {return "";}
-
-        if (!m_path_prefix.empty() &&
-            strncmp(req_path.c_str(), m_path_prefix.c_str(), m_path_prefix.size()))
-        {
-            return "";
-        }
-
-        if (!m_group.empty()) {
-            for (const auto &group : groups) {
-                if (group == m_group)
-                    return m_result;
-            }
-            return "";
-        }
-        return m_result;
-    }
-
-    std::string m_sub;
-    std::string m_username;
-    std::string m_path_prefix;
-    std::string m_group;
-    std::string m_result;
-};
-
 struct IssuerConfig
 {
     IssuerConfig(const std::string &issuer_name,
                  const std::string &issuer_url,
                  const std::vector<std::string> &base_paths,
                  const std::vector<std::string> &restricted_paths,
                  bool map_subject,
                  uint32_t authz_strategy,
                  const std::string &default_user,
                  const std::string &username_claim,
                  const std::string &groups_claim,
-                 const std::vector<MapRule> rules)
+                 const std::vector<MapRule> rules,
+                 AuthzSetting acceptable_authz,
+                 AuthzSetting required_authz)
         : m_map_subject(map_subject || !username_claim.empty()),
+          m_acceptable_authz(acceptable_authz),
+          m_required_authz(required_authz),
           m_authz_strategy(authz_strategy),
           m_name(issuer_name),
           m_url(issuer_url),
           m_default_user(default_user),
           m_username_claim(username_claim),
           m_groups_claim(groups_claim),
           m_base_paths(base_paths),
           m_restricted_paths(restricted_paths),
           m_map_rules(rules)
     {}
 
     const bool m_map_subject;
+    const AuthzSetting m_acceptable_authz;
+    const AuthzSetting m_required_authz;
     const uint32_t m_authz_strategy;
     const std::string m_name;
     const std::string m_url;
     const std::string m_default_user;
     const std::string m_username_claim;
     const std::string m_groups_claim;
     const std::vector<std::string> m_base_paths;
     const std::vector<std::string> m_restricted_paths;
     const std::vector<MapRule> m_map_rules;
 };
 
-}
-
 class OverrideINIReader: public INIReader {
 public:
     OverrideINIReader() {};
@@ -346,123 +296,142 @@ class OverrideINIReader: public INIReader {
 
 };
 
-class XrdAccRules
-{
-public:
-    XrdAccRules(uint64_t expiry_time, const std::string &username, const std::string &token_subject,
-        const std::string &issuer, const std::vector<MapRule> &rules, const std::vector<std::string> &groups,
-        uint32_t authz_strategy) :
-        m_authz_strategy(authz_strategy),
-        m_expiry_time(expiry_time),
-        m_username(username),
-        m_token_subject(token_subject),
-        m_issuer(issuer),
-        m_map_rules(rules),
-        m_groups(groups)
-    {}
-
-    ~XrdAccRules() {}
-
-    bool apply(Access_Operation oper, std::string path) {
-      auto is_subdirectory = [](const std::string& dir, const std::string& subdir) {
-        if (subdir.size() < dir.size())
-          return false;
-
-        if (subdir.compare(0, dir.size(), dir, 0, dir.size()) != 0)
-          return false;
-
-        return dir.size() == subdir.size() || subdir[dir.size()] == '/' || dir == "/";
-      };
-
-      for (const auto & rule : m_rules) {
-        // Skip rules that don't match the current operation
-        if (rule.first != oper)
-          continue;
-
-        // If the rule allows any path, allow the operation
-        if (rule.second == "/")
-          return true;
 
-        // Allow operation if path is a subdirectory of the rule's path
-        if (is_subdirectory(rule.second, path)) {
-          return true;
-        } else {
-          // Allow stat and mkdir of parent directories to comply with WLCG token specs
-          if (oper == AOP_Stat || oper == AOP_Mkdir)
-            if (is_subdirectory(path, rule.second))
-              return true;
+void
+ParseTokenString(const std::string &param, XrdOucEnv *env, std::vector<std::string_view> &authz_list)
+{
+    if (!env) {return;}
+    const char *authz = env->Get(param.c_str());
+    if (!authz) {return;}
+    std::string_view authz_view(authz);
+    size_t pos;
+    do {
+        // Note: this is more permissive than the plugin was previously.
+        // The prefix 'Bearer%20' used to be required as that's what HTTP
+        // required.  However, to make this more pleasant for XRootD protocol
+        // users, we now simply "handle" the prefix insterad of requiring it.
+        if (authz_view.substr(0, 9) == "Bearer%20") {
+            authz_view = authz_view.substr(9);
         }
-      }
-      return false;
-    }
-
-    bool expired() const {return monotonic_time() > m_expiry_time;}
-
-    void parse(const AccessRulesRaw &rules) {
-        m_rules.reserve(rules.size());
-        for (const auto &entry : rules) {
-            m_rules.emplace_back(entry.first, entry.second);
+        pos = authz_view.find(",");
+        authz_list.push_back(authz_view.substr(0, pos));
+        authz_view = authz_view.substr(pos + 1);
+    } while (pos != std::string_view::npos);
+}
+
+} // namespace
+
+std::string
+SubpathMatch::str() const {
+    return AccessRuleStr(m_rules); // Returns a human-friendly representation of the access rules
+}
+
+// Convert a list of authorizations into a human-readable string.
+const std::string
+XrdAccRules::str() const
+{
+    std::stringstream ss;
+    ss << "mapped_username=" << m_username << ", subject=" << m_token_subject
+        << ", issuer=" << m_issuer;
+    if (!m_groups.empty()) {
+        ss << ", groups=";
+        bool first=true;
+        for (const auto &group : m_groups) {
+            ss << (first ? "" : ",") << group;
+            first = false;
         }
     }
-
-    std::string get_username(const std::string &req_path) const
-    {
-        for (const auto &rule : m_map_rules) {
-            std::string name = rule.match(m_token_subject, m_username, req_path, m_groups);
-            if (!name.empty()) {
-                return name;
-            }
-        }
-        return "";
+    if (!m_matcher.empty()) {
+        ss << ", authorizations=" << m_matcher.str();
     }
+    return ss.str();
+}
+
+bool XrdAccRules::expired() const
+{
+    return monotonic_time() > m_expiry_time;
+}
+
+// Determine whether a list of authorizations contains at least one entry
+// from each of the applicable required issuers.
+//
+// - `oper`: The operation type (read, write) to test for authorization.
+// - `path`: The requested path for the operation.
+// - `required_issuers`: A map from a list of paths to an issuer.
+// - `access_rules_list`: A list of access rules derived from the token
+//
+// If the requested path/operation matches one of the required issuers, then one
+// of the provided authorizations (e.g., the token's scopes) must come from that
+// issuer.
+//
+// The return value indicates whether the required authorization was missing, found,
+// or there was no required issuer for the path.
+bool AuthorizesRequiredIssuers(Access_Operation client_oper, const std::string_view &path,
+    const std::vector<std::pair<std::unique_ptr<SubpathMatch>, std::string>> &required_issuers,
+    const std::vector<std::shared_ptr<XrdAccRules>> &access_rules_list)
+{
 
-    const std::string str() const
-    {
-        std::stringstream ss;
-        ss << "mapped_username=" << m_username << ", subject=" << m_token_subject
-           << ", issuer=" << m_issuer;
-        if (!m_groups.empty()) {
-            ss << ", groups=";
-            bool first=true;
-            for (const auto &group : m_groups) {
-                ss << (first ? "" : ",") << group;
-                first = false;
+    // Translate the client-attempted operation to one of the simpler operations we've defined.
+    Access_Operation oper;
+    switch (client_oper) {
+        case AOP_Any:
+            return false; // Invalid request
+            break;
+        case AOP_Chmod: [[fallthrough]];
+        case AOP_Chown: [[fallthrough]];
+        case AOP_Create: [[fallthrough]];
+        case AOP_Excl_Create: [[fallthrough]];
+        case AOP_Delete: [[fallthrough]];
+        case AOP_Excl_Insert: [[fallthrough]];
+        case AOP_Insert: [[fallthrough]];
+        case AOP_Lock:
+            oper = AOP_Create;
+            break;
+        case AOP_Mkdir:
+            oper = AOP_Mkdir;
+            break;
+        case AOP_Read:
+            oper = AOP_Read;
+            break;
+        case AOP_Readdir:
+            oper = AOP_Readdir;
+            break;
+        case AOP_Rename:
+            oper = AOP_Create;
+            break;
+        case AOP_Stat:
+            oper = AOP_Stat;
+            break;
+        case AOP_Update:
+            oper = AOP_Update;
+            break;
+        default:
+            return false; // Invalid request
+    };
+
+    // Iterate through all the required issuers
+    for (const auto &info : required_issuers) {
+        // See if this issuer is required for this path/operation.
+        if (info.first->apply(oper, path)) {
+            bool has_authz = false;
+            // If so, see if one of the tokens (a) is from this issuer and (b) authorizes the request.
+            for (const auto &rules : access_rules_list) {
+                if (rules->get_issuer() == info.second && rules->apply(oper, path)) {
+                    has_authz = true;
+                    break;
+                }
+            }
+            if (!has_authz) {
+                return false;
             }
         }
-        if (!m_rules.empty()) {
-            ss << ", authorizations=" << AccessRuleStr(m_rules);
-        }
-        return ss.str();
     }
-
-
-        // Return the token's subject, an opaque unique string within the issuer's
-        // namespace.  It may or may not be related to the username one should
-        // use within the authorization framework.
-    const std::string & get_token_subject() const {return m_token_subject;}
-    const std::string & get_default_username() const {return m_username;}
-    const std::string & get_issuer() const {return m_issuer;}
-
-    uint32_t get_authz_strategy() const {return m_authz_strategy;}
-
-    size_t size() const {return m_rules.size();}
-    const std::vector<std::string> &groups() const {return m_groups;}
-
-private:
-    uint32_t m_authz_strategy;
-    AccessRulesRaw m_rules;
-    uint64_t m_expiry_time{0};
-    const std::string m_username;
-    const std::string m_token_subject;
-    const std::string m_issuer;
-    const std::vector<MapRule> m_map_rules;
-    const std::vector<std::string> m_groups;
-};
+    return true;
+}
 
 class XrdAccSciTokens;
 
 XrdAccSciTokens *accSciTokens = nullptr;
-XrdSciTokensHelper *SciTokensHelper = nullptr;
 
 class XrdAccSciTokens : public XrdAccAuthorize, public XrdSciTokensHelper,
                         public XrdSciTokensMon
@@ -500,164 +469,197 @@ class XrdAccSciTokens : public XrdAccAuthorize, public XrdSciTokensHelper,
                                   const Access_Operation oper,
                                         XrdOucEnv       *env) override
     {
-        const char *authz = env ? env->Get("authz") : nullptr;
-            // Note: this is more permissive than the plugin was previously.
-            // The prefix 'Bearer%20' used to be required as that's what HTTP
-            // required.  However, to make this more pleasant for XRootD protocol
-            // users, we now simply "handle" the prefix insterad of requiring it.
-        if (authz && !strncmp(authz, "Bearer%20", 9)) {
-            authz += 9;
-        }
-            // If there's no request-specific token, then see if the ZTN authorization
-            // has provided us with a session token.
-        if (!authz && Entity && !strcmp("ztn", Entity->prot) && Entity->creds &&
+        std::vector<std::string_view> authz_list;
+        authz_list.reserve(1);
+
+        // Parse the authz environment entry as a comma-separated list of tokens.
+        // Traditionally, `authz` has been used as the parameter for XRootD; however,
+        // RFC 6750 Section 2.3 ("URI Query Parameter") specifies that access_token
+        // is correct.  We support both.
+        ParseTokenString("authz", env, authz_list);
+        ParseTokenString("access_token", env, authz_list);
+
+        if (Entity && !strcmp("ztn", Entity->prot) && Entity->creds &&
             Entity->credslen && Entity->creds[Entity->credslen] == '\0')
         {
-            authz = Entity->creds;
+            authz_list.push_back(Entity->creds);
         }
-        if (authz == nullptr) {
+
+        if (authz_list.empty()) {
             return OnMissing(Entity, path, oper, env);
         }
+
+        // A potential DoS would be providing a large number of tokens to consider for ACLs.
+        // Have a hardcoded assumption of <10 tokens per request.
+        if (authz_list.size() > 10) {
+            m_log.Log(LogMask::Warning, "Access", "Request had more than 10 tokens attached; ignoring");
+            return OnMissing(Entity, path, oper, env);
+        }
+
         m_log.Log(LogMask::Debug, "Access", "Trying token-based access control");
-        std::shared_ptr<XrdAccRules> access_rules;
+        std::vector<std::shared_ptr<XrdAccRules>> access_rules_list;
         uint64_t now = monotonic_time();
         Check(now);
-        {
-            std::lock_guard<std::mutex> guard(m_mutex);
-            const auto iter = m_map.find(authz);
-            if (iter != m_map.end() && !iter->second->expired()) {
-                access_rules = iter->second;
-            }
-        }
-        if (!access_rules) {
-            m_log.Log(LogMask::Debug, "Access", "Token not found in recent cache; parsing.");
-            try {
-                uint64_t cache_expiry;
-                AccessRulesRaw rules;
-                std::string username;
-                std::string token_subject;
-                std::string issuer;
-                std::vector<MapRule> map_rules;
-                std::vector<std::string> groups;
-                uint32_t authz_strategy;
-                if (GenerateAcls(authz, cache_expiry, rules, username, token_subject, issuer, map_rules, groups, authz_strategy)) {
-                    access_rules.reset(new XrdAccRules(now + cache_expiry, username, token_subject, issuer, map_rules, groups, authz_strategy));
-                    access_rules->parse(rules);
-                } else {
-                    m_log.Log(LogMask::Warning, "Access", "Failed to generate ACLs for token");
-                    return OnMissing(Entity, path, oper, env);
+        for (const auto &authz : authz_list) {
+            std::shared_ptr<XrdAccRules> access_rules;
+            {
+                std::lock_guard<std::mutex> guard(m_mutex);
+                const auto iter = m_map.find(authz);
+                if (iter != m_map.end() && !iter->second->expired()) {
+                    access_rules = iter->second;
                 }
-                if (m_log.getMsgMask() & LogMask::Debug) {
-                    m_log.Log(LogMask::Debug, "Access", "New valid token", access_rules->str().c_str());
+            }
+            if (!access_rules) {
+                m_log.Log(LogMask::Debug, "Access", "Token not found in recent cache; parsing.");
+                try {
+                    uint64_t cache_expiry;
+                    AccessRulesRaw rules;
+                    std::string username;
+                    std::string token_subject;
+                    std::string issuer;
+                    std::vector<MapRule> map_rules;
+                    std::vector<std::string> groups;
+                    uint32_t authz_strategy;
+                    AuthzSetting acceptable_authz;
+                    if (GenerateAcls(authz, cache_expiry, rules, username, token_subject, issuer, map_rules, groups, authz_strategy, acceptable_authz)) {
+                        access_rules.reset(new XrdAccRules(now + cache_expiry, username, token_subject, issuer, map_rules, groups, authz_strategy, acceptable_authz));
+                        access_rules->parse(rules);
+                    } else {
+                        m_log.Log(LogMask::Warning, "Access", "Failed to generate ACLs for token");
+                        continue;
+                    }
+                    if (m_log.getMsgMask() & LogMask::Debug) {
+                        m_log.Log(LogMask::Debug, "Access", "New valid token", access_rules->str().c_str());
+                    }
+                } catch (std::exception &exc) {
+                    m_log.Log(LogMask::Warning, "Access", "Error generating ACLs for authorization", exc.what());
+                    continue;
                 }
-            } catch (std::exception &exc) {
-                m_log.Log(LogMask::Warning, "Access", "Error generating ACLs for authorization", exc.what());
-                return OnMissing(Entity, path, oper, env);
+                std::lock_guard<std::mutex> guard(m_mutex);
+                m_map[std::string(authz)] = access_rules;
+            } else if (m_log.getMsgMask() & LogMask::Debug) {
+                m_log.Log(LogMask::Debug, "Access", "Cached token", access_rules->str().c_str());
             }
-            std::lock_guard<std::mutex> guard(m_mutex);
-            m_map[authz] = access_rules;
-        } else if (m_log.getMsgMask() & LogMask::Debug) {
-            m_log.Log(LogMask::Debug, "Access", "Cached token", access_rules->str().c_str());
+            access_rules_list.push_back(access_rules);
+        }
+        if (access_rules_list.empty()) {
+            return OnMissing(Entity, path, oper, env);
+        }
+        std::string_view path_view(path, strlen(path));
+
+        // Apply the logic for the required issuers.
+        if (!AuthorizesRequiredIssuers(oper, path_view, m_required_issuers, access_rules_list)) {
+            return OnMissing(Entity, path, oper, env);
         }
 
         // Strategy: assuming the corresponding strategy is enabled, we populate the name in
         // the XrdSecEntity if:
         //    1. There are scopes present in the token that authorize the request,
         //    2. The token is mapped by some rule in the mapfile (group or subject-based mapping).
         // The default username for the issuer is only used in (1).
         // If the scope-based mapping is successful, authorize immediately.  Otherwise, if the
         // mapping is successful, we potentially chain to another plugin.
         //
         // We always populate the issuer and the groups, if present.
 
         // Access may be authorized; populate XrdSecEntity
-        XrdSecEntity new_secentity;
-        new_secentity.vorg = nullptr;
-        new_secentity.grps = nullptr;
-        new_secentity.role = nullptr;
-        new_secentity.secMon = Entity->secMon;
-        new_secentity.addrInfo = Entity->addrInfo;
-        const auto &issuer = access_rules->get_issuer();
-        if (!issuer.empty()) {
-            new_secentity.vorg = strdup(issuer.c_str());
-        }
-        bool group_success = false;
-        if ((access_rules->get_authz_strategy() & IssuerAuthz::Group) && access_rules->groups().size()) {
-            std::stringstream ss;
-            for (const auto &grp : access_rules->groups()) {
-                ss << grp << " ";
-            }
-            const auto &groups_str = ss.str();
-            new_secentity.grps = static_cast<char*>(malloc(groups_str.size() + 1));
-            if (new_secentity.grps) {
-                memcpy(new_secentity.grps, groups_str.c_str(), groups_str.size());
-                new_secentity.grps[groups_str.size()] = '\0';
-            }
-            group_success = true;
-        }
-
-        std::string username;
-        bool mapping_success = false;
-        bool scope_success = false;
-        username = access_rules->get_username(path);
-
-        mapping_success = (access_rules->get_authz_strategy() & IssuerAuthz::Mapping) && !username.empty();
-        scope_success = (access_rules->get_authz_strategy() & IssuerAuthz::Capability) && access_rules->apply(oper, path);
-        if (scope_success && (m_log.getMsgMask() & LogMask::Debug)) {
-            std::stringstream ss;
-            ss << "Grant authorization based on scopes for operation=" << OpToName(oper) << ", path=" << path;
-            m_log.Log(LogMask::Debug, "Access", ss.str().c_str());
-        }
-
-        if (!scope_success && !mapping_success && !group_success) {
-            auto returned_accs = OnMissing(&new_secentity, path, oper, env);
-            // Clean up the new_secentity
+        for (const auto &access_rules : access_rules_list) {
+            // Make sure this issuer is acceptable for the given operation.
+            if (!access_rules->acceptable_authz(oper)) {
+                m_log.Log(LogMask::Debug, "Access", "Issuer is not acceptable for given operation:", access_rules->get_issuer().c_str());
+                continue;
+            }
+
+            XrdSecEntity new_secentity;
+            new_secentity.vorg = nullptr;
+            new_secentity.grps = nullptr;
+            new_secentity.role = nullptr;
+            new_secentity.secMon = Entity->secMon;
+            new_secentity.addrInfo = Entity->addrInfo;
+            const auto &issuer = access_rules->get_issuer();
+            if (!issuer.empty()) {
+                new_secentity.vorg = strdup(issuer.c_str());
+            }
+            bool group_success = false;
+            if ((access_rules->get_authz_strategy() & IssuerAuthz::Group) && access_rules->groups().size()) {
+                std::stringstream ss;
+                for (const auto &grp : access_rules->groups()) {
+                    ss << grp << " ";
+                }
+                const auto &groups_str = ss.str();
+                new_secentity.grps = static_cast<char*>(malloc(groups_str.size() + 1));
+                if (new_secentity.grps) {
+                    memcpy(new_secentity.grps, groups_str.c_str(), groups_str.size());
+                    new_secentity.grps[groups_str.size()] = '\0';
+                }
+                group_success = true;
+            }
+
+            std::string username;
+            bool mapping_success = false;
+            bool scope_success = false;
+            username = access_rules->get_username(path_view);
+
+            mapping_success = (access_rules->get_authz_strategy() & IssuerAuthz::Mapping) && !username.empty();
+            scope_success = (access_rules->get_authz_strategy() & IssuerAuthz::Capability) && access_rules->apply(oper, path_view);
+            if (scope_success && (m_log.getMsgMask() & LogMask::Debug)) {
+                std::stringstream ss;
+                ss << "Grant authorization based on scopes for operation=" << OpToName(oper) << ", path=" << path;
+                m_log.Log(LogMask::Debug, "Access", ss.str().c_str());
+            }
+
+            if (!scope_success && !mapping_success && !group_success) {
+                auto returned_accs = OnMissing(&new_secentity, path, oper, env);
+                // Clean up the new_secentity
+                if (new_secentity.vorg != nullptr) free(new_secentity.vorg);
+                if (new_secentity.grps != nullptr) free(new_secentity.grps);
+                if (new_secentity.role != nullptr) free(new_secentity.role);
+
+                return returned_accs;
+            }
+
+            // Default user only applies to scope-based mappings.
+            if (scope_success && username.empty()) {
+                username = access_rules->get_default_username();
+            }
+
+            // Setting the request.name will pass the username to the next plugin.
+            // Ensure we do that only if map-based or scope-based authorization worked.
+            if (scope_success || mapping_success) {
+                // Set scitokens.name in the extra attribute
+                Entity->eaAPI->Add("request.name", username, true);
+                new_secentity.eaAPI->Add("request.name", username, true);
+                m_log.Log(LogMask::Debug, "Access", "Request username", username.c_str());
+            }
+
+                // Make the token subject available.  Even though it's a reasonably bad idea
+                // to use for *authorization* for file access, there may be other use cases.
+                // For example, the combination of (vorg, token.subject) is a reasonable
+                // approximation of a unique 'entity' (either person or a robot) and is
+                // more reasonable to use for resource fairshare in XrdThrottle.
+            const auto &token_subject = access_rules->get_token_subject();
+            if (!token_subject.empty()) {
+                Entity->eaAPI->Add("token.subject", token_subject, true);
+            }
+
+            // When the scope authorized this access, allow immediately.  Otherwise, chain
+            XrdAccPrivs returned_op = scope_success ? AddPriv(oper, XrdAccPriv_None) : OnMissing(&new_secentity, path, oper, env);
+
+            // Since we are doing an early return, insert token info into the
+            // monitoring stream if monitoring is in effect and access granted
+            //
+            if (Entity->secMon && scope_success && returned_op && Mon_isIO(oper))
+            Mon_Report(new_secentity, token_subject, username);
+
+            // Cleanup the new_secentry
             if (new_secentity.vorg != nullptr) free(new_secentity.vorg);
             if (new_secentity.grps != nullptr) free(new_secentity.grps);
             if (new_secentity.role != nullptr) free(new_secentity.role);
-
-            return returned_accs;
-        }
-
-        // Default user only applies to scope-based mappings.
-        if (scope_success && username.empty()) {
-            username = access_rules->get_default_username();
-        }
-
-        // Setting the request.name will pass the username to the next plugin.
-        // Ensure we do that only if map-based or scope-based authorization worked.
-        if (scope_success || mapping_success) {
-            // Set scitokens.name in the extra attribute
-            Entity->eaAPI->Add("request.name", username, true);
-            new_secentity.eaAPI->Add("request.name", username, true);
-            m_log.Log(LogMask::Debug, "Access", "Request username", username.c_str());
+            return returned_op;
         }
 
-            // Make the token subject available.  Even though it's a reasonably bad idea
-            // to use for *authorization* for file access, there may be other use cases.
-            // For example, the combination of (vorg, token.subject) is a reasonable
-            // approximation of a unique 'entity' (either person or a robot) and is
-            // more reasonable to use for resource fairshare in XrdThrottle.
-        const auto &token_subject = access_rules->get_token_subject();
-        if (!token_subject.empty()) {
-            Entity->eaAPI->Add("token.subject", token_subject, true);
-        }
-
-        // When the scope authorized this access, allow immediately.  Otherwise, chain
-        XrdAccPrivs returned_op = scope_success ? AddPriv(oper, XrdAccPriv_None) : OnMissing(&new_secentity, path, oper, env);
-
-        // Since we are doing an early return, insert token info into the
-        // monitoring stream if monitoring is in effect and access granted
-        //
-        if (Entity->secMon && scope_success && returned_op && Mon_isIO(oper))
-           Mon_Report(new_secentity, token_subject, username);
-
-        // Cleanup the new_secentry
-        if (new_secentity.vorg != nullptr) free(new_secentity.vorg);
-        if (new_secentity.grps != nullptr) free(new_secentity.grps);
-        if (new_secentity.role != nullptr) free(new_secentity.role);
-
-        return returned_op;
+        // We iterated through all available credentials and none provided authorization; fall back
+        return OnMissing(Entity, path, oper, env);
     }
 
     virtual  Issuers IssuerList() override
@@ -762,12 +764,12 @@ class XrdAccSciTokens : public XrdAccAuthorize, public XrdSciTokensHelper,
         return XrdAccPriv_None;
     }
 
-    bool GenerateAcls(const std::string &authz, uint64_t &cache_expiry, AccessRulesRaw &rules, std::string &username, std::string &token_subject, std::string &issuer, std::vector<MapRule> &map_rules, std::vector<std::string> &groups, uint32_t &authz_strategy) {
+    bool GenerateAcls(const std::string_view &authz, uint64_t &cache_expiry, AccessRulesRaw &rules, std::string &username, std::string &token_subject, std::string &issuer, std::vector<MapRule> &map_rules, std::vector<std::string> &groups, uint32_t &authz_strategy, AuthzSetting &acceptable_authz) {
         // Does this look like a JWT?  If not, bail out early and
         // do not pollute the log.
         bool looks_good = true;
         int separator_count = 0;
-        for (auto cur_char = authz.c_str(); *cur_char; cur_char++) {
+        for (auto cur_char = authz.data(); *cur_char; cur_char++) {
             if (*cur_char == '.') {
                 separator_count++;
                 if (separator_count > 2) {
@@ -792,7 +794,7 @@ class XrdAccSciTokens : public XrdAccAuthorize, public XrdSciTokensHelper,
         char *err_msg;
         SciToken token = nullptr;
         pthread_rwlock_rdlock(&m_config_lock);
-        auto retval = scitoken_deserialize(authz.c_str(), &token, &m_valid_issuers_array[0], &err_msg);
+        auto retval = scitoken_deserialize(authz.data(), &token, &m_valid_issuers_array[0], &err_msg);
         pthread_rwlock_unlock(&m_config_lock);
         if (retval) {
             // This originally looked like a JWT so log the failure.
@@ -1000,6 +1002,7 @@ class XrdAccSciTokens : public XrdAccAuthorize, public XrdSciTokensHelper,
         username = std::move(tmp_username);
         issuer = std::move(token_issuer);
         groups = std::move(groups_parsed);
+        acceptable_authz = config.m_acceptable_authz;
 
         return true;
     }
@@ -1137,6 +1140,33 @@ class XrdAccSciTokens : public XrdAccAuthorize, public XrdSciTokensHelper,
         return true;
     }
 
+    // A helper function for parsing one of the authorization setting variables (required_authz, acceptable_authz).
+    // The result object is only changed if the variable is set to a non-empty string in the configuration.
+    //
+    // Returns false on failure.
+    bool ParseAuthzSetting(OverrideINIReader &reader, const std::string &section, const std::string &variable, AuthzSetting &result) {
+        auto authz_setting_str = reader.Get(section, variable, "");
+        AuthzSetting authz_setting(AuthzSetting::None);
+        if (authz_setting_str == "") {
+            return true;
+        } else if (authz_setting_str == "none") {
+            authz_setting = AuthzSetting::None;
+        } else if (authz_setting_str == "all") {
+            authz_setting = AuthzSetting::All;
+        } else if (authz_setting_str == "read") {
+            authz_setting = AuthzSetting::Read;
+        } else if (authz_setting_str == "write") {
+            authz_setting = AuthzSetting::Write;
+        } else {
+            std::stringstream ss;
+            ss << "Failed to parse " << variable << " in section " << section << ": unknown authorization setting " << authz_setting_str;
+            m_log.Log(LogMask::Error, "Reconfig", ss.str().c_str());
+            return false;
+        }
+        result = authz_setting;
+        return true;
+    }
+
     bool Reconfig()
     {
         errno = 0;
@@ -1281,6 +1311,14 @@ class XrdAccSciTokens : public XrdAccAuthorize, public XrdSciTokensHelper,
             auto username_claim = reader.Get(section, "username_claim", "");
             auto groups_claim = reader.Get(section, "groups_claim", "wlcg.groups");
 
+            AuthzSetting required_authz(AuthzSetting::None), acceptable_authz(AuthzSetting::All);
+            if (!ParseAuthzSetting(reader, section, "required_authorization", required_authz)) {
+                m_log.Log(LogMask::Error, "Reconfig", "Ignoring required_authorization and using default of 'none'");
+            }
+            if (!ParseAuthzSetting(reader, section, "acceptable_authorization", acceptable_authz)) {
+                m_log.Log(LogMask::Error, "Reconfig", "Ignoring acceptable_authorization and using default of 'all'");
+            }
+
             auto authz_strategy_str = reader.Get(section, "authorization_strategy", "");
             uint32_t authz_strategy = 0;
             if (authz_strategy_str.empty()) {
@@ -1304,7 +1342,33 @@ class XrdAccSciTokens : public XrdAccAuthorize, public XrdSciTokensHelper,
             issuers.emplace(std::piecewise_construct,
                             std::forward_as_tuple(issuer),
                             std::forward_as_tuple(name, issuer, base_paths, restricted_paths,
-                                                  map_subject, authz_strategy, default_user, username_claim, groups_claim, rules));
+                                                  map_subject, authz_strategy, default_user, username_claim, groups_claim, rules,
+                                                  acceptable_authz, required_authz));
+
+            // If this is an issuer that is required for authorization, calculate the paths that it is
+            // responsible for.
+            if (required_authz != AuthzSetting::None) {
+                AccessRulesRaw rules;
+                for (const auto &base_path : base_paths) {
+                    if (restricted_paths.empty()) {
+                        restricted_paths.emplace_back("/");
+                    }
+                    for (const auto &restricted_path : restricted_paths) {
+                        auto full_path = base_path + "/" + restricted_path;
+                        std::string cleaned_path;
+                        MakeCanonical(full_path, cleaned_path);
+                        if (required_authz == AuthzSetting::Read || required_authz == AuthzSetting::All) {
+                            rules.emplace_back(AOP_Read, cleaned_path);
+                            rules.emplace_back(AOP_Stat, cleaned_path);
+                        } else if (required_authz == AuthzSetting::Write || required_authz == AuthzSetting::All) {
+                            rules.emplace_back(AOP_Create, cleaned_path);
+                            rules.emplace_back(AOP_Mkdir, cleaned_path);
+                            rules.emplace_back(AOP_Stat, cleaned_path);
+                        }
+                    }
+                }
+                m_required_issuers.emplace_back(std::make_unique<SubpathMatch>(rules), issuer);
+            }
         }
 
         if (issuers.empty()) {
@@ -1358,10 +1422,13 @@ class XrdAccSciTokens : public XrdAccAuthorize, public XrdSciTokensHelper,
     pthread_rwlock_t m_config_lock;
     std::vector<std::string> m_audiences;
     std::vector<const char *> m_audiences_array;
-    std::map<std::string, std::shared_ptr<XrdAccRules>> m_map;
+    std::map<std::string, std::shared_ptr<XrdAccRules>, std::less<>> m_map; // Note: std::less<> is used as the comparator to enable transparent casting from std::string_view for key lookup
     XrdAccAuthorize* m_chain;
     const std::string m_parms;
     std::vector<const char*> m_valid_issuers_array;
+    // Authorization from these issuers are required for any matching path.  The map tracks the
+    // base prefix to the issuer URL.
+    std::vector<std::pair<std::unique_ptr<SubpathMatch>, std::string>> m_required_issuers;
     std::unordered_map<std::string, IssuerConfig> m_issuers;
     uint64_t m_next_clean{0};
     XrdSysError m_log;
diff --git a/src/XrdSciTokens/XrdSciTokensAccess.hh b/src/XrdSciTokens/XrdSciTokensAccess.hh
new file mode 100644
index 000000000..09b1a8d0d
--- /dev/null
+++ b/src/XrdSciTokens/XrdSciTokensAccess.hh
@@ -0,0 +1,222 @@
+
+#include "XrdAcc/XrdAccAuthorize.hh"
+
+#include <memory>
+#include <string>
+#include <string_view>
+#include <vector>
+
+#include <string.h>
+
+/**
+ * Class and function definitions for the SciTokens plugin.
+ */
+
+typedef std::vector<std::pair<Access_Operation, std::string>> AccessRulesRaw;
+
+// Class representing a rule in the administrator-provided mapfile.
+// All predicates must match for the rule to apply.
+struct MapRule
+{
+    MapRule(const std::string &sub,
+            const std::string &username,
+            const std::string &path_prefix,
+            const std::string &group,
+            const std::string &result)
+        : m_sub(sub),
+          m_username(username),
+          m_path_prefix(path_prefix),
+          m_group(group),
+          m_result(result)
+    {
+        //std::cerr << "Making a rule {sub=" << sub << ", username=" << username << ", path=" << path_prefix << ", group=" << group << ", result=" << name << "}" << std::endl;
+    }
+
+    const std::string match(const std::string &sub,
+                            const std::string &username,
+                            const std::string_view &req_path,
+                            const std::vector<std::string> &groups) const
+    {
+        if (!m_sub.empty() && sub != m_sub) {return "";}
+
+        if (!m_username.empty() && username != m_username) {return "";}
+
+        if (!m_path_prefix.empty() &&
+            strncmp(req_path.data(), m_path_prefix.c_str(), m_path_prefix.size()))
+        {
+            return "";
+        }
+
+        if (!m_group.empty()) {
+            for (const auto &group : groups) {
+                if (group == m_group)
+                    return m_result;
+            }
+            return "";
+        }
+        return m_result;
+    }
+
+    std::string m_sub;
+    std::string m_username;
+    std::string m_path_prefix;
+    std::string m_group;
+    std::string m_result;
+};
+
+// Control whether a given issuer is required for the paths it authorizes
+enum class AuthzSetting {
+    None, // Issuer's authorization is not necessary
+    Read, // Authorization from this issuer is necessary for reads.
+    Write, // Authorization from this issuer is necessary for writes.
+    All, // Authorization from this issuer is necessary for all operations.
+};
+
+// Controls what part of the token is used to determine a positive authorization.
+//
+// E.g., if IssuerAuthz::Group is set, then the positive authorization may be based
+// on the groups embedded in the token.
+enum IssuerAuthz {
+    Capability = 0x01,
+    Group = 0x02,
+    Mapping = 0x04,
+    Default = 0x07
+};
+
+// Given a list of access rules, this class determines whether a requested operation / path
+// is permitted by the access rules.
+class SubpathMatch final {
+public:
+    SubpathMatch() = default;
+    SubpathMatch(const AccessRulesRaw &rules)
+    : m_rules(rules)
+    {}
+
+    // Determine whether the known access rules permit the requested `oper` on `path`.
+    bool apply(Access_Operation oper, const std::string_view path) const {
+        auto is_subdirectory = [](const std::string_view& dir, const std::string_view& subdir) {
+            if (subdir.size() < dir.size())
+                return false;
+
+            if (subdir.compare(0, dir.size(), dir, 0, dir.size()) != 0)
+                return false;
+
+            return dir.size() == subdir.size() || subdir[dir.size()] == '/' || dir == "/";
+        };
+
+        for (const auto & rule : m_rules) {
+            // Skip rules that don't match the current operation
+            if (rule.first != oper)
+                continue;
+
+            // If the rule allows any path, allow the operation
+            if (rule.second == "/")
+                return true;
+
+            // Allow operation if path is a subdirectory of the rule's path
+            if (is_subdirectory(rule.second, path)) {
+                return true;
+            } else {
+                // Allow stat and mkdir of parent directories to comply with WLCG token specs
+                if (oper == AOP_Stat || oper == AOP_Mkdir)
+                if (is_subdirectory(path, rule.second))
+                    return true;
+            }
+        }
+        return false;
+    }
+
+    bool empty() const {return m_rules.empty();} // Returns true if there are no rules to match
+
+    std::string str() const; // Returns a human-friendly representation of the access rules
+
+    size_t size() const {return m_rules.size();} // Returns the count of rules
+private:
+
+    AccessRulesRaw m_rules;
+};
+
+/**
+ * A class that encapsulates the access rules generated from a token.
+ * 
+ * The access rules are generated from the token's claims; the object
+ * is intended to be kept in a cache and periodically checked for expiration.
+ */
+class XrdAccRules
+{
+public:
+    XrdAccRules(uint64_t expiry_time, const std::string &username, const std::string &token_subject,
+        const std::string &issuer, const std::vector<MapRule> &rules, const std::vector<std::string> &groups,
+        uint32_t authz_strategy, AuthzSetting acceptable_authz) :
+        m_authz_strategy(authz_strategy),
+        m_acceptable_authz(acceptable_authz),
+        m_expiry_time(expiry_time),
+        m_username(username),
+        m_token_subject(token_subject),
+        m_issuer(issuer),
+        m_map_rules(rules),
+        m_groups(groups)
+    {}
+
+    ~XrdAccRules() {}
+
+    bool apply(Access_Operation oper, const std::string_view path) {
+        return m_matcher.apply(oper, path);
+    }
+
+    // Check to see if the access rules generated for this token have expired
+    bool expired() const;
+
+    void parse(const AccessRulesRaw &rules) {
+        m_matcher = SubpathMatch(rules);
+    }
+
+    std::string get_username(const std::string_view &req_path) const
+    {
+        for (const auto &rule : m_map_rules) {
+            std::string name = rule.match(m_token_subject, m_username, req_path, m_groups);
+            if (!name.empty()) {
+                return name;
+            }
+        }
+        return "";
+    }
+
+    const std::string str() const;
+
+        // Return the token's subject, an opaque unique string within the issuer's
+        // namespace.  It may or may not be related to the username one should
+        // use within the authorization framework.
+    const std::string & get_token_subject() const {return m_token_subject;}
+    const std::string & get_default_username() const {return m_username;}
+    const std::string & get_issuer() const {return m_issuer;}
+
+    uint32_t get_authz_strategy() const {return m_authz_strategy;}
+    bool acceptable_authz(Access_Operation oper) const {
+        if (m_acceptable_authz == AuthzSetting::All) return true;
+        if (m_acceptable_authz == AuthzSetting::None) return false;
+
+        bool is_read = oper == AOP_Read || oper == AOP_Readdir || oper == AOP_Stat;
+        if (is_read) return m_acceptable_authz == AuthzSetting::Read;
+        else return m_acceptable_authz == AuthzSetting::Write;
+    }
+
+    size_t size() const {return m_matcher.size();}
+    const std::vector<std::string> &groups() const {return m_groups;}
+
+private:
+    const uint32_t m_authz_strategy;
+    const AuthzSetting m_acceptable_authz;
+    SubpathMatch m_matcher;
+    const uint64_t m_expiry_time{0};
+    const std::string m_username;
+    const std::string m_token_subject;
+    const std::string m_issuer;
+    const std::vector<MapRule> m_map_rules;
+    const std::vector<std::string> m_groups;
+};
+
+bool AuthorizesRequiredIssuers(Access_Operation client_oper, const std::string_view &path,
+    const std::vector<std::pair<std::unique_ptr<SubpathMatch>, std::string>> &required_issuers,
+    const std::vector<std::shared_ptr<XrdAccRules>> &access_rules_list);
+
diff --git a/src/XrdTpc/XrdTpcUtils.cc b/src/XrdTpc/XrdTpcUtils.cc
index 26863cf9a..4f068f716 100644
--- a/src/XrdTpc/XrdTpcUtils.cc
+++ b/src/XrdTpc/XrdTpcUtils.cc
@@ -40,6 +40,9 @@ std::string XrdTpcUtils::prepareOpenURL(const std::string & reqResource, std::ma
           reqHeaders["Authorization"] = token.substr(6);
           has_authz_header = true;
         }
+      } else if (!strncmp(token.c_str(), "access_token=", 13) && !has_authz_header) {
+        reqHeaders["Authorization"] = token.substr(13);
+        has_authz_header = true;
       } else {
         opaque << (found_first_header ? "&" : "?") << token;
         found_first_header = true;
@@ -59,4 +62,4 @@ std::string XrdTpcUtils::prepareOpenURL(const std::string & reqResource, std::ma
   }
   hasSetOpaque = found_first_header;
   return reqResource + opaque.str();
-}
\ No newline at end of file
+}
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index 523682553..be570c3ce 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -18,6 +18,10 @@ add_subdirectory( XrdSsiTests )
 
 add_subdirectory(XrdTpcTests)
 
+if( BUILD_SCITOKENS )
+  add_subdirectory( scitokens )
+endif()
+
 if(NOT ENABLE_SERVER_TESTS)
   return()
 endif()
diff --git a/tests/XRootD/CMakeLists.txt b/tests/XRootD/CMakeLists.txt
index 6b469eb38..bd549ca95 100644
--- a/tests/XRootD/CMakeLists.txt
+++ b/tests/XRootD/CMakeLists.txt
@@ -9,6 +9,13 @@ if(ENABLE_HTTP_TESTS)
   list(APPEND XROOTD_CONFIGS http)
 endif()
 
+# Note: HAVE_SCITOKEN_CONFIG_SET_STR is required to override the CA file
+# for the scitokens library; otherwise, the test will fail with TLS errors.
+if(BUILD_SCITOKENS AND HAVE_SCITOKEN_CONFIG_SET_STR)
+  list(APPEND XROOTD_CONFIGS scitokens)
+  list(APPEND scitokens_FIXTURES SciTokens)
+endif()
+
 foreach(CONFIG ${XROOTD_CONFIGS})
   add_test(NAME XRootD::${CONFIG}::setup
     COMMAND sh -c "${CMAKE_CURRENT_SOURCE_DIR}/test.sh ${CONFIG} setup")
@@ -34,10 +41,19 @@ foreach(CONFIG ${XROOTD_CONFIGS})
   list(APPEND ${CONFIG}_LOGS ${CMAKE_CURRENT_BINARY_DIR}/${CONFIG}/client.log)
   list(APPEND ${CONFIG}_LOGS ${CMAKE_CURRENT_BINARY_DIR}/${CONFIG}/xrootd.log)
 
+  list(APPEND ${CONFIG}_FIXTURES XRootD::${CONFIG})
+
   set_tests_properties(XRootD::${CONFIG}::test
     PROPERTIES
-      FIXTURES_REQUIRED XRootD::${CONFIG}
+      FIXTURES_REQUIRED "${${CONFIG}_FIXTURES}"
       ENVIRONMENT "BINARY_DIR=${CMAKE_BINARY_DIR}"
       ATTACHED_FILES_ON_FAIL "${${CONFIG}_LOGS}"
   )
 endforeach()
+
+if(BUILD_SCITOKENS AND HAVE_SCITOKEN_CONFIG_SET_STR)
+  set_tests_properties(XRootD::scitokens::setup
+    PROPERTIES
+      FIXTURES_REQUIRED SciTokens
+  )
+endif()
diff --git a/tests/XRootD/scitokens-module.cfg b/tests/XRootD/scitokens-module.cfg
new file mode 100644
index 000000000..014e61f32
--- /dev/null
+++ b/tests/XRootD/scitokens-module.cfg
@@ -0,0 +1,12 @@
+[Global]
+audience = https://localhost:7095
+
+[Issuer test]
+issuer = https://localhost:7095/issuer/one
+base_path = /protected, /dual
+
+[Issuer test2]
+issuer = https://localhost:7095/issuer/two
+base_path = /dual
+required_authorization = all
+acceptable_authorization = none
diff --git a/tests/XRootD/scitokens.authdb b/tests/XRootD/scitokens.authdb
new file mode 100644
index 000000000..ac17e381c
--- /dev/null
+++ b/tests/XRootD/scitokens.authdb
@@ -0,0 +1 @@
+u * /issuer lr
diff --git a/tests/XRootD/scitokens.cfg b/tests/XRootD/scitokens.cfg
new file mode 100644
index 000000000..fb802fe6e
--- /dev/null
+++ b/tests/XRootD/scitokens.cfg
@@ -0,0 +1,26 @@
+set name = scitokens
+set port = 7095
+
+set pwd = $PWD
+set src = $SOURCE_DIR
+
+set scitokensdir = $PWD
+
+xrootd.seclib libXrdSec.so
+xrd.protocol XrdHttp:7095 libXrdHttp.so
+
+xrd.tlsca certfile $scitokensdir/../issuer/tlsca.pem
+xrd.tls $scitokensdir/../issuer/tls.crt $scitokensdir/../issuer/tls.key
+
+ofs.authlib ++ libXrdAccSciTokens.so config=$src/scitokens-module.cfg
+ofs.authorize 1
+acc.authdb $src/scitokens.authdb
+
+http.header2cgi Authorization authz
+http.exthandler xrdtpc libXrdHttpTPC.so
+
+# For root://-protocol test, force usage of a token.
+sec.protocol ztn
+sec.protbind * only ztn
+
+continue $src/common.cfg
diff --git a/tests/XRootD/scitokens.sh b/tests/XRootD/scitokens.sh
new file mode 100644
index 000000000..621889dd6
--- /dev/null
+++ b/tests/XRootD/scitokens.sh
@@ -0,0 +1,159 @@
+#!/usr/bin/env bash
+
+function setup_scitokens() {
+	require_commands curl
+
+	# Setup the issuer and protected directory
+	ln -sf "$PWD/../issuer/export" scitokens/xrootd/issuer
+	mkdir -p scitokens/xrootd/protected
+	echo 'Hello, World' > scitokens/xrootd/protected/hello_world.txt
+	mkdir -p "$PWD/scitokens/xrootd/dual"
+	echo 'Hello, World' > "$PWD/scitokens/xrootd/dual/hello_world.txt"
+
+	# Override the scitoken cache location; otherwise, contents of prior test runs may be cached
+	XDG_CACHE_HOME="${NAME}/cache"
+	export XDG_CACHE_HOME
+	mkdir -p "$XDG_CACHE_HOME/scitokens"
+
+	# Add the xrdscitokens-create-token command to the PATH to simplify invocations below.
+	PATH="$PWD/../scitokens:$PATH"
+
+	# Create a read-only token
+	OUTPUTDIR=$PWD/scitokens
+	pushd ../issuer || exit 1
+	if ! xrdscitokens-create-token issuer_pub_1.pem issuer_key_1.pem test_1 \
+		"https://localhost:7095/issuer/one" storage.read:/ > "$OUTPUTDIR/token"; then
+		echo "Failed to create token"
+		exit 1
+	fi
+	chmod 0600 "$OUTPUTDIR/token"
+
+	# Create a create-only token
+	if ! xrdscitokens-create-token issuer_pub_1.pem issuer_key_1.pem test_1 \
+		"https://localhost:7095/issuer/one" storage.create:/subdir > "$OUTPUTDIR/token_create"; then
+		echo "Failed to create 'storage.create' token"
+		exit 1
+	fi
+	chmod 0600 "$OUTPUTDIR/token_create"
+
+	# Create a modify token
+	if ! xrdscitokens-create-token issuer_pub_1.pem issuer_key_1.pem test_1 \
+		"https://localhost:7095/issuer/one" storage.modify:/subdir_modify > "$OUTPUTDIR/token_modify"; then
+		echo "Failed to create 'storage.modify' token"
+		exit 1
+	fi
+	chmod 0600 "$OUTPUTDIR/token_modify"
+
+	# Create an issuer-two read token
+	if ! xrdscitokens-create-token issuer_pub_2.pem issuer_key_2.pem test_2 \
+		"https://localhost:7095/issuer/two" storage.read:/ > "$OUTPUTDIR/token_two"; then
+		echo "Failed to create second 'storage.read' token from issuer two"
+		exit 1
+	fi
+
+	popd || exit 1
+}
+
+function execute_curl() {
+	url="$1"
+	expected_status="$2"
+	expected_contents="$3"
+	token_file="$4"
+	http_verb="$5"
+
+	token_arg=()
+	if [ -n "$token_file" ]; then
+		token_arg=(-H "Authorization: Bearer $(cat "$token_file")")
+	fi
+	verb_arg=()
+	if [ -n "$http_verb" ]; then
+		verb_arg=(-X "$http_verb" -d "$expected_contents")
+		echo -n "$http_verb $url "
+	else
+		echo -n "GET $url "
+	fi
+	token_arg=()
+	if [ -n "$token_file" ]; then
+		token_arg=(-H "Authorization: Bearer $(cat "$token_file")")
+		echo -n "with token file $token_file "
+	else
+		echo -n "with no token "
+	fi
+	echo "(expected $expected_status)"
+
+	# This does not use the "assert" helper function as we must redirect curl's output;
+	# "assert" does not allow redirects
+	if ! curl -s "${verb_arg[@]}" "${token_arg[@]}" -o "$TMPDIR/curl_output" -w "%{http_code}" \
+		--cacert "../issuer/tlsca.pem" "$url" > "$TMPDIR/curl_status"; then
+
+		echo "HTTP request failed.  Retrying with verbose output enabled:"
+		curl -s "${verb_arg[@]}" "${token_arg[@]}" -v --cacert "../issuer/tlsca.pem" "$url"
+		exit 1
+	fi
+	assert_eq "$expected_status" "$(cat "$TMPDIR/curl_status")"
+	if [ -n "$expected_contents" ] && [ -z "$http_verb" ]; then
+		assert_eq "$expected_contents" "$(cat "$TMPDIR/curl_output")"
+	fi
+}
+
+function test_scitokens() {
+	# The default $HOST construction uses $HOSTNAME in the URL; that will
+	# fail here because of the TLS verification (the certificate is generated
+	# with "localhost" instead).
+	HOST="roots://localhost:${XRD_PORT}/"
+	export X509_CERT_FILE=../issuer/tlsca.pem
+	export BEARER_TOKEN_FILE=scitokens/token
+	echo
+	echo "server: XRootD $(xrdfs "${HOST}" query config version 2>&1)"
+	echo
+
+	# create local temporary directory
+	TMPDIR=$(mktemp -d "${NAME}/test-XXXXXX")
+
+	# Perform tests over the root protocol using ZTN
+	unset BEARER_TOKEN_FILE
+	assert_failure xrdcp "$SOURCE_DIR/scitokens.cfg" "$HOST/protected/subdir/root/scitokens.cfg"
+	export BEARER_TOKEN_FILE=scitokens/token_create
+	xrdcp "$SOURCE_DIR/scitokens.cfg" "$HOST/protected/subdir/root/scitokens.cfg"
+	assert_failure xrdcp -f "$HOST/protected/subdir/root/scitokens.cfg" .
+	export BEARER_TOKEN_FILE=scitokens/token
+	assert xrdcp -f "$HOST/protected/subdir/root/scitokens.cfg" .
+	assert diff -u "$SOURCE_DIR/scitokens.cfg" scitokens.cfg
+
+	# from now on, we use HTTP
+	export HOST=https://localhost:7095
+
+	execute_curl "$HOST/issuer/one/issuer.jwks" 200 "$(cat scitokens/xrootd/issuer/one/issuer.jwks)"
+	execute_curl "$HOST/protected/hello_world.txt" 403 ""
+	execute_curl "$HOST/protected/hello_world.txt" 200 "Hello, World" scitokens/token
+
+	# Downloading $HOST/protected/hello_world.txt with create-only token (expected 403)
+	execute_curl "$HOST/protected/hello_world.txt" 403 "" scitokens/token_create
+
+	# Uploading $HOST/protected/subdir/hello_world.txt with create-only token (expected 201)
+	execute_curl "$HOST/protected/subdir/hello_world.txt" 201 "hello, world" scitokens/token_create PUT
+	execute_curl "$HOST/protected/subdir/hello_world.txt" 200 "hello, world" scitokens/token
+
+	# Re-uploading $HOST/protected/subdir/hello_world.txt with create-only token (expected 403)
+	execute_curl "$HOST/protected/subdir/hello_world.txt" 403 "hello, world" scitokens/token_create PUT
+
+	# Uploading $HOST/protected/subdir_modify/hello_world.txt with modify token (expected 201)"
+	execute_curl "$HOST/protected/subdir_modify/hello_world.txt" 201 test scitokens/token_modify PUT
+	execute_curl "$HOST/protected/subdir_modify/hello_world.txt" 200 test scitokens/token
+
+	# Re-uploading $HOST/protected/subdir_modify/hello_world.txt with modify token (expected 201)
+	execute_curl "$HOST/protected/subdir_modify/hello_world.txt" 201 'hello, world' scitokens/token_modify PUT
+	execute_curl "$HOST/protected/subdir_modify/hello_world.txt" 200 'hello, world' scitokens/token
+
+	###
+	## Tests for requiring multiple tokens to authorize an operation
+	###
+	execute_curl "$HOST/dual/hello_world.txt" 403 "" scitokens/token
+	execute_curl "$HOST/dual/hello_world.txt" 403 "" scitokens/token_two
+	execute_curl "$HOST/dual/hello_world.txt?access_token=$(cat scitokens/token)" 200 "" scitokens/token_two
+
+	HOST="roots://localhost:${XRD_PORT}/"
+	export BEARER_TOKEN_FILE=scitokens/token
+	assert xrdcp -f "$HOST/dual/hello_world.txt?authz=$(cat scitokens/token_two)" .
+	assert_eq "Hello, World" "$(cat hello_world.txt)"
+}
diff --git a/tests/XrdOucTests/CMakeLists.txt b/tests/XrdOucTests/CMakeLists.txt
index 3a7236752..4928f88ac 100644
--- a/tests/XrdOucTests/CMakeLists.txt
+++ b/tests/XrdOucTests/CMakeLists.txt
@@ -1,4 +1,4 @@
-add_executable(xrdoucutils-unit-tests XrdOucUtilsTests.cc)
+add_executable(xrdoucutils-unit-tests XrdOucUtilsTests.cc XrdOucEnvTests.cc)
 
 target_link_libraries(xrdoucutils-unit-tests XrdUtils GTest::GTest GTest::Main)
 target_include_directories(xrdoucutils-unit-tests PRIVATE ${CMAKE_SOURCE_DIR}/src)
diff --git a/tests/XrdOucTests/XrdOucEnvTests.cc b/tests/XrdOucTests/XrdOucEnvTests.cc
new file mode 100644
index 000000000..ac8fe6da6
--- /dev/null
+++ b/tests/XrdOucTests/XrdOucEnvTests.cc
@@ -0,0 +1,28 @@
+
+#include "XrdOuc/XrdOucEnv.hh"
+
+#include <gtest/gtest.h>
+
+static const std::pair<std::string, std::string> env_tests[] = {
+    {"foo=bar", "&foo=bar"},
+    {"authz=bar", "&"},
+    {"authz=bar&foo=1", "&foo=1"},
+    {"&authz=bar&authz=1", "&"},
+    {"authz=bar&authz=1", "&"},
+    {"&authz=bar", "&"},
+    {"&access_token=bar", "&"},
+    {"foo=1&authz=bar", "&foo=1"},
+    {"foo=1&authz=foo&access_token=bar", "&foo=1"},
+    {"authz=foo&access_token=bar", "&"},
+    {"authz=foo&foo=bar", "&foo=bar"},
+    {"authz=foo&foo=bar&access_token=3", "&foo=bar"},
+    {"authz=1&access_token=2&authz=3&access_token=4", "&"},
+};
+
+TEST(XrdOucEnv, EnvTidy) {
+    for (const auto &env_str : env_tests) {
+        int envlen;
+        XrdOucEnv env(env_str.first.c_str(), env_str.first.size());
+        ASSERT_STREQ(env_str.second.c_str(), env.EnvTidy(envlen)) << "Testing tidy of " << env_str.first;
+    }	    
+}
diff --git a/tests/XrdOucTests/XrdOucUtilsTests.cc b/tests/XrdOucTests/XrdOucUtilsTests.cc
index 3deafc95e..84961f9ad 100644
--- a/tests/XrdOucTests/XrdOucUtilsTests.cc
+++ b/tests/XrdOucTests/XrdOucUtilsTests.cc
@@ -92,13 +92,16 @@ static const std::string plain_urls[] = {
 
 static const std::string authz_strings[] = {
   "authz=REDACTED",
+  "access_token=REDACTED",
   " authz=REDACTED ",
   " 'authz=REDACTED' ",
   " \"authz=REDACTED\" ",
   "authz=REDACTED&scitag.flow=144&test=abcd",
+  "access_token=REDACTED&scitag.flow=144&test=abcd",
   "scitag.flow=144&authz=REDACTED&test=abcd",
   "scitag.flow=144&test=abcd&authz=REDACTED",
   "authz=REDACTED&test=test2&authz=REDACTED",
+  "authz=REDACTED&test=test2&access_token=REDACTED",
   "authz=REDACTED&test=test2&authz=REDACTED&authz=REDACTED&test=test2&authz=REDACTED",
   "/path/test.txt?scitag.flow=44&authz=REDACTED done close.",
   "/path/test.txt?authz=REDACTED&scitag.flow=44 done close.",
diff --git a/tests/scitokens/CMakeLists.txt b/tests/scitokens/CMakeLists.txt
new file mode 100644
index 000000000..16d2ef56d
--- /dev/null
+++ b/tests/scitokens/CMakeLists.txt
@@ -0,0 +1,34 @@
+
+add_executable(xrdscitokens-create-jwks XrdScitokensCreateJwks.cc)
+target_link_libraries(xrdscitokens-create-jwks PRIVATE OpenSSL::Crypto)
+
+add_executable(xrdscitokens-create-token XrdScitokensCreateToken.cc)
+target_link_libraries(xrdscitokens-create-token PRIVATE ${SCITOKENS_CPP_LIBRARIES})
+target_include_directories(xrdscitokens-create-token PRIVATE ${SCITOKENS_CPP_INCLUDE_DIR})
+
+add_executable(xrdscitokens-unit-tests
+  XrdSciTokens.cc
+)
+
+target_link_libraries(xrdscitokens-unit-tests
+  XrdSciTokensObj GTest::GTest GTest::Main)
+
+gtest_discover_tests(xrdscitokens-unit-tests)
+
+add_test(NAME SciTokens::setup
+  COMMAND sh -c "${CMAKE_CURRENT_SOURCE_DIR}/setup.sh ${CMAKE_BINARY_DIR}/tests/issuer")
+
+set_tests_properties(SciTokens::setup
+  PROPERTIES
+    FIXTURES_SETUP SciTokens
+    ENVIRONMENT "BINARY_DIR=${CMAKE_BINARY_DIR}"
+)
+
+add_test(NAME SciTokens::teardown
+  COMMAND sh -c "${CMAKE_CURRENT_SOURCE_DIR}/teardown.sh ${CMAKE_BINARY_DIR}/tests/issuer")
+
+set_tests_properties(SciTokens::teardown
+  PROPERTIES
+    FIXTURES_CLEANUP SciTokens
+    ENVIRONMENT "BINARY_DIR=${CMAKE_BINARY_DIR}"
+)
diff --git a/tests/scitokens/XrdSciTokens.cc b/tests/scitokens/XrdSciTokens.cc
new file mode 100644
index 000000000..9f85263c4
--- /dev/null
+++ b/tests/scitokens/XrdSciTokens.cc
@@ -0,0 +1,73 @@
+
+#include "XrdSciTokens/XrdSciTokensAccess.hh"
+
+#include <gtest/gtest.h>
+
+TEST(XrdSciTokens, MapRule) {
+  MapRule rule("subject", "user", "/prefix", "group", "result");
+  ASSERT_EQ("", rule.match("not subject", "not user", "/foo", {"not group"}));
+  ASSERT_EQ("", rule.match("subject", "not user", "/foo", {"not group"}));
+  ASSERT_EQ("", rule.match("subject", "not user", "/foo", {"not group"}));
+  ASSERT_EQ("", rule.match("not subject", "user", "/foo", {"not group"}));
+  ASSERT_EQ("", rule.match("not subject", "not user", "/prefix/baz", {"not group"}));
+  ASSERT_EQ("", rule.match("not subject", "not user", "/foo", {"group"}));
+  ASSERT_EQ("result", rule.match("subject", "user", "/prefix/foo", {"group"}));
+  ASSERT_EQ("result", rule.match("subject", "user", "/prefix/foo", {"not group", "group"}));
+}
+
+TEST(XrdSciTokens, SubpathMatch) {
+  SubpathMatch matcher({{AOP_Read, "/prefix"}});
+  ASSERT_EQ(false, matcher.apply(AOP_Read, "/prefix1"));
+  ASSERT_EQ(false, matcher.apply(AOP_Create, "/prefix"));
+  ASSERT_EQ(true, matcher.apply(AOP_Read, "/prefix"));
+  ASSERT_EQ(true, matcher.apply(AOP_Read, "/prefix/foo"));
+
+  // Test handling of root paths
+  matcher = SubpathMatch({{AOP_Create, "/"}});
+  ASSERT_EQ(true, matcher.apply(AOP_Create, "/bar/baz"));
+  ASSERT_EQ(false, matcher.apply(AOP_Stat, "/bar/baz"));
+
+  // Test special handling of parent prefixes
+  matcher = SubpathMatch({{AOP_Stat, "/foo/bar"}});
+  ASSERT_EQ(true, matcher.apply(AOP_Stat, "/foo"));
+  ASSERT_EQ(false, matcher.apply(AOP_Read, "/foo"));
+  matcher = SubpathMatch({{AOP_Mkdir, "/foo/bar"}});
+  ASSERT_EQ(true, matcher.apply(AOP_Mkdir, "/foo"));
+  ASSERT_EQ(1, matcher.size());
+  ASSERT_FALSE(matcher.empty());
+  ASSERT_EQ("/foo/bar:mkdir", matcher.str());
+
+  matcher = SubpathMatch();
+  ASSERT_EQ(0, matcher.size());
+  ASSERT_TRUE(matcher.empty());
+}
+
+
+TEST(XrdSciTokens, AuthorizesRequiredIssuers) {
+  AccessRulesRaw rules{{AOP_Read, "/prefix"}, {AOP_Mkdir, "/prefix2/nested"}};
+  auto matcher = std::make_unique<SubpathMatch>(rules);
+  std::vector<std::pair<std::unique_ptr<SubpathMatch>, std::string>> required_issuers;
+  required_issuers.emplace_back(std::move(matcher), "https://example.com");
+
+  auto access_rule_entry_ptr = new XrdAccRules(0, "username", "token_sub", "https://example.com", {}, {}, IssuerAuthz::Capability, AuthzSetting::None);
+  std::shared_ptr<XrdAccRules> access_rule_entry(access_rule_entry_ptr);
+  access_rule_entry->parse({{AOP_Read, "/prefix"}});
+
+  access_rule_entry_ptr = new XrdAccRules(0, "username", "token_sub", "https://example-other.com", {}, {}, IssuerAuthz::Capability, AuthzSetting::None);
+  std::shared_ptr<XrdAccRules> access_rule_entry_other(access_rule_entry_ptr);
+  access_rule_entry_other->parse({{AOP_Read, "/prefix"}});
+
+  ASSERT_EQ(true, AuthorizesRequiredIssuers(AOP_Read, "/prefix/foo", required_issuers, {access_rule_entry}));
+  ASSERT_EQ(true, AuthorizesRequiredIssuers(AOP_Read, "/foo", required_issuers, {access_rule_entry}));
+  ASSERT_EQ(false, AuthorizesRequiredIssuers(AOP_Read, "/prefix/foo", required_issuers, {access_rule_entry_other}));
+  ASSERT_EQ(false, AuthorizesRequiredIssuers(AOP_Read, "/prefix", required_issuers, {access_rule_entry_other}));
+  ASSERT_EQ(true, AuthorizesRequiredIssuers(AOP_Read, "/prefix2", required_issuers, {access_rule_entry_other}));
+  ASSERT_EQ(true, AuthorizesRequiredIssuers(AOP_Create, "/prefix/foo", required_issuers, {access_rule_entry_other}));
+  ASSERT_EQ(true, AuthorizesRequiredIssuers(AOP_Mkdir, "/prefix", required_issuers, {access_rule_entry_other}));
+  ASSERT_EQ(true, AuthorizesRequiredIssuers(AOP_Mkdir, "/prefix", required_issuers, {access_rule_entry}));
+  ASSERT_EQ(false, AuthorizesRequiredIssuers(AOP_Mkdir, "/prefix2", required_issuers, {access_rule_entry}));
+
+  required_issuers.emplace_back(std::make_unique<SubpathMatch>(rules), "https://example-other.com");
+  ASSERT_EQ(false, AuthorizesRequiredIssuers(AOP_Read, "/prefix/foo", required_issuers, {access_rule_entry}));
+  ASSERT_EQ(true, AuthorizesRequiredIssuers(AOP_Read, "/prefix/foo", required_issuers, {access_rule_entry, access_rule_entry_other}));
+}
\ No newline at end of file
diff --git a/tests/scitokens/XrdScitokensCreateJwks.cc b/tests/scitokens/XrdScitokensCreateJwks.cc
new file mode 100644
index 000000000..db89ceafe
--- /dev/null
+++ b/tests/scitokens/XrdScitokensCreateJwks.cc
@@ -0,0 +1,215 @@
+
+
+///
+// Given a PEM-formatted EC public key, create an equivalent JWKS file
+// with the specified KID
+
+/*
+
+Example JWKS:
+
+```
+{
+  "keys": [
+    {
+      "alg": "ES256",
+      "kid": "key",
+      "kty": "EC",
+      "use": "sig",
+      "x": "ncSCrGTBTXXOhNiAOTwNdPjwRz1hVY4saDNiHQK9Bh4=",
+      "y": "sCsFXvx7FAAklwq3CzRCBcghqZOFPB2dKUayS6LY_Lo="
+    }
+  ]
+}
+```
+
+*/
+
+#include <openssl/bio.h>
+#include <openssl/bn.h>
+#include <openssl/ec.h>
+#include <openssl/evp.h>
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+#include <openssl/param_build.h>
+#endif
+#include <openssl/pem.h>
+
+#define EC_NAME NID_X9_62_prime256v1
+
+
+#include <stdio.h>
+#include <string.h>
+
+#include <algorithm>
+#include <iostream>
+#include <memory>
+#include <string>
+#include <string_view>
+#include <vector>
+
+std::string b64url_encode_nopadding(std::string_view input) {
+    std::unique_ptr<BIO, decltype(&BIO_free_all)> mem_bio(
+        BIO_new(BIO_s_mem()), BIO_free_all);
+    std::unique_ptr<BIO, decltype(&BIO_free_all)> b64_bio(
+        BIO_new(BIO_f_base64()), BIO_free_all);
+    BIO_push(b64_bio.get(), mem_bio.get());
+    auto mem_ptr = mem_bio.release();
+    BIO_set_flags(b64_bio.get(), BIO_FLAGS_BASE64_NO_NL);
+    BIO_write(b64_bio.get(), input.data(), input.length());
+    BIO_flush(b64_bio.get());
+
+    char *b64_data;
+    auto len = BIO_get_mem_data(mem_ptr, &b64_data);
+    if (len < 0) {
+        return "";
+    }
+
+    std::string result(b64_data, len);
+    std::replace(result.begin(), result.end(), '+', '-');
+    std::replace(result.begin(), result.end(), '/', '_');
+    return result.substr(0, result.find('='));
+}
+
+bool readPubkey(const std::string &fname, std::string &x, std::string &y) {
+    std::unique_ptr<BIO, decltype(&BIO_free_all)> pubkey_bio(
+        BIO_new_file(fname.c_str(), "r"), BIO_free_all);
+
+    if (!pubkey_bio) {
+      std::cerr << "Failed to load public key from " << fname << ": " << strerror(errno) << std::endl;
+      return false;
+    }
+
+    std::unique_ptr<BIGNUM, decltype(&BN_free)> x_bignum(BN_new(), BN_free);
+    std::unique_ptr<BIGNUM, decltype(&BN_free)> y_bignum(BN_new(), BN_free);
+
+#if OPENSSL_VERSION_NUMBER >= 0x30000000L
+    std::unique_ptr<EVP_PKEY, decltype(&EVP_PKEY_free)> pkey(
+        PEM_read_bio_PUBKEY(pubkey_bio.get(), nullptr, nullptr, nullptr),
+        EVP_PKEY_free);
+    if (!pkey.get()) {
+        return false;
+    }
+
+    std::unique_ptr<EC_GROUP, decltype(&EC_GROUP_free)> ec_group(
+        EC_GROUP_new_by_curve_name(EC_NAME), EC_GROUP_free);
+    if (!ec_group.get()) {
+        std::cerr << "Unable to get OpenSSL EC group" << std::endl;
+        return false;
+    }
+
+    std::unique_ptr<EC_POINT, decltype(&EC_POINT_free)> q_point(
+        EC_POINT_new(ec_group.get()), EC_POINT_free);
+    if (!q_point.get()) {
+        std::cerr << "Unable to get OpenSSL EC point" << std::endl;
+        return false;
+    }
+
+    OSSL_PARAM *params;
+    if (!EVP_PKEY_todata(pkey.get(), EVP_PKEY_PUBLIC_KEY, &params)) {
+        std::cerr << "Unable to get OpenSSL public key parameters" << std::endl;
+        return false;
+    }
+
+    void *buf = NULL;
+    size_t buf_len, max_len = 256;
+    OSSL_PARAM *p = OSSL_PARAM_locate(params, "pub");
+    if (!p || !OSSL_PARAM_get_octet_string(p, &buf, max_len, &buf_len) ||
+        !EC_POINT_oct2point(ec_group.get(), q_point.get(),
+                            static_cast<unsigned char *>(buf), buf_len,
+                            nullptr)) {
+        std::cerr << "Failed to to set OpenSSL EC point with public key information" << std::endl;
+        return false;
+    }
+
+    if (!EC_POINT_get_affine_coordinates(ec_group.get(), q_point.get(),
+                                         x_bignum.get(), y_bignum.get(),
+                                         NULL)) {
+        std::cerr << "Unable to get OpenSSL affine coordinates" << std::endl;
+        return false;
+    }
+
+    OSSL_PARAM_free(params);
+#else
+    std::unique_ptr<EC_KEY, decltype(&EC_KEY_free)> pkey(
+        PEM_read_bio_EC_PUBKEY(pubkey_bio.get(), nullptr, nullptr, nullptr),
+        EC_KEY_free);
+    if (!pkey) {
+        return false;
+    }
+
+    EC_GROUP *params = (EC_GROUP *)EC_KEY_get0_group(pkey.get());
+    if (!params) {
+        std::cerr << "Unable to get OpenSSL EC group" << std::endl;
+        return false;
+    }
+
+    const EC_POINT *point = EC_KEY_get0_public_key(pkey.get());
+    if (!point) {
+        std::cerr << "Unable to get OpenSSL EC point" << std::endl;
+        return false;
+    }
+
+    if (!EC_POINT_get_affine_coordinates_GFp(params, point, x_bignum.get(),
+                                             y_bignum.get(), nullptr)) {
+        std::cerr << "Unable to get OpenSSL affine coordinates" << std::endl;
+        return false;
+    }
+#endif
+
+    auto x_num = BN_num_bytes(x_bignum.get());
+    auto y_num = BN_num_bytes(y_bignum.get());
+    std::vector<unsigned char> x_bin;
+    x_bin.resize(x_num);
+    std::vector<unsigned char> y_bin;
+    y_bin.resize(y_num);
+    BN_bn2bin(x_bignum.get(), &x_bin[0]);
+    BN_bn2bin(y_bignum.get(), &y_bin[0]);
+    x = b64url_encode_nopadding(std::string(reinterpret_cast<char *>(&x_bin[0]), x_num));
+    y = b64url_encode_nopadding(std::string(reinterpret_cast<char *>(&y_bin[0]), y_num));
+
+    return true;
+}
+
+int main(int argc, char *argv[]) {
+    if (argc != 4) {
+        std::cerr << "Usage: " << argv[0] << " issuer.pem issuer.jwks kid" << std::endl;
+        return 1;
+    }
+
+    std::string x, y;
+    if (!readPubkey(argv[1], x, y)) {
+        std::cerr << "Failed to read EC pubkey " << argv[1] << std::endl;
+        return 2;
+    }
+
+    auto fd = fopen(argv[2], "w");
+    if (!fd) {
+        std::cerr << "Failed to open output JWKS " << argv[2] << ": " << strerror(errno) << std::endl;
+        return 3;
+    }
+
+    auto rc = fprintf(fd, R"(
+{
+  "keys": [
+    {
+      "alg": "ES256",
+      "crv": "P-256",
+      "kid": "%s",
+      "kty": "EC",
+      "use": "sig",
+      "x": "%s",
+      "y": "%s"
+    }
+  ]
+}
+)",
+    argv[3],
+    x.c_str(),
+    y.c_str());
+
+    if (rc < 0) {
+        std::cerr << "Error writing to output file: " << strerror(errno) << std::endl;
+        return 4;
+    }
+    return 0;
+}
diff --git a/tests/scitokens/XrdScitokensCreateToken.cc b/tests/scitokens/XrdScitokensCreateToken.cc
new file mode 100644
index 000000000..2962a693e
--- /dev/null
+++ b/tests/scitokens/XrdScitokensCreateToken.cc
@@ -0,0 +1,145 @@
+
+
+///
+// Create a sample token useful for unit tests
+///
+
+#include <scitokens/scitokens.h>
+
+#include <fcntl.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include <iostream>
+#include <memory>
+#include <string>
+#include <string_view>
+#include <vector>
+
+
+ssize_t fullRead(int fd, void *ptr, size_t nbytes) {
+    ssize_t nleft, nread;
+
+    nleft = nbytes;
+    while (nleft > 0) {
+REISSUE_READ:
+        nread = read(fd, ptr, nleft);
+        if (nread < 0) {
+            if (errno == EINTR) {
+                goto REISSUE_READ;
+            }
+
+            return -1;
+        } else if (nread == 0) {
+            break;
+        }
+
+        nleft -= nread;
+        ptr = ((char *)ptr) + nread;
+    }
+
+    return (nbytes - nleft);
+}
+
+
+bool readShortFile(const std::string &fileName, std::string &contents) {
+    int fd = open(fileName.c_str(), O_RDONLY, 0600);
+
+    if (fd < 0) {
+        std::cerr << "Failed to open " << fileName << ": " << strerror(errno) << std::endl;
+        return false;
+    }
+
+    struct stat statbuf;
+    int rv = fstat(fd, &statbuf);
+    if (rv < 0) {
+        std::cerr << "Failed to fstat " << fileName << ": " << strerror(errno) << std::endl;
+        return false;
+    }
+    unsigned long fileSize = statbuf.st_size;
+    if (fileSize > 1024*1024) {
+        std::cerr << "File " << fileName << " too large for reading to memory" << std::endl;
+        return false;
+    }
+
+    std::unique_ptr<char, decltype(&std::free)> rawBuffer((char*)malloc(fileSize + 1), &std::free);
+    if (!rawBuffer) {
+        std::cerr << "Failed to allocate memory buffer" << std::endl;
+        return false;
+    }
+    unsigned long totalRead = fullRead(fd, rawBuffer.get(), fileSize);
+    if (totalRead != fileSize) {
+        std::cerr << "Failed to fully read file " << fileName << ": " << strerror(errno) << std::endl;
+        close(fd);
+        return false;
+    }
+    close(fd);
+    contents.assign(rawBuffer.get(), fileSize);
+
+    return true;
+}
+
+
+int main(int argc, char *argv[]) {
+    if (argc != 6) {
+        std::cerr << "Usage: " << argv[0] << " issuer.pem issuer.key kid iss prefix" << std::endl;
+        return 1;
+    }
+
+    std::string pubkey, privkey;
+    if (!readShortFile(argv[1], pubkey)) {
+        return 2;
+    }
+    if (!readShortFile(argv[2], privkey)) {
+        return 3;
+    }
+
+    using KeyPtr = std::unique_ptr<void, decltype(&scitoken_key_destroy)>;
+    using TokenPtr = std::unique_ptr<void, decltype(&scitoken_destroy)>;
+
+    char *err_msg = nullptr;
+    KeyPtr key(scitoken_key_create(argv[3], "ES256", pubkey.c_str(), privkey.c_str(), &err_msg), scitoken_key_destroy);
+    if (!key) {
+        std::cerr << err_msg << std::endl;
+        return 4;
+    }
+
+    TokenPtr token(scitoken_create(key.get()), scitoken_destroy);
+    if (!token) {
+        std::cerr << err_msg << std::endl;
+        return 5;
+    }
+
+    auto rv = scitoken_set_claim_string(token.get(), "iss", argv[4], &err_msg);
+    if (rv) {
+        std::cerr << err_msg << std::endl;
+        return 6;
+    }
+
+    rv = scitoken_set_claim_string(token.get(), "scope", argv[5], &err_msg);
+    if (rv) {
+        std::cerr << err_msg << std::endl;
+        return 7;
+    }
+
+    rv = scitoken_set_claim_string(token.get(), "sub", "test", &err_msg);
+    if (rv) {
+        std::cerr << err_msg << std::endl;
+        return 8;
+    }
+
+    scitoken_set_lifetime(token.get(), 60);
+    scitoken_set_serialize_profile(token.get(), SciTokenProfile::WLCG_1_0);
+
+    char *token_value;
+    rv = scitoken_serialize(token.get(), &token_value, &err_msg);
+    if (rv) {
+        std::cerr << err_msg << std::endl;
+        return 9;
+    }
+    printf("%s\n", token_value);
+    free(token_value);
+    return 0;
+}
diff --git a/tests/scitokens/one-openid-configuration b/tests/scitokens/one-openid-configuration
new file mode 100644
index 000000000..18c607be7
--- /dev/null
+++ b/tests/scitokens/one-openid-configuration
@@ -0,0 +1,3 @@
+{
+  "jwks_uri": "https://localhost:7095/issuer/one/issuer.jwks"
+}
diff --git a/tests/scitokens/setup.sh b/tests/scitokens/setup.sh
new file mode 100644
index 000000000..e8f07647f
--- /dev/null
+++ b/tests/scitokens/setup.sh
@@ -0,0 +1,127 @@
+#!/bin/bash
+
+ISSUERDIR="$1"
+
+mkdir -p "$ISSUERDIR"
+pushd "$ISSUERDIR" || exit 1
+
+###
+## Generate two different issuer keys
+###
+
+for idx in 1 2; do
+  # Generate signing key and public version
+  if ! openssl ecparam -name prime256v1 -genkey -noout -out "issuer_key_$idx.pem"; then
+    echo "Failed to generate EC private key"
+    exit 1
+  fi
+
+  if ! openssl ec -in "issuer_key_$idx.pem" -pubout -out "issuer_pub_$idx.pem"; then
+    echo "Failed to generate EC public key"
+    exit 1
+  fi
+
+  # Generate the JWKS file
+  if ! "$BINARY_DIR/tests/scitokens/xrdscitokens-create-jwks" "issuer_pub_$idx.pem" "issuer_$idx.jwks" "test_$idx"; then
+    echo "Failed to generate JWKS file"
+    exit 1
+  fi
+done
+
+###
+## Create the CA & host certificate setup
+###
+
+if ! openssl genrsa -out tlscakey.pem 4096; then
+  echo "Failed to generate CA private key"
+  exit 1
+fi
+
+mkdir -p ca
+touch ca/index.txt
+echo '01' > ca/serial.txt
+
+cat > tlsca.ini <<EOF
+
+[ ca ]
+default_ca = CA_test
+
+[ CA_test ]
+
+default_days = 365
+default_md = sha256
+private_key = $ISSUERDIR/tlscakey.pem
+certificate = $ISSUERDIR/tlsca.pem
+new_certs_dir = $ISSUERDIR/ca
+database = $ISSUERDIR/ca/index.txt
+serial = $ISSUERDIR/ca/serial.txt
+
+[ req ]
+default_bits = 4096
+distinguished_name = ca_test_dn
+x509_extensions = ca_extensions
+string_mask = utf8only
+
+[ ca_test_dn ]
+
+commonName_default = Xrootd CA
+
+[ ca_extensions ]
+
+basicConstraints = critical,CA:true
+keyUsage = keyCertSign,cRLSign
+subjectKeyIdentifier = hash
+authorityKeyIdentifier = keyid
+
+[ signing_policy ]
+countryName            = optional
+stateOrProvinceName    = optional
+localityName           = optional
+organizationName       = optional
+organizationalUnitName = optional
+commonName             = supplied
+emailAddress           = optional
+
+[ cert_extensions ]
+
+basicConstraints = critical,CA:false
+keyUsage = digitalSignature, keyEncipherment
+extendedKeyUsage = critical, serverAuth, clientAuth
+
+EOF
+
+# Create the CA certificate
+echo "Creating TLS CA certificate in $ISSUERDIR/tlsca.pem"
+if ! openssl req -x509 -key tlscakey.pem -config tlsca.ini -out tlsca.pem -outform PEM -subj "/CN=XRootD CA" 0<&-; then
+  echo "Failed to generate CA request"
+  exit 1
+fi
+
+# Create the host certificate request
+openssl genrsa -out tls.key 4096
+chmod 0400 tls.key
+if ! openssl req -new -key tls.key -config tlsca.ini -out tls.csr -outform PEM -subj /CN=localhost 0<&-; then
+  echo "Failed to generate host certificate request"
+  exit 1
+fi
+
+if ! openssl ca -config tlsca.ini -batch -policy signing_policy -extensions cert_extensions -out tls.crt -infiles tls.csr 0<&-; then
+  echo "Failed to sign host certificate request"
+  exit 1
+fi
+chmod 0600 tls.crt
+
+###
+## Create the directory structure to export
+###
+: "${SOURCE_DIR:="$(realpath "$(dirname "${BASH_SOURCE[0]}")")"}"
+
+mkdir -p export/one/.well-known
+cp issuer_1.jwks export/one/issuer.jwks
+cp "$SOURCE_DIR/one-openid-configuration" export/one/.well-known/openid-configuration
+
+mkdir -p export/two/.well-known
+cp issuer_2.jwks export/two/issuer.jwks
+cp "$SOURCE_DIR/two-openid-configuration" export/two/.well-known/openid-configuration
+
+popd || exit 1
diff --git a/tests/scitokens/teardown.sh b/tests/scitokens/teardown.sh
new file mode 100644
index 000000000..d4a57f98d
--- /dev/null
+++ b/tests/scitokens/teardown.sh
@@ -0,0 +1,11 @@
+#!/bin/sh
+
+ISSUERDIR="$1"
+
+rm -rf "$ISSUERDIR/issuer_key_1.pem" "$ISSUERDIR/issuer_key_2.pem"
+rm -rf "$ISSUERDIR/issuer_pub_1.pem" "$ISSUERDIR/issuer_pub_2.pem"
+rm -rf "$ISSUERDIR/issuer_1.jwks" "$ISSUERDIR/issuer_2.jwks"
+rm -rf "$ISSUERDIR/ca"
+rm -rf "$ISSUERDIR/export"
+rm -rf "$ISSUERDIR/tlsca.ini" "$ISSUERDIR/tlsca.pem" "$ISSUERDIR/tlscakey.pem"
+rm -rf "$ISSUERDIR/tls.crt" "$ISSUERDIR/tls.key" "$ISSUERDIR/tls.csr"
diff --git a/tests/scitokens/two-openid-configuration b/tests/scitokens/two-openid-configuration
new file mode 100644
index 000000000..2ceebc6ac
--- /dev/null
+++ b/tests/scitokens/two-openid-configuration
@@ -0,0 +1,3 @@
+{
+  "jwks_uri": "https://localhost:7095/issuer/two/issuer.jwks"
+}
-- 
2.43.5

