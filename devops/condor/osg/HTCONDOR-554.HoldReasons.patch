diff --git a/src/condor_gridmanager/condorjob.cpp b/src/condor_gridmanager/condorjob.cpp
index b028114..fcfd054 100644
--- a/src/condor_gridmanager/condorjob.cpp
+++ b/src/condor_gridmanager/condorjob.cpp
@@ -1486,7 +1486,7 @@ ClassAd *CondorJob::buildSubmitAd()
 
 	submit_ad->Assign( ATTR_JOB_STATUS, HELD );
 	submit_ad->Assign( ATTR_HOLD_REASON, "Spooling input data files" );
-	submit_ad->Assign( ATTR_HOLD_REASON_CODE, CONDOR_HOLD_CODE_SpoolingInput );
+	submit_ad->Assign( ATTR_HOLD_REASON_CODE, CONDOR_HOLD_CODE::SpoolingInput );
 	submit_ad->Assign( ATTR_JOB_UNIVERSE, CONDOR_UNIVERSE_VANILLA );
 
 	submit_ad->Assign( ATTR_Q_DATE, now );
diff --git a/src/condor_gridmanager/ec2job.cpp b/src/condor_gridmanager/ec2job.cpp
index 3f3ace8..6469a0d 100644
--- a/src/condor_gridmanager/ec2job.cpp
+++ b/src/condor_gridmanager/ec2job.cpp
@@ -193,7 +193,7 @@ EC2Job::EC2Job( ClassAd *classad ) :
 	jobAd->LookupString( ATTR_EC2_ACCESS_KEY_ID, m_public_key_file );
 
 	if ( m_public_key_file.empty() ) {
-		holdReasonCode = CONDOR_HOLD_CODE_EC2UserError;
+		holdReasonCode = CONDOR_HOLD_CODE::EC2UserError;
 		holdReasonSubCode = 1;
 		error_string = "Public key file not defined";
 		goto error_exit;
@@ -203,7 +203,7 @@ EC2Job::EC2Job( ClassAd *classad ) :
 	jobAd->LookupString( ATTR_EC2_SECRET_ACCESS_KEY, m_private_key_file );
 
 	if ( m_private_key_file.empty() ) {
-		holdReasonCode = CONDOR_HOLD_CODE_EC2UserError;
+		holdReasonCode = CONDOR_HOLD_CODE::EC2UserError;
 		holdReasonSubCode = 2;
 		error_string = "Private key file not defined";
 		goto error_exit;
@@ -314,7 +314,7 @@ EC2Job::EC2Job( ClassAd *classad ) :
 
 		token = GetNextToken( " ", false );
 		if ( !token || strcasecmp( token, "ec2" ) ) {
-			holdReasonCode = CONDOR_HOLD_CODE_EC2InternalError;
+			holdReasonCode = CONDOR_HOLD_CODE::EC2InternalError;
 			holdReasonSubCode = 3;
 			formatstr( error_string, "%s not of type ec2",
 									  ATTR_GRID_RESOURCE );
@@ -325,7 +325,7 @@ EC2Job::EC2Job( ClassAd *classad ) :
 		if ( token && *token ) {
 			m_serviceUrl = token;
 		} else {
-			holdReasonCode = CONDOR_HOLD_CODE_EC2UserError;
+			holdReasonCode = CONDOR_HOLD_CODE::EC2UserError;
 			holdReasonSubCode = 4;
 			formatstr( error_string, "%s missing EC2 service URL",
 									  ATTR_GRID_RESOURCE );
@@ -333,7 +333,7 @@ EC2Job::EC2Job( ClassAd *classad ) :
 		}
 
 	} else {
-		holdReasonCode = CONDOR_HOLD_CODE_EC2InternalError;
+		holdReasonCode = CONDOR_HOLD_CODE::EC2InternalError;
 		holdReasonSubCode = 5;
 		formatstr( error_string, "%s is not set in the job ad",
 								  ATTR_GRID_RESOURCE );
@@ -342,7 +342,7 @@ EC2Job::EC2Job( ClassAd *classad ) :
 
 	gahp_path = param( "EC2_GAHP" );
 	if ( gahp_path == NULL ) {
-		holdReasonCode = CONDOR_HOLD_CODE_EC2AdminError;
+		holdReasonCode = CONDOR_HOLD_CODE::EC2AdminError;
 		holdReasonSubCode = 6;
 		error_string = "EC2_GAHP not defined";
 		goto error_exit;
@@ -410,7 +410,7 @@ EC2Job::EC2Job( ClassAd *classad ) :
 
 		token = GetNextToken( " ", false );
 		if ( !token || strcasecmp( token, "ec2" ) ) {
-			holdReasonCode = CONDOR_HOLD_CODE_EC2InternalError;
+			holdReasonCode = CONDOR_HOLD_CODE::EC2InternalError;
 			holdReasonSubCode = 7;
 			formatstr( error_string, "%s not of type ec2", ATTR_GRID_JOB_ID );
 			goto error_exit;
@@ -568,7 +568,7 @@ void EC2Job::doEvaluateState()
 						gmState = GM_DELETE;
 						break;
 					} else {
-						holdReasonCode = CONDOR_HOLD_CODE_EC2UserError;
+						holdReasonCode = CONDOR_HOLD_CODE::EC2UserError;
 						holdReasonSubCode = 9;
 						formatstr( errorString, "Failed to authenticate %s.",
 									myResource->authFailureMessage.c_str() );
@@ -689,7 +689,7 @@ void EC2Job::doEvaluateState()
 
 					if ( m_client_token.empty() && m_key_pair_file.empty() &&
 						 !m_key_pair.empty() ) {
-						holdReasonCode = CONDOR_HOLD_CODE_EC2UserError;
+						holdReasonCode = CONDOR_HOLD_CODE::EC2UserError;
 						holdReasonSubCode = 10;
 						formatstr( errorString, "Can't use existing ssh keypair for server type %s", myResource->m_serverType.c_str() );
 						gmState = GM_HOLD;
@@ -785,7 +785,7 @@ void EC2Job::doEvaluateState()
 								gahp_error_code.c_str(),
 								errorString.c_str() );
 						gmState = GM_HOLD;
-						holdReasonCode = CONDOR_HOLD_CODE_EC2ConnectionProblem;
+						holdReasonCode = CONDOR_HOLD_CODE::EC2ConnectionProblem;
 						holdReasonSubCode = 11;
 						break;
 					}
@@ -909,7 +909,7 @@ void EC2Job::doEvaluateState()
 								procID.cluster, procID.proc,
 								gahp_error_code.c_str(),
 								errorString.c_str() );
-						holdReasonCode = CONDOR_HOLD_CODE_EC2ConnectionProblem;
+						holdReasonCode = CONDOR_HOLD_CODE::EC2ConnectionProblem;
 						holdReasonSubCode = 12;
 						gmState = GM_HOLD;
 					}
@@ -1245,7 +1245,7 @@ void EC2Job::doEvaluateState()
 							formatstr( errorString, "Abnormal instance termination: %s.", m_state_reason_code.c_str() );
 							dprintf( D_ALWAYS, "(%d.%d) %s\n", procID.cluster, procID.proc, errorString.c_str() );
 							gmState = GM_HOLD;
-							holdReasonCode = CONDOR_HOLD_CODE_EC2ServerError;
+							holdReasonCode = CONDOR_HOLD_CODE::EC2ServerError;
 							holdReasonSubCode = 13;
 							break;
 						} else {
@@ -1253,7 +1253,7 @@ void EC2Job::doEvaluateState()
 							formatstr( errorString, "Unrecognized reason for instance termination: %s.  Treating as abnormal.", m_state_reason_code.c_str() );
 							dprintf( D_ALWAYS, "(%d.%d) %s\n", procID.cluster, procID.proc, errorString.c_str() );
 							gmState = GM_HOLD;
-							holdReasonCode = CONDOR_HOLD_CODE_EC2ServerError;
+							holdReasonCode = CONDOR_HOLD_CODE::EC2ServerError;
 							holdReasonSubCode = 14;
 							break;
 						}
@@ -1322,7 +1322,7 @@ void EC2Job::doEvaluateState()
 									 gahp_error_code.c_str(),
 									 errorString.c_str() );
 							gmState = GM_HOLD;
-							holdReasonCode = CONDOR_HOLD_CODE_EC2InstancePotentiallyLostError;
+							holdReasonCode = CONDOR_HOLD_CODE::EC2InstancePotentiallyLostError;
 							holdReasonSubCode = 15;
 							break;
 						}
@@ -1398,7 +1398,7 @@ void EC2Job::doEvaluateState()
 						formatstr( errorString, "Job cancel did not succeed after %d tries, giving up.", maxRetryTimes );
 						dprintf( D_ALWAYS, "(%d.%d) %s\n", procID.cluster, procID.proc, errorString.c_str() );
 						gmState = GM_HOLD;
-						holdReasonCode = CONDOR_HOLD_CODE_EC2InstancePotentiallyLostError;
+						holdReasonCode = CONDOR_HOLD_CODE::EC2InstancePotentiallyLostError;
 						holdReasonSubCode = 16;
 						break;
 					}
@@ -1594,7 +1594,7 @@ void EC2Job::doEvaluateState()
 					// job, or put in on hold, before the spot instance
 					// request failed, they should learn about the failure.
 					gmState = GM_HOLD;
-					holdReasonCode = CONDOR_HOLD_CODE_EC2ConnectionProblem;
+					holdReasonCode = CONDOR_HOLD_CODE::EC2ConnectionProblem;
 					holdReasonSubCode = 17;
 					break;
 				}
@@ -1643,7 +1643,7 @@ void EC2Job::doEvaluateState()
 									errorString.c_str() );
 						dprintf( D_FULLDEBUG, "Error transition: GM_SPOT_CANCEL + <GAHP failure> = GM_HOLD\n" );
 						gmState = GM_HOLD;
-						holdReasonCode = CONDOR_HOLD_CODE_EC2InstancePotentiallyLostError;
+						holdReasonCode = CONDOR_HOLD_CODE::EC2InstancePotentiallyLostError;
 						holdReasonSubCode = 17;
 						break;
 					}
@@ -1704,7 +1704,7 @@ void EC2Job::doEvaluateState()
 						formatstr( errorString, "Spot job cancel did not succeed after %d tries, giving up.", maxRetryTimes );
 						dprintf( D_ALWAYS, "(%d.%d) %s\n", procID.cluster, procID.proc, errorString.c_str() );
 						gmState = GM_HOLD;
-						holdReasonCode = CONDOR_HOLD_CODE_EC2InstancePotentiallyLostError;
+						holdReasonCode = CONDOR_HOLD_CODE::EC2InstancePotentiallyLostError;
 						holdReasonSubCode = 18;
 						break;
 					}
@@ -1788,7 +1788,7 @@ void EC2Job::doEvaluateState()
 					dprintf( D_ALWAYS, "(%d.%d) %s\n", procID.cluster, procID.proc, errorString.c_str() );
 					dprintf( D_FULLDEBUG, "Error transition: GM_SPOT_QUERY + <spot purged> = GM_HOLD\n" );
 					gmState = GM_HOLD;
-					holdReasonCode = CONDOR_HOLD_CODE_EC2InstancePotentiallyLostError;
+					holdReasonCode = CONDOR_HOLD_CODE::EC2InstancePotentiallyLostError;
 					holdReasonSubCode = 19;
 					break;
 				}
@@ -1846,7 +1846,7 @@ void EC2Job::doEvaluateState()
 					dprintf( D_ALWAYS, "(%d.%d) %s\n", procID.cluster, procID.proc, errorString.c_str() );
 					dprintf( D_FULLDEBUG, "Error transition: GM_SPOT_QUERY + <cancelled> = GM_HOLD\n" );
 					gmState = GM_HOLD;
-					holdReasonCode = CONDOR_HOLD_CODE_EC2UserError;
+					holdReasonCode = CONDOR_HOLD_CODE::EC2UserError;
 					holdReasonSubCode = 20;
 					break;
 				} else if( remoteJobState == "pending" ) {
@@ -1873,7 +1873,7 @@ void EC2Job::doEvaluateState()
 					dprintf( D_ALWAYS, "(%d.%d) %s\n", procID.cluster, procID.proc, errorString.c_str() );
 					dprintf( D_FULLDEBUG, "Error transition: GM_SPOT_QUERY + <unexpected state> = GM_HOLD\n" );
 					gmState = GM_HOLD;
-					holdReasonCode = CONDOR_HOLD_CODE_EC2InternalError;
+					holdReasonCode = CONDOR_HOLD_CODE::EC2InternalError;
 					holdReasonSubCode = 21;
 					break;
 				}
@@ -2459,7 +2459,7 @@ void EC2Job::ResourceLeaseExpired() {
 	errorString = "Resource was down for too long.";
 	dprintf( D_ALWAYS, "(%d.%d) Putting job on hold: resource was down for too long.\n", procID.cluster, procID.proc );
 	gmState = GM_HOLD;
-	holdReasonCode = CONDOR_HOLD_CODE_EC2ServerError;
+	holdReasonCode = CONDOR_HOLD_CODE::EC2ServerError;
 	holdReasonSubCode = 22;
 	resourceLeaseTID = -1;
 	SetEvaluateState();
diff --git a/src/condor_gridmanager/globusjob.cpp b/src/condor_gridmanager/globusjob.cpp
index c640ec4..8a8c015 100644
--- a/src/condor_gridmanager/globusjob.cpp
+++ b/src/condor_gridmanager/globusjob.cpp
@@ -981,7 +981,7 @@ void GlobusJob::doEvaluateState()
 				jobAd->Assign( ATTR_HOLD_REASON,
 							   "Proxy file missing or corrupted" );
 				jobAd->Assign(ATTR_HOLD_REASON_CODE,
-							   CONDOR_HOLD_CODE_CorruptedCredential);
+							   CONDOR_HOLD_CODE::CorruptedCredential);
 				jobAd->Assign(ATTR_HOLD_REASON_SUBCODE, 0);
 				gmState = GM_HOLD;
 				break;
@@ -2249,27 +2249,27 @@ else{dprintf(D_FULLDEBUG,"(%d.%d) JEF: proceeding immediately with restart\n",pr
 				if ( holdReason[0] == '\0' && globusStateErrorCode == 0 &&
 					 globusState == GLOBUS_GRAM_PROTOCOL_JOB_STATE_FAILED ) {
 					snprintf( holdReason, 1024, "Job failed, no reason given by GRAM server" );
-					holdCode = CONDOR_HOLD_CODE_GlobusGramError;
+					holdCode = CONDOR_HOLD_CODE::GlobusGramError;
 					holdSubCode = 0;
 				}
 				if ( holdReason[0] == '\0' && globusStateErrorCode != 0 ) {
 					snprintf( holdReason, 1024, "Globus error %d: %s",
 							  globusStateErrorCode,
 							  gahp->globus_gram_client_error_string( globusStateErrorCode ) );
-					holdCode = CONDOR_HOLD_CODE_GlobusGramError;
+					holdCode = CONDOR_HOLD_CODE::GlobusGramError;
 					holdSubCode = globusStateErrorCode;
 				}
 				if ( holdReason[0] == '\0' && globusError != 0 ) {
 					snprintf( holdReason, 1024, "Globus error %d: %s", globusError,
 							  gahp->globus_gram_client_error_string( globusError ) );
-					holdCode = CONDOR_HOLD_CODE_GlobusGramError;
+					holdCode = CONDOR_HOLD_CODE::GlobusGramError;
 					holdSubCode = globusError;
 				}
 				if ( holdReason[0] == '\0' && previousGlobusError != 0 ) {
 					snprintf( holdReason, 1024, "Globus error %d: %s",
 							  previousGlobusError,
 							  gahp->globus_gram_client_error_string( previousGlobusError ) );
-					holdCode = CONDOR_HOLD_CODE_GlobusGramError;
+					holdCode = CONDOR_HOLD_CODE::GlobusGramError;
 					holdSubCode = previousGlobusError;
 				}
 				if ( holdReason[0] == '\0' ) {
diff --git a/src/condor_includes/condor_attributes.h b/src/condor_includes/condor_attributes.h
index 6a3aae4..58a8c12 100644
--- a/src/condor_includes/condor_attributes.h
+++ b/src/condor_includes/condor_attributes.h
@@ -538,6 +538,8 @@
 #define ATTR_NUM_GLOBUS_SUBMITS  "NumGlobusSubmits"
 #define ATTR_NUM_MATCHES  "NumJobMatches"
 #define ATTR_LIMIT_RESULTS "LimitResults"
+#define ATTR_NUM_HOLDS "NumHolds"
+#define ATTR_NUM_HOLDS_BY_REASON "NumHoldsByReason"
 #define ATTR_NUM_JOB_STARTS  "NumJobStarts"
 #define ATTR_NUM_JOB_COMPLETIONS "NumJobCompletions"
 #define ATTR_NUM_JOB_RECONNECTS  "NumJobReconnects"
diff --git a/src/condor_includes/enum.h b/src/condor_includes/enum.h
new file mode 100644
index 0000000..ae3e2ee
--- /dev/null
+++ b/src/condor_includes/enum.h
@@ -0,0 +1,1326 @@
+// This file is part of Better Enums, released under the BSD 2-clause license.
+// See LICENSE.md for details, or visit http://github.com/aantron/better-enums.
+
+#pragma once
+
+#ifndef BETTER_ENUMS_ENUM_H
+#define BETTER_ENUMS_ENUM_H
+
+
+
+#include <cstddef>
+#include <cstring>
+#include <iosfwd>
+#include <stdexcept>
+
+
+// in-line, non-#pragma warning handling
+// not supported in very old compilers (namely gcc 4.4 or less)
+#ifdef __GNUC__
+#   ifdef __clang__
+#      define BETTER_ENUMS_IGNORE_OLD_CAST_HEADER _Pragma("clang diagnostic push")
+#      define BETTER_ENUMS_IGNORE_OLD_CAST_BEGIN _Pragma("clang diagnostic ignored \"-Wold-style-cast\"")
+#      define BETTER_ENUMS_IGNORE_OLD_CAST_END _Pragma("clang diagnostic pop")
+#      define BETTER_ENUMS_IGNORE_ATTRIBUTES_HEADER
+#      define BETTER_ENUMS_IGNORE_ATTRIBUTES_BEGIN
+#      define BETTER_ENUMS_IGNORE_ATTRIBUTES_END
+#   else
+#      define BETTER_ENUMS_GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100)
+#      if BETTER_ENUMS_GCC_VERSION > 40400
+#         define BETTER_ENUMS_IGNORE_OLD_CAST_HEADER _Pragma("GCC diagnostic push")
+#         define BETTER_ENUMS_IGNORE_OLD_CAST_BEGIN _Pragma("GCC diagnostic ignored \"-Wold-style-cast\"")
+#         define BETTER_ENUMS_IGNORE_OLD_CAST_END _Pragma("GCC diagnostic pop")
+#         if (BETTER_ENUMS_GCC_VERSION >= 70300)
+#               define BETTER_ENUMS_IGNORE_ATTRIBUTES_HEADER _Pragma("GCC diagnostic push")
+#               define BETTER_ENUMS_IGNORE_ATTRIBUTES_BEGIN _Pragma("GCC diagnostic ignored \"-Wattributes\"")
+#               define BETTER_ENUMS_IGNORE_ATTRIBUTES_END _Pragma("GCC diagnostic pop")
+#         else
+#               define BETTER_ENUMS_IGNORE_ATTRIBUTES_HEADER
+#               define BETTER_ENUMS_IGNORE_ATTRIBUTES_BEGIN
+#               define BETTER_ENUMS_IGNORE_ATTRIBUTES_END
+#         endif
+#      else
+#         define BETTER_ENUMS_IGNORE_OLD_CAST_HEADER
+#         define BETTER_ENUMS_IGNORE_OLD_CAST_BEGIN
+#         define BETTER_ENUMS_IGNORE_OLD_CAST_END
+#         define BETTER_ENUMS_IGNORE_ATTRIBUTES_HEADER
+#         define BETTER_ENUMS_IGNORE_ATTRIBUTES_BEGIN
+#         define BETTER_ENUMS_IGNORE_ATTRIBUTES_END
+#      endif
+#   endif
+#else // empty definitions for compilers that don't support _Pragma
+#   define BETTER_ENUMS_IGNORE_OLD_CAST_HEADER
+#   define BETTER_ENUMS_IGNORE_OLD_CAST_BEGIN
+#   define BETTER_ENUMS_IGNORE_OLD_CAST_END
+#   define BETTER_ENUMS_IGNORE_ATTRIBUTES_HEADER
+#   define BETTER_ENUMS_IGNORE_ATTRIBUTES_BEGIN
+#   define BETTER_ENUMS_IGNORE_ATTRIBUTES_END
+#endif
+
+// Feature detection.
+
+#ifdef __GNUC__
+#   ifdef __clang__
+#       if __has_feature(cxx_constexpr)
+#           define BETTER_ENUMS_HAVE_CONSTEXPR
+#       endif
+#       if !defined(__EXCEPTIONS) || !__has_feature(cxx_exceptions)
+#           define BETTER_ENUMS_NO_EXCEPTIONS
+#       endif
+#   else
+#       if defined(__GXX_EXPERIMENTAL_CXX0X__) || __cplusplus >= 201103L
+#           if (__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ >= 6))
+#               define BETTER_ENUMS_HAVE_CONSTEXPR
+#           endif
+#       endif
+#       ifndef __EXCEPTIONS
+#           define BETTER_ENUMS_NO_EXCEPTIONS
+#       endif
+#   endif
+#endif
+
+#ifdef _MSC_VER
+#   if _MSC_VER >= 1911
+#       define BETTER_ENUMS_HAVE_CONSTEXPR
+#   endif
+#   ifdef __clang__
+#       if __has_feature(cxx_constexpr)
+#           define BETTER_ENUMS_HAVE_CONSTEXPR
+#       endif
+#   endif
+#   ifndef _CPPUNWIND
+#       define BETTER_ENUMS_NO_EXCEPTIONS
+#   endif
+#   if _MSC_VER < 1600
+#       define BETTER_ENUMS_VC2008_WORKAROUNDS
+#   endif
+#endif
+
+#ifdef BETTER_ENUMS_CONSTEXPR
+#   define BETTER_ENUMS_HAVE_CONSTEXPR
+#endif
+
+#ifdef BETTER_ENUMS_NO_CONSTEXPR
+#   ifdef BETTER_ENUMS_HAVE_CONSTEXPR
+#       undef BETTER_ENUMS_HAVE_CONSTEXPR
+#   endif
+#endif
+
+// GCC (and maybe clang) can be made to warn about using 0 or NULL when nullptr
+// is available, so Better Enums tries to use nullptr. This passage uses
+// availability of constexpr as a proxy for availability of nullptr, i.e. it
+// assumes that nullptr is available when compiling on the right versions of gcc
+// and clang with the right -std flag. This is actually slightly wrong, because
+// nullptr is also available in Visual C++, but constexpr isn't. This
+// imprecision doesn't matter, however, because VC++ doesn't have the warnings
+// that make using nullptr necessary.
+#ifdef BETTER_ENUMS_HAVE_CONSTEXPR
+#   define BETTER_ENUMS_CONSTEXPR_     constexpr
+#   define BETTER_ENUMS_NULLPTR        nullptr
+#else
+#   define BETTER_ENUMS_CONSTEXPR_
+#   define BETTER_ENUMS_NULLPTR        NULL
+#endif
+
+#ifndef BETTER_ENUMS_NO_EXCEPTIONS
+#   define BETTER_ENUMS_IF_EXCEPTIONS(x) x
+#else
+#   define BETTER_ENUMS_IF_EXCEPTIONS(x)
+#endif
+
+#ifdef __GNUC__
+#   define BETTER_ENUMS_UNUSED __attribute__((__unused__))
+#else
+#   define BETTER_ENUMS_UNUSED
+#endif
+
+
+
+// Higher-order preprocessor macros.
+
+#ifdef BETTER_ENUMS_MACRO_FILE
+#   include BETTER_ENUMS_MACRO_FILE
+#else
+
+#define BETTER_ENUMS_PP_MAP(macro, data, ...) \
+    BETTER_ENUMS_ID( \
+        BETTER_ENUMS_APPLY( \
+            BETTER_ENUMS_PP_MAP_VAR_COUNT, \
+            BETTER_ENUMS_PP_COUNT(__VA_ARGS__)) \
+        (macro, data, __VA_ARGS__))
+
+#define BETTER_ENUMS_PP_MAP_VAR_COUNT(count) BETTER_ENUMS_M ## count
+
+#define BETTER_ENUMS_APPLY(macro, ...) BETTER_ENUMS_ID(macro(__VA_ARGS__))
+
+#define BETTER_ENUMS_ID(x) x
+
+#define BETTER_ENUMS_M1(m, d, x) m(d,0,x)
+#define BETTER_ENUMS_M2(m,d,x,...) m(d,1,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M1(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M3(m,d,x,...) m(d,2,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M2(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M4(m,d,x,...) m(d,3,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M3(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M5(m,d,x,...) m(d,4,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M4(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M6(m,d,x,...) m(d,5,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M5(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M7(m,d,x,...) m(d,6,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M6(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M8(m,d,x,...) m(d,7,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M7(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M9(m,d,x,...) m(d,8,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M8(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M10(m,d,x,...) m(d,9,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M9(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M11(m,d,x,...) m(d,10,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M10(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M12(m,d,x,...) m(d,11,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M11(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M13(m,d,x,...) m(d,12,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M12(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M14(m,d,x,...) m(d,13,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M13(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M15(m,d,x,...) m(d,14,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M14(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M16(m,d,x,...) m(d,15,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M15(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M17(m,d,x,...) m(d,16,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M16(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M18(m,d,x,...) m(d,17,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M17(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M19(m,d,x,...) m(d,18,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M18(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M20(m,d,x,...) m(d,19,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M19(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M21(m,d,x,...) m(d,20,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M20(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M22(m,d,x,...) m(d,21,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M21(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M23(m,d,x,...) m(d,22,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M22(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M24(m,d,x,...) m(d,23,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M23(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M25(m,d,x,...) m(d,24,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M24(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M26(m,d,x,...) m(d,25,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M25(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M27(m,d,x,...) m(d,26,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M26(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M28(m,d,x,...) m(d,27,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M27(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M29(m,d,x,...) m(d,28,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M28(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M30(m,d,x,...) m(d,29,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M29(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M31(m,d,x,...) m(d,30,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M30(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M32(m,d,x,...) m(d,31,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M31(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M33(m,d,x,...) m(d,32,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M32(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M34(m,d,x,...) m(d,33,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M33(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M35(m,d,x,...) m(d,34,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M34(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M36(m,d,x,...) m(d,35,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M35(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M37(m,d,x,...) m(d,36,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M36(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M38(m,d,x,...) m(d,37,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M37(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M39(m,d,x,...) m(d,38,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M38(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M40(m,d,x,...) m(d,39,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M39(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M41(m,d,x,...) m(d,40,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M40(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M42(m,d,x,...) m(d,41,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M41(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M43(m,d,x,...) m(d,42,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M42(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M44(m,d,x,...) m(d,43,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M43(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M45(m,d,x,...) m(d,44,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M44(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M46(m,d,x,...) m(d,45,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M45(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M47(m,d,x,...) m(d,46,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M46(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M48(m,d,x,...) m(d,47,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M47(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M49(m,d,x,...) m(d,48,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M48(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M50(m,d,x,...) m(d,49,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M49(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M51(m,d,x,...) m(d,50,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M50(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M52(m,d,x,...) m(d,51,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M51(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M53(m,d,x,...) m(d,52,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M52(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M54(m,d,x,...) m(d,53,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M53(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M55(m,d,x,...) m(d,54,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M54(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M56(m,d,x,...) m(d,55,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M55(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M57(m,d,x,...) m(d,56,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M56(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M58(m,d,x,...) m(d,57,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M57(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M59(m,d,x,...) m(d,58,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M58(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M60(m,d,x,...) m(d,59,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M59(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M61(m,d,x,...) m(d,60,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M60(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M62(m,d,x,...) m(d,61,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M61(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M63(m,d,x,...) m(d,62,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M62(m,d,__VA_ARGS__))
+#define BETTER_ENUMS_M64(m,d,x,...) m(d,63,x) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_M63(m,d,__VA_ARGS__))
+
+#define BETTER_ENUMS_PP_COUNT_IMPL(_1, _2, _3, _4, _5, _6, _7, _8, _9, _10,    \
+    _11, _12, _13, _14, _15, _16, _17, _18, _19, _20, _21, _22, _23, _24, _25, \
+    _26, _27, _28, _29, _30, _31, _32, _33, _34, _35, _36, _37, _38, _39, _40, \
+    _41, _42, _43, _44, _45, _46, _47, _48, _49, _50, _51, _52, _53, _54, _55, \
+    _56, _57, _58, _59, _60, _61, _62, _63, _64, count, ...) count
+
+#define BETTER_ENUMS_PP_COUNT(...) \
+    BETTER_ENUMS_ID(BETTER_ENUMS_PP_COUNT_IMPL(__VA_ARGS__, 64, 63, 62, 61, 60,\
+        59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42,\
+        41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24,\
+        23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, \
+        4, 3, 2, 1))
+
+#define BETTER_ENUMS_ITERATE(X, f, l) X(f, l, 0) X(f, l, 1) X(f, l, 2)         \
+    X(f, l, 3) X(f, l, 4) X(f, l, 5) X(f, l, 6) X(f, l, 7) X(f, l, 8)          \
+    X(f, l, 9) X(f, l, 10) X(f, l, 11) X(f, l, 12) X(f, l, 13) X(f, l, 14)     \
+    X(f, l, 15) X(f, l, 16) X(f, l, 17) X(f, l, 18) X(f, l, 19) X(f, l, 20)    \
+    X(f, l, 21) X(f, l, 22) X(f, l, 23)
+
+#endif // #ifdef BETTER_ENUMS_MACRO_FILE else case
+
+
+
+namespace better_enums {
+
+
+// Optional type.
+
+template <typename T>
+BETTER_ENUMS_CONSTEXPR_ inline T _default()
+{
+    return static_cast<typename T::_enumerated>(0);
+}
+
+template <>
+BETTER_ENUMS_CONSTEXPR_ inline const char* _default<const char*>()
+{
+    return BETTER_ENUMS_NULLPTR;
+}
+
+template <>
+BETTER_ENUMS_CONSTEXPR_ inline std::size_t _default<std::size_t>()
+{
+    return 0;
+}
+
+template <typename T>
+struct optional {
+    BETTER_ENUMS_CONSTEXPR_ optional() :
+        _valid(false), _value(_default<T>()) { }
+
+    BETTER_ENUMS_CONSTEXPR_ optional(T v) : _valid(true), _value(v) { }
+
+    BETTER_ENUMS_CONSTEXPR_ const T& operator *() const { return _value; }
+    BETTER_ENUMS_CONSTEXPR_ const T* operator ->() const { return &_value; }
+
+    BETTER_ENUMS_CONSTEXPR_ operator bool() const { return _valid; }
+
+    BETTER_ENUMS_CONSTEXPR_ const T& value() const { return _value; }
+
+  private:
+    bool    _valid;
+    T       _value;
+};
+
+template <typename CastTo, typename Element>
+BETTER_ENUMS_CONSTEXPR_ static optional<CastTo>
+_map_index(const Element *array, optional<std::size_t> index)
+{
+    return index ? static_cast<CastTo>(array[*index]) : optional<CastTo>();
+}
+
+#ifdef BETTER_ENUMS_VC2008_WORKAROUNDS
+
+#define BETTER_ENUMS_OR_THROW                                                  \
+    if (!maybe)                                                                \
+        throw std::runtime_error(message);                                     \
+                                                                               \
+    return *maybe;
+
+#else
+
+#define BETTER_ENUMS_OR_THROW                                                  \
+    return maybe ? *maybe : throw std::runtime_error(message);
+
+#endif
+
+BETTER_ENUMS_IF_EXCEPTIONS(
+template <typename T>
+BETTER_ENUMS_CONSTEXPR_ static T _or_throw(optional<T> maybe,
+                                           const char *message)
+{
+    BETTER_ENUMS_OR_THROW
+}
+)
+
+template <typename T>
+BETTER_ENUMS_CONSTEXPR_ static T* _or_null(optional<T*> maybe)
+{
+    return maybe ? *maybe : BETTER_ENUMS_NULLPTR;
+}
+
+template <typename T>
+BETTER_ENUMS_CONSTEXPR_ static T _or_zero(optional<T> maybe)
+{
+    return maybe ? *maybe : T::_from_integral_unchecked(0);
+}
+
+
+
+// Functional sequencing. This is essentially a comma operator wrapped in a
+// constexpr function. g++ 4.7 doesn't "accept" integral constants in the second
+// position for the comma operator, and emits an external symbol, which then
+// causes a linking error.
+
+template <typename T, typename U>
+BETTER_ENUMS_CONSTEXPR_ U
+continue_with(T, U value) { return value; }
+
+
+
+// Values array declaration helper.
+
+//! Get intrinsic value of an (Enum::value) by taking advantage of
+// C-conversion's parentheses priority
+template <typename EnumType>
+struct _eat_assign {
+    explicit BETTER_ENUMS_CONSTEXPR_ _eat_assign(EnumType value) : _value(value)
+        { }
+
+    template <typename Any>
+    BETTER_ENUMS_CONSTEXPR_ const _eat_assign&
+    operator =(Any) const { return *this; }
+
+    BETTER_ENUMS_CONSTEXPR_ operator EnumType () const { return _value; }
+
+  private:
+    EnumType    _value;
+};
+
+
+
+// Iterables.
+
+template <typename Element>
+struct _iterable {
+    typedef const Element*  iterator;
+
+    BETTER_ENUMS_CONSTEXPR_ iterator begin() const { return iterator(_array); }
+    BETTER_ENUMS_CONSTEXPR_ iterator end() const
+        { return iterator(_array + _size); }
+    BETTER_ENUMS_CONSTEXPR_ std::size_t size() const { return _size; }
+    BETTER_ENUMS_CONSTEXPR_ const Element& operator [](std::size_t index) const
+        { return _array[index]; }
+
+    BETTER_ENUMS_CONSTEXPR_ _iterable(const Element *array, std::size_t s) :
+        _array(array), _size(s) { }
+
+  private:
+    const Element * const   _array;
+    const std::size_t       _size;
+};
+
+
+
+// String routines.
+
+BETTER_ENUMS_CONSTEXPR_ static const char       *_name_enders = "= \t\n";
+
+BETTER_ENUMS_CONSTEXPR_ inline bool _ends_name(char c, std::size_t index = 0)
+{
+    return
+        c == _name_enders[index] ? true  :
+        _name_enders[index] == '\0' ? false :
+        _ends_name(c, index + 1);
+}
+
+BETTER_ENUMS_CONSTEXPR_ inline bool _has_initializer(const char *s,
+                                                     std::size_t index = 0)
+{
+    return
+        s[index] == '\0' ? false :
+        s[index] == '=' ? true :
+        _has_initializer(s, index + 1);
+}
+
+BETTER_ENUMS_CONSTEXPR_ inline std::size_t
+_constant_length(const char *s, std::size_t index = 0)
+{
+    return _ends_name(s[index]) ? index : _constant_length(s, index + 1);
+}
+
+BETTER_ENUMS_CONSTEXPR_ inline char
+_select(const char *from, std::size_t from_length, std::size_t index)
+{
+    return index >= from_length ? '\0' : from[index];
+}
+
+BETTER_ENUMS_CONSTEXPR_ inline char _to_lower_ascii(char c)
+{
+    return c >= 0x41 && c <= 0x5A ? static_cast<char>(c + 0x20) : c;
+}
+
+BETTER_ENUMS_CONSTEXPR_ inline bool _names_match(const char *stringizedName,
+                                                 const char *referenceName,
+                                                 std::size_t index = 0)
+{
+    return
+        _ends_name(stringizedName[index]) ? referenceName[index] == '\0' :
+        referenceName[index] == '\0' ? false :
+        stringizedName[index] != referenceName[index] ? false :
+        _names_match(stringizedName, referenceName, index + 1);
+}
+
+BETTER_ENUMS_CONSTEXPR_ inline bool
+_names_match_nocase(const char *stringizedName, const char *referenceName,
+                    std::size_t index = 0)
+{
+    return
+        _ends_name(stringizedName[index]) ? referenceName[index] == '\0' :
+        referenceName[index] == '\0' ? false :
+        _to_lower_ascii(stringizedName[index]) !=
+            _to_lower_ascii(referenceName[index]) ? false :
+        _names_match_nocase(stringizedName, referenceName, index + 1);
+}
+
+inline void _trim_names(const char * const *raw_names,
+                        const char **trimmed_names,
+                        char *storage, std::size_t count)
+{
+    std::size_t     offset = 0;
+
+    for (std::size_t index = 0; index < count; ++index) {
+        trimmed_names[index] = storage + offset;
+
+        std::size_t trimmed_length =
+            std::strcspn(raw_names[index], _name_enders);
+        storage[offset + trimmed_length] = '\0';
+
+        std::size_t raw_length = std::strlen(raw_names[index]);
+        offset += raw_length + 1;
+    }
+}
+
+
+
+// Eager initialization.
+template <typename Enum>
+struct _initialize_at_program_start {
+    _initialize_at_program_start() { Enum::initialize(); }
+};
+
+} // namespace better_enums
+
+
+
+// Array generation macros.
+
+#define BETTER_ENUMS_EAT_ASSIGN_SINGLE(EnumType, index, expression)            \
+    (EnumType)((::better_enums::_eat_assign<EnumType>)EnumType::expression),
+
+#define BETTER_ENUMS_EAT_ASSIGN(EnumType, ...)                                 \
+    BETTER_ENUMS_ID(                                                           \
+        BETTER_ENUMS_PP_MAP(                                                   \
+            BETTER_ENUMS_EAT_ASSIGN_SINGLE, EnumType, __VA_ARGS__))
+
+
+
+#ifdef BETTER_ENUMS_HAVE_CONSTEXPR
+
+
+
+#define BETTER_ENUMS_SELECT_SINGLE_CHARACTER(from, from_length, index)         \
+    ::better_enums::_select(from, from_length, index),
+
+#define BETTER_ENUMS_SELECT_CHARACTERS(from, from_length)                      \
+    BETTER_ENUMS_ITERATE(                                                      \
+        BETTER_ENUMS_SELECT_SINGLE_CHARACTER, from, from_length)
+
+
+
+#define BETTER_ENUMS_TRIM_SINGLE_STRING(ignored, index, expression)            \
+constexpr std::size_t   _length_ ## index =                                    \
+    ::better_enums::_constant_length(#expression);                             \
+constexpr const char    _trimmed_ ## index [] =                                \
+    { BETTER_ENUMS_SELECT_CHARACTERS(#expression, _length_ ## index) };        \
+constexpr const char    *_final_ ## index =                                    \
+    ::better_enums::_has_initializer(#expression) ?                            \
+        _trimmed_ ## index : #expression;
+
+#define BETTER_ENUMS_TRIM_STRINGS(...)                                         \
+    BETTER_ENUMS_ID(                                                           \
+        BETTER_ENUMS_PP_MAP(                                                   \
+            BETTER_ENUMS_TRIM_SINGLE_STRING, ignored, __VA_ARGS__))
+
+
+
+#define BETTER_ENUMS_REFER_TO_SINGLE_STRING(ignored, index, expression)        \
+    _final_ ## index,
+
+#define BETTER_ENUMS_REFER_TO_STRINGS(...)                                     \
+    BETTER_ENUMS_ID(                                                           \
+        BETTER_ENUMS_PP_MAP(                                                   \
+            BETTER_ENUMS_REFER_TO_SINGLE_STRING, ignored, __VA_ARGS__))
+
+
+
+#endif // #ifdef BETTER_ENUMS_HAVE_CONSTEXPR
+
+
+
+#define BETTER_ENUMS_STRINGIZE_SINGLE(ignored, index, expression)  #expression,
+
+#define BETTER_ENUMS_STRINGIZE(...)                                            \
+    BETTER_ENUMS_ID(                                                           \
+        BETTER_ENUMS_PP_MAP(                                                   \
+            BETTER_ENUMS_STRINGIZE_SINGLE, ignored, __VA_ARGS__))
+
+#define BETTER_ENUMS_RESERVE_STORAGE_SINGLE(ignored, index, expression)        \
+    #expression ","
+
+#define BETTER_ENUMS_RESERVE_STORAGE(...)                                      \
+    BETTER_ENUMS_ID(                                                           \
+        BETTER_ENUMS_PP_MAP(                                                   \
+            BETTER_ENUMS_RESERVE_STORAGE_SINGLE, ignored, __VA_ARGS__))
+
+
+
+// The enums proper.
+
+#define BETTER_ENUMS_NS(EnumType)  better_enums_data_ ## EnumType
+
+#ifdef BETTER_ENUMS_VC2008_WORKAROUNDS
+
+#define BETTER_ENUMS_COPY_CONSTRUCTOR(Enum)                                    \
+        BETTER_ENUMS_CONSTEXPR_ Enum(const Enum &other) :                      \
+            _value(other._value) { }
+
+#else
+
+#define BETTER_ENUMS_COPY_CONSTRUCTOR(Enum)
+
+#endif
+
+#ifndef BETTER_ENUMS_CLASS_ATTRIBUTE
+#   define BETTER_ENUMS_CLASS_ATTRIBUTE
+#endif
+
+#define BETTER_ENUMS_TYPE(SetUnderlyingType, SwitchType, GenerateSwitchType,   \
+                          GenerateStrings, ToStringConstexpr,                  \
+                          DeclareInitialize, DefineInitialize, CallInitialize, \
+                          Enum, Underlying, ...)                               \
+                                                                               \
+namespace better_enums_data_ ## Enum {                                         \
+                                                                               \
+BETTER_ENUMS_ID(GenerateSwitchType(Underlying, __VA_ARGS__))                   \
+                                                                               \
+}                                                                              \
+                                                                               \
+class BETTER_ENUMS_CLASS_ATTRIBUTE Enum {                                      \
+  private:                                                                     \
+    typedef ::better_enums::optional<Enum>                  _optional;         \
+    typedef ::better_enums::optional<std::size_t>           _optional_index;   \
+                                                                               \
+  public:                                                                      \
+    typedef Underlying                                      _integral;         \
+                                                                               \
+    enum _enumerated SetUnderlyingType(Underlying) { __VA_ARGS__ };            \
+                                                                               \
+    BETTER_ENUMS_CONSTEXPR_ Enum(_enumerated value) : _value(value) { }        \
+                                                                               \
+    BETTER_ENUMS_COPY_CONSTRUCTOR(Enum)                                        \
+                                                                               \
+    BETTER_ENUMS_CONSTEXPR_ operator SwitchType(Enum)() const                  \
+    {                                                                          \
+        return SwitchType(Enum)(_value);                                       \
+    }                                                                          \
+                                                                               \
+    BETTER_ENUMS_CONSTEXPR_ _integral _to_integral() const;                    \
+    BETTER_ENUMS_IF_EXCEPTIONS(                                                \
+    BETTER_ENUMS_CONSTEXPR_ static Enum _from_integral(_integral value);       \
+    )                                                                          \
+    BETTER_ENUMS_CONSTEXPR_ static Enum                                        \
+    _from_integral_unchecked(_integral value);                                 \
+    BETTER_ENUMS_CONSTEXPR_ static _optional                                   \
+    _from_integral_nothrow(_integral value);                                   \
+                                                                               \
+    BETTER_ENUMS_CONSTEXPR_ std::size_t _to_index() const;                     \
+    BETTER_ENUMS_IF_EXCEPTIONS(                                                \
+    BETTER_ENUMS_CONSTEXPR_ static Enum _from_index(std::size_t index);        \
+    )                                                                          \
+    BETTER_ENUMS_CONSTEXPR_ static Enum                                        \
+    _from_index_unchecked(std::size_t index);                                  \
+    BETTER_ENUMS_CONSTEXPR_ static _optional                                   \
+    _from_index_nothrow(std::size_t index);                                    \
+                                                                               \
+    ToStringConstexpr const char* _to_string() const;                          \
+    BETTER_ENUMS_IF_EXCEPTIONS(                                                \
+    BETTER_ENUMS_CONSTEXPR_ static Enum _from_string(const char *name);        \
+    )                                                                          \
+    BETTER_ENUMS_CONSTEXPR_ static _optional                                   \
+    _from_string_nothrow(const char *name);                                    \
+                                                                               \
+    BETTER_ENUMS_IF_EXCEPTIONS(                                                \
+    BETTER_ENUMS_CONSTEXPR_ static Enum _from_string_nocase(const char *name); \
+    )                                                                          \
+    BETTER_ENUMS_CONSTEXPR_ static _optional                                   \
+    _from_string_nocase_nothrow(const char *name);                             \
+                                                                               \
+    BETTER_ENUMS_CONSTEXPR_ static bool _is_valid(_integral value);            \
+    BETTER_ENUMS_CONSTEXPR_ static bool _is_valid(const char *name);           \
+    BETTER_ENUMS_CONSTEXPR_ static bool _is_valid_nocase(const char *name);    \
+                                                                               \
+    typedef ::better_enums::_iterable<Enum>             _value_iterable;       \
+    typedef ::better_enums::_iterable<const char*>      _name_iterable;        \
+                                                                               \
+    typedef _value_iterable::iterator                   _value_iterator;       \
+    typedef _name_iterable::iterator                    _name_iterator;        \
+                                                                               \
+    BETTER_ENUMS_CONSTEXPR_ static const std::size_t _size_constant =          \
+        BETTER_ENUMS_ID(BETTER_ENUMS_PP_COUNT(__VA_ARGS__));                   \
+    BETTER_ENUMS_CONSTEXPR_ static std::size_t _size()                         \
+        { return _size_constant; }                                             \
+                                                                               \
+    BETTER_ENUMS_CONSTEXPR_ static const char* _name();                        \
+    BETTER_ENUMS_CONSTEXPR_ static _value_iterable _values();                  \
+    ToStringConstexpr static _name_iterable _names();                          \
+                                                                               \
+    _integral      _value;                                                     \
+                                                                               \
+    BETTER_ENUMS_DEFAULT_CONSTRUCTOR(Enum)                                     \
+                                                                               \
+  private:                                                                     \
+    explicit BETTER_ENUMS_CONSTEXPR_ Enum(const _integral &value) :            \
+        _value(value) { }                                                      \
+                                                                               \
+    DeclareInitialize                                                          \
+                                                                               \
+    BETTER_ENUMS_CONSTEXPR_ static _optional_index                             \
+    _from_value_loop(_integral value, std::size_t index = 0);                  \
+    BETTER_ENUMS_CONSTEXPR_ static _optional_index                             \
+    _from_string_loop(const char *name, std::size_t index = 0);                \
+    BETTER_ENUMS_CONSTEXPR_ static _optional_index                             \
+    _from_string_nocase_loop(const char *name, std::size_t index = 0);         \
+                                                                               \
+    friend struct ::better_enums::_initialize_at_program_start<Enum>;          \
+};                                                                             \
+                                                                               \
+namespace better_enums_data_ ## Enum {                                         \
+                                                                               \
+static ::better_enums::_initialize_at_program_start<Enum>                      \
+                                                _force_initialization;         \
+                                                                               \
+enum _putNamesInThisScopeAlso { __VA_ARGS__ };                                 \
+                                                                               \
+BETTER_ENUMS_IGNORE_OLD_CAST_HEADER                                            \
+BETTER_ENUMS_IGNORE_OLD_CAST_BEGIN                                             \
+BETTER_ENUMS_CONSTEXPR_ const Enum      _value_array[] =                       \
+    { BETTER_ENUMS_ID(BETTER_ENUMS_EAT_ASSIGN(Enum, __VA_ARGS__)) };           \
+BETTER_ENUMS_IGNORE_OLD_CAST_END                                               \
+                                                                               \
+BETTER_ENUMS_ID(GenerateStrings(Enum, __VA_ARGS__))                            \
+                                                                               \
+}                                                                              \
+                                                                               \
+BETTER_ENUMS_IGNORE_ATTRIBUTES_HEADER                                          \
+BETTER_ENUMS_IGNORE_ATTRIBUTES_BEGIN                                           \
+BETTER_ENUMS_UNUSED BETTER_ENUMS_CONSTEXPR_                                    \
+inline const Enum                                                              \
+operator +(Enum::_enumerated enumerated)                                       \
+{                                                                              \
+    return static_cast<Enum>(enumerated);                                      \
+}                                                                              \
+BETTER_ENUMS_IGNORE_ATTRIBUTES_END                                             \
+                                                                               \
+BETTER_ENUMS_CONSTEXPR_ inline Enum::_optional_index                           \
+Enum::_from_value_loop(Enum::_integral value, std::size_t index)               \
+{                                                                              \
+    return                                                                     \
+        index == _size() ?                                                     \
+            _optional_index() :                                                \
+            BETTER_ENUMS_NS(Enum)::_value_array[index]._value == value ?       \
+                _optional_index(index) :                                       \
+                _from_value_loop(value, index + 1);                            \
+}                                                                              \
+                                                                               \
+BETTER_ENUMS_CONSTEXPR_ inline Enum::_optional_index                           \
+Enum::_from_string_loop(const char *name, std::size_t index)                   \
+{                                                                              \
+    return                                                                     \
+        index == _size() ? _optional_index() :                                 \
+        ::better_enums::_names_match(                                          \
+            BETTER_ENUMS_NS(Enum)::_raw_names()[index], name) ?                \
+            _optional_index(index) :                                           \
+            _from_string_loop(name, index + 1);                                \
+}                                                                              \
+                                                                               \
+BETTER_ENUMS_CONSTEXPR_ inline Enum::_optional_index                           \
+Enum::_from_string_nocase_loop(const char *name, std::size_t index)            \
+{                                                                              \
+    return                                                                     \
+        index == _size() ? _optional_index() :                                 \
+            ::better_enums::_names_match_nocase(                               \
+                BETTER_ENUMS_NS(Enum)::_raw_names()[index], name) ?            \
+                    _optional_index(index) :                                   \
+                    _from_string_nocase_loop(name, index + 1);                 \
+}                                                                              \
+                                                                               \
+BETTER_ENUMS_CONSTEXPR_ inline Enum::_integral Enum::_to_integral() const      \
+{                                                                              \
+    return _integral(_value);                                                  \
+}                                                                              \
+                                                                               \
+BETTER_ENUMS_CONSTEXPR_ inline std::size_t Enum::_to_index() const             \
+{                                                                              \
+    return *_from_value_loop(_value);                                          \
+}                                                                              \
+                                                                               \
+BETTER_ENUMS_CONSTEXPR_ inline Enum                                            \
+Enum::_from_index_unchecked(std::size_t index)                                 \
+{                                                                              \
+    return                                                                     \
+        ::better_enums::_or_zero(_from_index_nothrow(index));                  \
+}                                                                              \
+                                                                               \
+BETTER_ENUMS_CONSTEXPR_ inline Enum::_optional                                 \
+Enum::_from_index_nothrow(std::size_t index)                                   \
+{                                                                              \
+    return                                                                     \
+        index >= _size() ?                                                     \
+            _optional() :                                                      \
+             _optional(BETTER_ENUMS_NS(Enum)::_value_array[index]);            \
+}                                                                              \
+                                                                               \
+BETTER_ENUMS_IF_EXCEPTIONS(                                                    \
+BETTER_ENUMS_CONSTEXPR_ inline Enum Enum::_from_index(std::size_t index)       \
+{                                                                              \
+    return                                                                     \
+        ::better_enums::_or_throw(_from_index_nothrow(index),                  \
+                                  #Enum "::_from_index: invalid argument");    \
+}                                                                              \
+)                                                                              \
+                                                                               \
+BETTER_ENUMS_CONSTEXPR_ inline Enum                                            \
+Enum::_from_integral_unchecked(_integral value)                                \
+{                                                                              \
+    return static_cast<_enumerated>(value);                                    \
+}                                                                              \
+                                                                               \
+BETTER_ENUMS_CONSTEXPR_ inline Enum::_optional                                 \
+Enum::_from_integral_nothrow(_integral value)                                  \
+{                                                                              \
+    return                                                                     \
+        ::better_enums::_map_index<Enum>(BETTER_ENUMS_NS(Enum)::_value_array,  \
+                                         _from_value_loop(value));             \
+}                                                                              \
+                                                                               \
+BETTER_ENUMS_IF_EXCEPTIONS(                                                    \
+BETTER_ENUMS_CONSTEXPR_ inline Enum Enum::_from_integral(_integral value)      \
+{                                                                              \
+    return                                                                     \
+        ::better_enums::_or_throw(_from_integral_nothrow(value),               \
+                                  #Enum "::_from_integral: invalid argument"); \
+}                                                                              \
+)                                                                              \
+                                                                               \
+ToStringConstexpr inline const char* Enum::_to_string() const                  \
+{                                                                              \
+    return                                                                     \
+        ::better_enums::_or_null(                                              \
+            ::better_enums::_map_index<const char*>(                           \
+                BETTER_ENUMS_NS(Enum)::_name_array(),                          \
+                _from_value_loop(CallInitialize(_value))));                    \
+}                                                                              \
+                                                                               \
+BETTER_ENUMS_CONSTEXPR_ inline Enum::_optional                                 \
+Enum::_from_string_nothrow(const char *name)                                   \
+{                                                                              \
+    return                                                                     \
+        ::better_enums::_map_index<Enum>(                                      \
+            BETTER_ENUMS_NS(Enum)::_value_array, _from_string_loop(name));     \
+}                                                                              \
+                                                                               \
+BETTER_ENUMS_IF_EXCEPTIONS(                                                    \
+BETTER_ENUMS_CONSTEXPR_ inline Enum Enum::_from_string(const char *name)       \
+{                                                                              \
+    return                                                                     \
+        ::better_enums::_or_throw(_from_string_nothrow(name),                  \
+                                  #Enum "::_from_string: invalid argument");   \
+}                                                                              \
+)                                                                              \
+                                                                               \
+BETTER_ENUMS_CONSTEXPR_ inline Enum::_optional                                 \
+Enum::_from_string_nocase_nothrow(const char *name)                            \
+{                                                                              \
+    return                                                                     \
+        ::better_enums::_map_index<Enum>(BETTER_ENUMS_NS(Enum)::_value_array,  \
+                                         _from_string_nocase_loop(name));      \
+}                                                                              \
+                                                                               \
+BETTER_ENUMS_IF_EXCEPTIONS(                                                    \
+BETTER_ENUMS_CONSTEXPR_ inline Enum Enum::_from_string_nocase(const char *name)\
+{                                                                              \
+    return                                                                     \
+        ::better_enums::_or_throw(                                             \
+            _from_string_nocase_nothrow(name),                                 \
+            #Enum "::_from_string_nocase: invalid argument");                  \
+}                                                                              \
+)                                                                              \
+                                                                               \
+BETTER_ENUMS_CONSTEXPR_ inline bool Enum::_is_valid(_integral value)           \
+{                                                                              \
+    return _from_value_loop(value);                                            \
+}                                                                              \
+                                                                               \
+BETTER_ENUMS_CONSTEXPR_ inline bool Enum::_is_valid(const char *name)          \
+{                                                                              \
+    return _from_string_loop(name);                                            \
+}                                                                              \
+                                                                               \
+BETTER_ENUMS_CONSTEXPR_ inline bool Enum::_is_valid_nocase(const char *name)   \
+{                                                                              \
+    return _from_string_nocase_loop(name);                                     \
+}                                                                              \
+                                                                               \
+BETTER_ENUMS_CONSTEXPR_ inline const char* Enum::_name()                       \
+{                                                                              \
+    return #Enum;                                                              \
+}                                                                              \
+                                                                               \
+BETTER_ENUMS_CONSTEXPR_ inline Enum::_value_iterable Enum::_values()           \
+{                                                                              \
+    return _value_iterable(BETTER_ENUMS_NS(Enum)::_value_array, _size());      \
+}                                                                              \
+                                                                               \
+ToStringConstexpr inline Enum::_name_iterable Enum::_names()                   \
+{                                                                              \
+    return                                                                     \
+        _name_iterable(BETTER_ENUMS_NS(Enum)::_name_array(),                   \
+                       CallInitialize(_size()));                               \
+}                                                                              \
+                                                                               \
+DefineInitialize(Enum)                                                         \
+                                                                               \
+BETTER_ENUMS_IGNORE_ATTRIBUTES_HEADER                                          \
+BETTER_ENUMS_IGNORE_ATTRIBUTES_BEGIN                                           \
+BETTER_ENUMS_UNUSED BETTER_ENUMS_CONSTEXPR_                                    \
+inline bool operator ==(const Enum &a, const Enum &b)                          \
+    { return a._to_integral() == b._to_integral(); }                           \
+                                                                               \
+BETTER_ENUMS_UNUSED BETTER_ENUMS_CONSTEXPR_                                    \
+inline bool operator !=(const Enum &a, const Enum &b)                          \
+    { return a._to_integral() != b._to_integral(); }                           \
+                                                                               \
+BETTER_ENUMS_UNUSED BETTER_ENUMS_CONSTEXPR_                                    \
+inline bool operator <(const Enum &a, const Enum &b)                           \
+    { return a._to_integral() < b._to_integral(); }                            \
+                                                                               \
+BETTER_ENUMS_UNUSED BETTER_ENUMS_CONSTEXPR_                                    \
+inline bool operator <=(const Enum &a, const Enum &b)                          \
+    { return a._to_integral() <= b._to_integral(); }                           \
+                                                                               \
+BETTER_ENUMS_UNUSED BETTER_ENUMS_CONSTEXPR_                                    \
+inline bool operator >(const Enum &a, const Enum &b)                           \
+    { return a._to_integral() > b._to_integral(); }                            \
+                                                                               \
+BETTER_ENUMS_UNUSED BETTER_ENUMS_CONSTEXPR_                                    \
+inline bool operator >=(const Enum &a, const Enum &b)                          \
+    { return a._to_integral() >= b._to_integral(); }                           \
+BETTER_ENUMS_IGNORE_ATTRIBUTES_END                                             \
+                                                                               \
+                                                                               \
+template <typename Char, typename Traits>                                      \
+std::basic_ostream<Char, Traits>&                                              \
+operator <<(std::basic_ostream<Char, Traits>& stream, const Enum &value)       \
+{                                                                              \
+    return stream << value._to_string();                                       \
+}                                                                              \
+                                                                               \
+template <typename Char, typename Traits>                                      \
+std::basic_istream<Char, Traits>&                                              \
+operator >>(std::basic_istream<Char, Traits>& stream, Enum &value)             \
+{                                                                              \
+    std::basic_string<Char, Traits>     buffer;                                \
+                                                                               \
+    stream >> buffer;                                                          \
+    ::better_enums::optional<Enum>      converted =                            \
+        Enum::_from_string_nothrow(buffer.c_str());                            \
+                                                                               \
+    if (converted)                                                             \
+        value = *converted;                                                    \
+    else                                                                       \
+        stream.setstate(std::basic_istream<Char, Traits>::failbit);            \
+                                                                               \
+    return stream;                                                             \
+}
+
+
+
+// Enum feature options.
+
+// C++98, C++11
+#define BETTER_ENUMS_CXX98_UNDERLYING_TYPE(Underlying)
+
+// C++11
+#define BETTER_ENUMS_CXX11_UNDERLYING_TYPE(Underlying)                         \
+    : Underlying
+
+#if defined(_MSC_VER) && _MSC_VER >= 1700
+// VS 2012 and above fully support strongly typed enums and will warn about
+// incorrect usage.
+#   define BETTER_ENUMS_LEGACY_UNDERLYING_TYPE(Underlying) \
+        BETTER_ENUMS_CXX11_UNDERLYING_TYPE(Underlying)
+#else
+#   define BETTER_ENUMS_LEGACY_UNDERLYING_TYPE(Underlying) \
+        BETTER_ENUMS_CXX98_UNDERLYING_TYPE(Underlying)
+#endif
+
+// C++98, C++11
+#define BETTER_ENUMS_REGULAR_ENUM_SWITCH_TYPE(Type)                            \
+    _enumerated
+
+// C++11
+#define BETTER_ENUMS_ENUM_CLASS_SWITCH_TYPE(Type)                              \
+    BETTER_ENUMS_NS(Type)::_enumClassForSwitchStatements
+
+// C++98, C++11
+#define BETTER_ENUMS_REGULAR_ENUM_SWITCH_TYPE_GENERATE(Underlying, ...)
+
+// C++11
+#define BETTER_ENUMS_ENUM_CLASS_SWITCH_TYPE_GENERATE(Underlying, ...)          \
+    enum class _enumClassForSwitchStatements : Underlying { __VA_ARGS__ };
+
+// C++98
+#define BETTER_ENUMS_CXX98_TRIM_STRINGS_ARRAYS(Enum, ...)                      \
+    inline const char** _raw_names()                                           \
+    {                                                                          \
+        static const char   *value[] =                                         \
+            { BETTER_ENUMS_ID(BETTER_ENUMS_STRINGIZE(__VA_ARGS__)) };          \
+        return value;                                                          \
+    }                                                                          \
+                                                                               \
+    inline char* _name_storage()                                               \
+    {                                                                          \
+        static char         storage[] =                                        \
+            BETTER_ENUMS_ID(BETTER_ENUMS_RESERVE_STORAGE(__VA_ARGS__));        \
+        return storage;                                                        \
+    }                                                                          \
+                                                                               \
+    inline const char** _name_array()                                          \
+    {                                                                          \
+        static const char   *value[Enum::_size_constant];                      \
+        return value;                                                          \
+    }                                                                          \
+                                                                               \
+    inline bool& _initialized()                                                \
+    {                                                                          \
+        static bool         value = false;                                     \
+        return value;                                                          \
+    }
+
+// C++11 fast version
+#define BETTER_ENUMS_CXX11_PARTIAL_CONSTEXPR_TRIM_STRINGS_ARRAYS(Enum, ...)    \
+    constexpr const char    *_the_raw_names[] =                                \
+        { BETTER_ENUMS_ID(BETTER_ENUMS_STRINGIZE(__VA_ARGS__)) };              \
+                                                                               \
+    constexpr const char * const * _raw_names()                                \
+    {                                                                          \
+        return _the_raw_names;                                                 \
+    }                                                                          \
+                                                                               \
+    inline char* _name_storage()                                               \
+    {                                                                          \
+        static char         storage[] =                                        \
+            BETTER_ENUMS_ID(BETTER_ENUMS_RESERVE_STORAGE(__VA_ARGS__));        \
+        return storage;                                                        \
+    }                                                                          \
+                                                                               \
+    inline const char** _name_array()                                          \
+    {                                                                          \
+        static const char   *value[Enum::_size_constant];                      \
+        return value;                                                          \
+    }                                                                          \
+                                                                               \
+    inline bool& _initialized()                                                \
+    {                                                                          \
+        static bool         value = false;                                     \
+        return value;                                                          \
+    }
+
+// C++11 slow all-constexpr version
+#define BETTER_ENUMS_CXX11_FULL_CONSTEXPR_TRIM_STRINGS_ARRAYS(Enum, ...)       \
+    BETTER_ENUMS_ID(BETTER_ENUMS_TRIM_STRINGS(__VA_ARGS__))                    \
+                                                                               \
+    constexpr const char * const    _the_name_array[] =                        \
+        { BETTER_ENUMS_ID(BETTER_ENUMS_REFER_TO_STRINGS(__VA_ARGS__)) };       \
+                                                                               \
+    constexpr const char * const * _name_array()                               \
+    {                                                                          \
+        return _the_name_array;                                                \
+    }                                                                          \
+                                                                               \
+    constexpr const char * const * _raw_names()                                \
+    {                                                                          \
+        return _the_name_array;                                                \
+    }
+
+// C++98, C++11 fast version
+#define BETTER_ENUMS_NO_CONSTEXPR_TO_STRING_KEYWORD
+
+// C++11 slow all-constexpr version
+#define BETTER_ENUMS_CONSTEXPR_TO_STRING_KEYWORD                               \
+    constexpr
+
+// C++98, C++11 fast version
+#define BETTER_ENUMS_DO_DECLARE_INITIALIZE                                     \
+    static int initialize();
+
+// C++11 slow all-constexpr version
+#define BETTER_ENUMS_DECLARE_EMPTY_INITIALIZE                                  \
+    static int initialize() { return 0; }
+
+// C++98, C++11 fast version
+#define BETTER_ENUMS_DO_DEFINE_INITIALIZE(Enum)                                \
+    inline int Enum::initialize()                                              \
+    {                                                                          \
+        if (BETTER_ENUMS_NS(Enum)::_initialized())                             \
+            return 0;                                                          \
+                                                                               \
+        ::better_enums::_trim_names(BETTER_ENUMS_NS(Enum)::_raw_names(),       \
+                                    BETTER_ENUMS_NS(Enum)::_name_array(),      \
+                                    BETTER_ENUMS_NS(Enum)::_name_storage(),    \
+                                    _size());                                  \
+                                                                               \
+        BETTER_ENUMS_NS(Enum)::_initialized() = true;                          \
+                                                                               \
+        return 0;                                                              \
+    }
+
+// C++11 slow all-constexpr version
+#define BETTER_ENUMS_DO_NOT_DEFINE_INITIALIZE(Enum)
+
+// C++98, C++11 fast version
+#define BETTER_ENUMS_DO_CALL_INITIALIZE(value)                                 \
+    ::better_enums::continue_with(initialize(), value)
+
+// C++11 slow all-constexpr version
+#define BETTER_ENUMS_DO_NOT_CALL_INITIALIZE(value)                             \
+    value
+
+
+
+// User feature selection.
+
+#ifdef BETTER_ENUMS_STRICT_CONVERSION
+#   define BETTER_ENUMS_DEFAULT_SWITCH_TYPE                                    \
+        BETTER_ENUMS_ENUM_CLASS_SWITCH_TYPE
+#   define BETTER_ENUMS_DEFAULT_SWITCH_TYPE_GENERATE                           \
+        BETTER_ENUMS_ENUM_CLASS_SWITCH_TYPE_GENERATE
+#else
+#   define BETTER_ENUMS_DEFAULT_SWITCH_TYPE                                    \
+        BETTER_ENUMS_REGULAR_ENUM_SWITCH_TYPE
+#   define BETTER_ENUMS_DEFAULT_SWITCH_TYPE_GENERATE                           \
+        BETTER_ENUMS_REGULAR_ENUM_SWITCH_TYPE_GENERATE
+#endif
+
+
+
+#ifndef BETTER_ENUMS_DEFAULT_CONSTRUCTOR
+#   define BETTER_ENUMS_DEFAULT_CONSTRUCTOR(Enum)                              \
+      private:                                                                 \
+        Enum() : _value(0) { }
+#endif
+
+
+
+#ifdef BETTER_ENUMS_HAVE_CONSTEXPR
+
+#ifdef BETTER_ENUMS_CONSTEXPR_TO_STRING
+#   define BETTER_ENUMS_DEFAULT_TRIM_STRINGS_ARRAYS                            \
+        BETTER_ENUMS_CXX11_FULL_CONSTEXPR_TRIM_STRINGS_ARRAYS
+#   define BETTER_ENUMS_DEFAULT_TO_STRING_KEYWORD                              \
+        BETTER_ENUMS_CONSTEXPR_TO_STRING_KEYWORD
+#   define BETTER_ENUMS_DEFAULT_DECLARE_INITIALIZE                             \
+        BETTER_ENUMS_DECLARE_EMPTY_INITIALIZE
+#   define BETTER_ENUMS_DEFAULT_DEFINE_INITIALIZE                              \
+        BETTER_ENUMS_DO_NOT_DEFINE_INITIALIZE
+#   define BETTER_ENUMS_DEFAULT_CALL_INITIALIZE                                \
+        BETTER_ENUMS_DO_NOT_CALL_INITIALIZE
+#else
+#   define BETTER_ENUMS_DEFAULT_TRIM_STRINGS_ARRAYS                            \
+        BETTER_ENUMS_CXX11_PARTIAL_CONSTEXPR_TRIM_STRINGS_ARRAYS
+#   define BETTER_ENUMS_DEFAULT_TO_STRING_KEYWORD                              \
+        BETTER_ENUMS_NO_CONSTEXPR_TO_STRING_KEYWORD
+#   define BETTER_ENUMS_DEFAULT_DECLARE_INITIALIZE                             \
+        BETTER_ENUMS_DO_DECLARE_INITIALIZE
+#   define BETTER_ENUMS_DEFAULT_DEFINE_INITIALIZE                              \
+        BETTER_ENUMS_DO_DEFINE_INITIALIZE
+#   define BETTER_ENUMS_DEFAULT_CALL_INITIALIZE                                \
+        BETTER_ENUMS_DO_CALL_INITIALIZE
+#endif
+
+
+
+// Top-level macros.
+
+#define BETTER_ENUM(Enum, Underlying, ...)                                     \
+    BETTER_ENUMS_ID(BETTER_ENUMS_TYPE(                                         \
+        BETTER_ENUMS_CXX11_UNDERLYING_TYPE,                                    \
+        BETTER_ENUMS_DEFAULT_SWITCH_TYPE,                                      \
+        BETTER_ENUMS_DEFAULT_SWITCH_TYPE_GENERATE,                             \
+        BETTER_ENUMS_DEFAULT_TRIM_STRINGS_ARRAYS,                              \
+        BETTER_ENUMS_DEFAULT_TO_STRING_KEYWORD,                                \
+        BETTER_ENUMS_DEFAULT_DECLARE_INITIALIZE,                               \
+        BETTER_ENUMS_DEFAULT_DEFINE_INITIALIZE,                                \
+        BETTER_ENUMS_DEFAULT_CALL_INITIALIZE,                                  \
+        Enum, Underlying, __VA_ARGS__))
+
+#define SLOW_ENUM(Enum, Underlying, ...)                                       \
+    BETTER_ENUMS_ID(BETTER_ENUMS_TYPE(                                         \
+        BETTER_ENUMS_CXX11_UNDERLYING_TYPE,                                    \
+        BETTER_ENUMS_DEFAULT_SWITCH_TYPE,                                      \
+        BETTER_ENUMS_DEFAULT_SWITCH_TYPE_GENERATE,                             \
+        BETTER_ENUMS_CXX11_FULL_CONSTEXPR_TRIM_STRINGS_ARRAYS,                 \
+        BETTER_ENUMS_CONSTEXPR_TO_STRING_KEYWORD,                              \
+        BETTER_ENUMS_DECLARE_EMPTY_INITIALIZE,                                 \
+        BETTER_ENUMS_DO_NOT_DEFINE_INITIALIZE,                                 \
+        BETTER_ENUMS_DO_NOT_CALL_INITIALIZE,                                   \
+        Enum, Underlying, __VA_ARGS__))
+
+#else
+
+#define BETTER_ENUM(Enum, Underlying, ...)                                     \
+    BETTER_ENUMS_ID(BETTER_ENUMS_TYPE(                                         \
+        BETTER_ENUMS_LEGACY_UNDERLYING_TYPE,                                   \
+        BETTER_ENUMS_DEFAULT_SWITCH_TYPE,                                      \
+        BETTER_ENUMS_DEFAULT_SWITCH_TYPE_GENERATE,                             \
+        BETTER_ENUMS_CXX98_TRIM_STRINGS_ARRAYS,                                \
+        BETTER_ENUMS_NO_CONSTEXPR_TO_STRING_KEYWORD,                           \
+        BETTER_ENUMS_DO_DECLARE_INITIALIZE,                                    \
+        BETTER_ENUMS_DO_DEFINE_INITIALIZE,                                     \
+        BETTER_ENUMS_DO_CALL_INITIALIZE,                                       \
+        Enum, Underlying, __VA_ARGS__))
+
+#endif
+
+
+
+namespace better_enums {
+
+// Maps.
+
+template <typename T>
+struct map_compare {
+    BETTER_ENUMS_CONSTEXPR_ static bool less(const T& a, const T& b)
+        { return a < b; }
+};
+
+template <>
+struct map_compare<const char*> {
+    BETTER_ENUMS_CONSTEXPR_ static bool less(const char *a, const char *b)
+        { return less_loop(a, b); }
+
+  private:
+    BETTER_ENUMS_CONSTEXPR_ static bool
+    less_loop(const char *a, const char *b, size_t index = 0)
+    {
+        return
+            a[index] != b[index] ? a[index] < b[index] :
+            a[index] == '\0' ? false :
+            less_loop(a, b, index + 1);
+    }
+};
+
+template <>
+struct map_compare<const wchar_t*> {
+    BETTER_ENUMS_CONSTEXPR_ static bool less(const wchar_t *a, const wchar_t *b)
+        { return less_loop(a, b); }
+
+  private:
+    BETTER_ENUMS_CONSTEXPR_ static bool
+    less_loop(const wchar_t *a, const wchar_t *b, size_t index = 0)
+    {
+        return
+            a[index] != b[index] ? a[index] < b[index] :
+            a[index] == L'\0' ? false :
+            less_loop(a, b, index + 1);
+    }
+};
+
+template <typename Enum, typename T, typename Compare = map_compare<T> >
+struct map {
+    typedef T (*function)(Enum);
+
+    BETTER_ENUMS_CONSTEXPR_ explicit map(function f) : _f(f) { }
+
+    BETTER_ENUMS_CONSTEXPR_ T from_enum(Enum value) const { return _f(value); }
+    BETTER_ENUMS_CONSTEXPR_ T operator [](Enum value) const
+        { return _f(value); }
+
+    BETTER_ENUMS_CONSTEXPR_ Enum to_enum(T value) const
+    {
+        return
+            _or_throw(to_enum_nothrow(value), "map::to_enum: invalid argument");
+    }
+
+    BETTER_ENUMS_CONSTEXPR_ optional<Enum>
+    to_enum_nothrow(T value, size_t index = 0) const
+    {
+        return
+            index >= Enum::_size() ? optional<Enum>() :
+            Compare::less(_f(Enum::_values()[index]), value) ||
+            Compare::less(value, _f(Enum::_values()[index])) ?
+                to_enum_nothrow(value, index + 1) :
+            Enum::_values()[index];
+    }
+
+  private:
+    const function      _f;
+};
+
+template <typename Enum, typename T>
+BETTER_ENUMS_CONSTEXPR_ map<Enum, T> make_map(T (*f)(Enum))
+{
+    return map<Enum, T>(f);
+}
+
+}
+
+#define BETTER_ENUMS_DECLARE_STD_HASH(type)                                    \
+	namespace std {                                                            \
+    template <> struct hash<type>                                              \
+    {                                                                          \
+        size_t operator()(const type &x) const                                 \
+        {                                                                      \
+            return std::hash<size_t>()(x._to_integral());                      \
+        }                                                                      \
+    };                                                                         \
+	}
+
+#endif // #ifndef BETTER_ENUMS_ENUM_H
diff --git a/src/condor_job_router/submit_job.cpp b/src/condor_job_router/submit_job.cpp
index d3bdd87..50fd34f 100644
--- a/src/condor_job_router/submit_job.cpp
+++ b/src/condor_job_router/submit_job.cpp
@@ -474,7 +474,7 @@ static bool submit_job_with_current_priv( ClassAd & src, const char * schedd_nam
 		// we need to submit on hold (taken from condor_submit.V6/submit.C)
 		src.Assign(ATTR_JOB_STATUS, 5); // 5==HELD
 		src.Assign(ATTR_HOLD_REASON, "Spooling input data files");
-		src.Assign(ATTR_HOLD_REASON_CODE, CONDOR_HOLD_CODE_SpoolingInput);
+		src.Assign(ATTR_HOLD_REASON_CODE, CONDOR_HOLD_CODE::SpoolingInput);
 
 			// See the comment in the function body of ExpandInputFileList
 			// for an explanation of what is going on here.
diff --git a/src/condor_schedd.V6/dedicated_scheduler.cpp b/src/condor_schedd.V6/dedicated_scheduler.cpp
index de4985a..aa8bf89 100644
--- a/src/condor_schedd.V6/dedicated_scheduler.cpp
+++ b/src/condor_schedd.V6/dedicated_scheduler.cpp
@@ -1372,7 +1372,7 @@ DedicatedScheduler::sortJobs( void )
 
 		formatstr(fifoConstraint, "%s == %d && %s == %d && %s == %d", ATTR_JOB_UNIVERSE, CONDOR_UNIVERSE_PARALLEL, 
 																ATTR_JOB_STATUS, HELD, 
-																ATTR_HOLD_REASON_CODE, CONDOR_HOLD_CODE_SpoolingInput);
+																ATTR_HOLD_REASON_CODE, CONDOR_HOLD_CODE::SpoolingInput);
 		ClassAd *spoolingInJob = NULL;
 		bool firstTime = true;
 		while ((spoolingInJob = GetNextJobByConstraint(fifoConstraint.c_str(), firstTime))) {
diff --git a/src/condor_schedd.V6/qmgmt.cpp b/src/condor_schedd.V6/qmgmt.cpp
index 6959865..ba9bb9c 100644
--- a/src/condor_schedd.V6/qmgmt.cpp
+++ b/src/condor_schedd.V6/qmgmt.cpp
@@ -928,7 +928,7 @@ ConvertOldJobAdAttrs( ClassAd *job_ad, bool startup )
 		job_ad->LookupString( ATTR_HOLD_REASON, hold_reason );
 		if ( hold_reason == "Spooling input data files" ) {
 			job_ad->Assign( ATTR_HOLD_REASON_CODE,
-							CONDOR_HOLD_CODE_SpoolingInput );
+							CONDOR_HOLD_CODE::SpoolingInput );
 		}
 	}
 
@@ -1906,7 +1906,7 @@ InitJobQueue(const char *job_queue_name,int max_historical_logs)
 				// we need to redo the rewriting here.
 			int hold_code = -1;
 			ad->LookupInteger(ATTR_HOLD_REASON_CODE, hold_code);
-			if ( job_status == HELD && hold_code == CONDOR_HOLD_CODE_SpoolingInput ) {
+			if ( job_status == HELD && hold_code == CONDOR_HOLD_CODE::SpoolingInput ) {
 				if ( rewriteSpooledJobAd( ad, cluster, proc, true ) ) {
 					JobQueueDirty = true;
 				}
@@ -3786,7 +3786,7 @@ enum {
 	catSubmitterIdent = 0x0040,
 	catNewMaterialize = 0x0080,  // attributes that control the job factory
 	catMaterializeState = 0x0100, // change in state of job factory
-	catSpoolingHold = 0x0200,    // hold reason was set to CONDOR_HOLD_CODE_SpoolingInput
+	catSpoolingHold = 0x0200,    // hold reason was set to CONDOR_HOLD_CODE::SpoolingInput
 	catPostSubmitClusterChange = 0x400, // a cluster ad was changed after submit time which calls for special processing in commit transaction
 	catCallbackTrigger = 0x1000, // indicates that a callback should happen on commit of this attribute
 	catCallbackNow = 0x20000,    // indicates that a callback should happen when setAttribute is called
@@ -4549,7 +4549,7 @@ SetAttribute(int cluster_id, int proc_id, const char *attr_name,
 		bool is_spooling_hold = false;
 		if (attr_id == idATTR_HOLD_REASON_CODE) {
 			int hold_reason = (int)strtol( attr_value, NULL, 10 );
-			is_spooling_hold = (CONDOR_HOLD_CODE_SpoolingInput == hold_reason);
+			is_spooling_hold = (CONDOR_HOLD_CODE::SpoolingInput == hold_reason);
 		} else if (attr_id == idATTR_HOLD_REASON) {
 			is_spooling_hold = YourString("Spooling input data files") == attr_value;
 		}
@@ -5903,7 +5903,7 @@ int CommitTransactionInternal( bool durable, CondorError * errorStack ) {
 				int hold_code = -1;
 				procad->LookupInteger(ATTR_JOB_STATUS, job_status);
 				procad->LookupInteger(ATTR_HOLD_REASON_CODE, hold_code);
-				if ( job_status == HELD && hold_code == CONDOR_HOLD_CODE_SpoolingInput ) {
+				if ( job_status == HELD && hold_code == CONDOR_HOLD_CODE::SpoolingInput ) {
 					SpooledJobFiles::createJobSpoolDirectory(procad,PRIV_UNKNOWN);
 				}
 
@@ -5948,7 +5948,7 @@ int CommitTransactionInternal( bool durable, CondorError * errorStack ) {
 								  ATTR_TRANSFER_INPUT_SIZE_MB, (int)xfer_input_size_mb,
 								  "MAX_TRANSFER_INPUT_MB", (int)max_xfer_input_mb);
 						holdJob(job_id.cluster, job_id.proc, hold_reason.c_str(),
-								CONDOR_HOLD_CODE_MaxTransferInputSizeExceeded, 0);
+								CONDOR_HOLD_CODE::MaxTransferInputSizeExceeded, 0);
 					}
 				}
 			}
diff --git a/src/condor_schedd.V6/qmgmt_factory.cpp b/src/condor_schedd.V6/qmgmt_factory.cpp
index ee1f29f..38eb2ad 100644
--- a/src/condor_schedd.V6/qmgmt_factory.cpp
+++ b/src/condor_schedd.V6/qmgmt_factory.cpp
@@ -583,7 +583,7 @@ int  MaterializeNextFactoryJob(JobFactory * factory, JobQueueCluster * ClusterAd
 		std::string txt(factory->error_stack()->getFullText()); if (txt.empty()) { txt = ""; }
 		formatstr(msg, "failed to create ClassAd for Job %d.%d : %s", jid.cluster, jid.proc, txt.c_str());
 		dprintf(D_ALWAYS, "ERROR: %s", msg.c_str());
-		setJobFactoryPauseAndLog(ClusterAd, mmHold, CONDOR_HOLD_CODE_Unspecified, msg);
+		setJobFactoryPauseAndLog(ClusterAd, mmHold, CONDOR_HOLD_CODE::Unspecified, msg);
 		//factory->Pause(mmHold);
 		//ClusterAd->Assign(ATTR_JOB_MATERIALIZE_PAUSED, mmHold);
 		//ClusterAd->Assign(ATTR_JOB_MATERIALIZE_PAUSE_REASON, msg);
diff --git a/src/condor_schedd.V6/schedd.cpp b/src/condor_schedd.V6/schedd.cpp
index 3d1bf0c..fb3fbb9 100644
--- a/src/condor_schedd.V6/schedd.cpp
+++ b/src/condor_schedd.V6/schedd.cpp
@@ -1027,7 +1027,7 @@ int check_for_spool_zombies(JobQueueJob *job, const JOB_ID_KEY & /*jid*/, void *
 			int hold_reason_code;
 			if( GetAttributeInt(cluster,proc,ATTR_HOLD_REASON_CODE,
 					&hold_reason_code) >= 0) {
-				if(hold_reason_code == CONDOR_HOLD_CODE_SpoolingInput) {
+				if(hold_reason_code == CONDOR_HOLD_CODE::SpoolingInput) {
 					dprintf( D_FULLDEBUG, "Job %d.%d held for spooling. "
 						"Checking how long...\n",cluster,proc);
 					int stage_in_start;
@@ -3699,7 +3699,7 @@ abort_job_myself( PROC_ID job_id, JobAction action, bool log_hold )
 				formatstr(msg, "Unable to switch to user: %s", owner.c_str());
 #endif
 				holdJob(job_id.cluster, job_id.proc, msg.c_str(), 
-						CONDOR_HOLD_CODE_FailedToAccessUserAccount, 0,
+						CONDOR_HOLD_CODE::FailedToAccessUserAccount, 0,
 					false, true, false, false);
 				return;
 			}
@@ -3821,7 +3821,7 @@ ResponsibleForPeriodicExprs( JobQueueJob *jobad, int & status )
 	if( status == HELD ) {
 		int hold_reason_code = -1;
 		jobad->LookupInteger(ATTR_HOLD_REASON_CODE,hold_reason_code);
-		if( hold_reason_code == CONDOR_HOLD_CODE_SpoolingInput ) {
+		if( hold_reason_code == CONDOR_HOLD_CODE::SpoolingInput ) {
 			dprintf(D_FULLDEBUG,"Skipping periodic expressions for job %d.%d, because hold reason code is '%d'\n",
 				jobad->jid.cluster, jobad->jid.proc, hold_reason_code);
 			return 0;
@@ -5344,7 +5344,7 @@ Scheduler::spoolJobFiles(int mode, Stream* s)
 							ATTR_HOLD_REASON_CODE,&holdcode) >= 0) {
 						dprintf( D_FULLDEBUG, "job_status is %d\n", job_status);
 						if(job_status == HELD &&
-								holdcode != CONDOR_HOLD_CODE_SpoolingInput) {
+								holdcode != CONDOR_HOLD_CODE::SpoolingInput) {
 							dprintf( D_AUDIT | D_FAILURE, *rsock, "Job %d.%d is not in hold state for "
 								"spooling. Do not allow stagein\n",
 								a_job.cluster, a_job.proc);
@@ -5978,7 +5978,7 @@ Scheduler::actOnJobs(int, Stream* s)
 				// input files to be spooled, (or cluster ads - so late materialization works)
 			snprintf( buf, 256, "(ProcId is undefined || (%s==%d && %s=!=%d)) && (", ATTR_JOB_STATUS,
 					  HELD, ATTR_HOLD_REASON_CODE,
-					  CONDOR_HOLD_CODE_SpoolingInput );
+					  CONDOR_HOLD_CODE::SpoolingInput );
 			break;
 		case JA_SUSPEND_JOBS:
 				// Only suspend running/staging jobs outside local & sched unis
@@ -6163,7 +6163,7 @@ Scheduler::actOnJobs(int, Stream* s)
 		case JA_RELEASE_JOBS:
 			GetAttributeInt(tmp_id.cluster, tmp_id.proc,
 							ATTR_HOLD_REASON_CODE, &hold_reason_code);
-			if( status != HELD || hold_reason_code == CONDOR_HOLD_CODE_SpoolingInput ) {
+			if( status != HELD || hold_reason_code == CONDOR_HOLD_CODE::SpoolingInput ) {
 				results.record( tmp_id, AR_BAD_STATUS );
 				jobs[i].cluster = -1;
 				continue;
@@ -6214,18 +6214,20 @@ Scheduler::actOnJobs(int, Stream* s)
 				jobs[i].cluster = -1;
 				continue;
 			}
-			if( SetAttributeInt( tmp_id.cluster, tmp_id.proc,
-								 ATTR_HOLD_REASON_CODE,
-								 CONDOR_HOLD_CODE_UserRequest ) < 0 ) {
-				results.record( tmp_id, AR_PERMISSION_DENIED );
-				jobs[i].cluster = -1;
-				continue;
-			}
-			if( SetAttributeInt( tmp_id.cluster, tmp_id.proc,
-								 ATTR_HOLD_REASON_SUBCODE,
-								 hold_reason_subcode ) < 0 )
+			if (holdJob(tmp_id.cluster, tmp_id.proc,
+				reason.c_str(),	// hold reason string
+				CONDOR_HOLD_CODE::UserRequest,	// hold reason code
+				hold_reason_subcode,	// hold reason subcode
+				false,	// use_transaction
+				false,	// email user?
+				false,	// email admin?
+				false,	// system hold?
+				false	// write to user log?  Set to false cause actOnJobs does not do this here...
+				) == false)
 			{
-				results.record( tmp_id, AR_PERMISSION_DENIED );
+				// We already tested above for all possibilities other than AR_PERMISSION_DENIED
+				// before calling holdJob(), so if holdJob() fails it is because permission denied...
+				results.record(tmp_id, AR_PERMISSION_DENIED);
 				jobs[i].cluster = -1;
 				continue;
 			}
@@ -6242,7 +6244,8 @@ Scheduler::actOnJobs(int, Stream* s)
 		}
 
 			// Ok, we're happy, do the deed.
-		if( action == JA_VACATE_JOBS || 
+		if( action == JA_HOLD_JOBS ||   // if hold, we already invoked holdJobs() above so all done
+			action == JA_VACATE_JOBS ||
 			action == JA_VACATE_FAST_JOBS || 
 		    action == JA_SUSPEND_JOBS || 
 		    action == JA_CONTINUE_JOBS ) {
@@ -6440,9 +6443,9 @@ Scheduler::actOnJobs(int, Stream* s)
 			continue;
 		if (action == JA_HOLD_JOBS) {
 			// log the change in pause state
-			setJobFactoryPauseAndLog(clusterad, mmHold, CONDOR_HOLD_CODE_UserRequest, reason.c_str());
+			setJobFactoryPauseAndLog(clusterad, mmHold, CONDOR_HOLD_CODE::UserRequest, reason.c_str());
 		} else if (action == JA_RELEASE_JOBS) {
-			setJobFactoryPauseAndLog(clusterad, mmRunning, CONDOR_HOLD_CODE_UserRequest, reason.c_str());
+			setJobFactoryPauseAndLog(clusterad, mmRunning, CONDOR_HOLD_CODE::UserRequest, reason.c_str());
 		}
 	}
 
@@ -9922,7 +9925,7 @@ Scheduler::noShadowForJob( shadow_rec* srec, NoShadowFailure_t why )
 		// hold the job, since we won't be able to run it without
 		// human intervention
 	holdJob( job_id.cluster, job_id.proc, hold_reason, 
-			 CONDOR_HOLD_CODE_NoCompatibleShadow, 0,
+			 CONDOR_HOLD_CODE::NoCompatibleShadow, 0,
 			 true, true, *notify_admin );
 
 		// regardless of what it used to be, we need to record that we
@@ -9991,7 +9994,7 @@ Scheduler::spawnLocalStarter( shadow_rec* srec )
 				 job_id->proc );
 		holdJob( job_id->cluster, job_id->proc,
 				 "No condor_starter installed that supports local universe",
-				 CONDOR_HOLD_CODE_NoCompatibleShadow, 0,
+				 CONDOR_HOLD_CODE::NoCompatibleShadow, 0,
 				 false, notify_admin, true );
 		delete_shadow_rec( srec );
 		notify_admin = false;
@@ -10232,7 +10235,7 @@ Scheduler::start_sched_universe_job(PROC_ID* job_id)
 		formatstr(tmpstr, "Unable to switch to user: %s", owner.c_str());
 #endif
 		holdJob(job_id->cluster, job_id->proc, tmpstr.c_str(),
-				CONDOR_HOLD_CODE_FailedToAccessUserAccount, 0,
+				CONDOR_HOLD_CODE::FailedToAccessUserAccount, 0,
 				false, true, false, false);
 		goto wrapup;
 	}
@@ -10261,7 +10264,7 @@ Scheduler::start_sched_universe_job(PROC_ID* job_id)
 
 			holdJob(job_id->cluster, job_id->proc, 
 				"Spooled executable is not executable!",
-					CONDOR_HOLD_CODE_FailedToCreateProcess, EACCES,
+					CONDOR_HOLD_CODE::FailedToCreateProcess, EACCES,
 				false, true, false, false );
 
 			delete filestat;
@@ -10286,7 +10289,7 @@ Scheduler::start_sched_universe_job(PROC_ID* job_id)
 			set_priv( priv );  // back to regular privs...
 			holdJob(job_id->cluster, job_id->proc, 
 				"Executable unknown - not specified in job ad!",
-					CONDOR_HOLD_CODE_FailedToCreateProcess, ENOENT,
+					CONDOR_HOLD_CODE::FailedToCreateProcess, ENOENT,
 				false, true, false, false );
 			goto wrapup;
 		}
@@ -10310,7 +10313,7 @@ Scheduler::start_sched_universe_job(PROC_ID* job_id)
 			formatstr( tmpstr, "File '%s' is missing or not executable", a_out_name.c_str() );
 			set_priv( priv );  // back to regular privs...
 			holdJob(job_id->cluster, job_id->proc, tmpstr.c_str(),
-					CONDOR_HOLD_CODE_FailedToCreateProcess, EACCES,
+					CONDOR_HOLD_CODE::FailedToCreateProcess, EACCES,
 					false, true, false, false);
 			goto wrapup;
 		}
@@ -12391,11 +12394,11 @@ Scheduler::jobExitCode( PROC_ID job_id, int exit_code )
 			}
 			if ( SetAttributeInt(job_id.cluster, job_id.proc,
 								 ATTR_HOLD_REASON_CODE,
-								 CONDOR_HOLD_CODE_MissedDeferredExecutionTime)
+								 CONDOR_HOLD_CODE::MissedDeferredExecutionTime)
 				 < 0 ) {
 				dprintf( D_ALWAYS, "WARNING: Failed to set %s to %d for "
 						 "job %d.%d\n", ATTR_HOLD_REASON_CODE,
-						 CONDOR_HOLD_CODE_MissedDeferredExecutionTime,
+						 CONDOR_HOLD_CODE::MissedDeferredExecutionTime,
 						 job_id.cluster, job_id.proc );
 			}
 			dprintf( D_ALWAYS, "Job %d.%d missed its deferred execution time\n",
@@ -12721,7 +12724,7 @@ Scheduler::scheduler_univ_job_exit(int pid, int status, shadow_rec * srec)
 			reason2 += ") ";
 			reason2 += reason;
 			holdJob(job_id.cluster, job_id.proc, reason2.c_str(),
-					CONDOR_HOLD_CODE_JobPolicyUndefined, 0,
+					CONDOR_HOLD_CODE::JobPolicyUndefined, 0,
 				true,false,false,true);
 			break;
 	}
@@ -15834,7 +15837,41 @@ abortJobsByConstraint( const char *constraint,
 	return result;
 }
 
+static void
+incrementJobAdAttr(int cluster, int proc, const char* attrName, const char *nestedAdAttrName = nullptr)
+{
+	int val = 0;
+	if (!attrName || !attrName[0]) return;
+	if (nestedAdAttrName) {
+		// Here we are going to increment an attribute in an ad nested inside the job ad.
 
+		// First, get the nested ad as a string, and parse to a classad
+		classad::ClassAdParser parser;
+		char *adAsString = nullptr;
+		ClassAd ad;
+		GetAttributeExprNew(cluster, proc, nestedAdAttrName, &adAsString);
+		if (adAsString) {
+			parser.ParseClassAd(adAsString, ad, true);
+			free(adAsString);
+		}
+
+		// Next update the unparsed ad
+		ad.LookupInteger(attrName, val);
+		ad.Assign(attrName, ++val);
+
+		// Finally unparse ad back to a string, and write it back to the job log.
+		classad::ClassAdUnParser unparser;
+		std::string result;
+		unparser.Unparse(result, &ad);
+		SetAttribute(cluster, proc, nestedAdAttrName, result.c_str());
+	} else {
+		// Here we are going to increment an attribute in the job ad.
+
+		GetAttributeInt(cluster, proc, attrName, &val);
+		SetAttributeInt(cluster, proc, attrName, ++val);
+	}
+
+}
 
 /*
 Hold a job by stopping the shadow, changing the job state,
@@ -15852,7 +15889,6 @@ holdJobRaw( int cluster, int proc, const char* reason,
 	PROC_ID tmp_id;
 	tmp_id.cluster = cluster;
 	tmp_id.proc = proc;
-	int system_holds = 0;
 
 	if ( cluster < 1 || proc < 0 ) {
 		dprintf(D_FULLDEBUG,"holdJobRaw failed, job id (%d.%d) is malformed\n",
@@ -15871,10 +15907,6 @@ holdJobRaw( int cluster, int proc, const char* reason,
 		return false;
 	}
 
-	if ( system_hold ) {
-		GetAttributeInt(cluster, proc, ATTR_NUM_SYSTEM_HOLDS, &system_holds);
-	}
-
 	if( reason ) {
 		std::string fixed_reason;
 		if( reason[0] == '"' ) {
@@ -15923,9 +15955,23 @@ holdJobRaw( int cluster, int proc, const char* reason,
 				 ATTR_LAST_SUSPENSION_TIME, cluster, proc );
 	}
 
+	// Update count in job ad of how many times job was put on hold
+	incrementJobAdAttr(cluster, proc, ATTR_NUM_HOLDS);
+
+	// Update count per hold reason in the job ad.
+	// If the reason_code int is not a valid CONDOR_HOLD_CODE enum, an exception will be thrown.
+	try {
+		incrementJobAdAttr(cluster, proc, (CONDOR_HOLD_CODE::_from_integral(reason_code))._to_string(), ATTR_NUM_HOLDS_BY_REASON);
+	}
+	catch (std::runtime_error) {
+		// Somehow reason_code is not a valid hold reason, so consider it as Unspecified here.
+		incrementJobAdAttr(cluster, proc, (+CONDOR_HOLD_CODE::Unspecified)._to_string(), ATTR_NUM_HOLDS_BY_REASON);
+	}
+
+	// Update count in job ad of "system holds", whatever that is supposed to mean
+	// (this is a legacy attribute from way back when, keep it the same as it was for now)
 	if ( system_hold ) {
-		system_holds++;
-		SetAttributeInt(cluster, proc, ATTR_NUM_SYSTEM_HOLDS, system_holds);
+		incrementJobAdAttr(cluster, proc, ATTR_NUM_SYSTEM_HOLDS);
 	}
 
 	dprintf( D_ALWAYS, "Job %d.%d put on hold: %s\n", cluster, proc,
@@ -16801,7 +16847,7 @@ Scheduler::calculateCronTabSchedule( ClassAd *jobAd, bool calculate )
 			//	system_hold		- false
 			//
 		holdJob( id.cluster, id.proc, reason.c_str(),
-				 CONDOR_HOLD_CODE_InvalidCronSettings, 0,
+				 CONDOR_HOLD_CODE::InvalidCronSettings, 0,
 				 true, true, false, false );
 	}
 	
diff --git a/src/condor_shadow.V6.1/baseshadow.cpp b/src/condor_shadow.V6.1/baseshadow.cpp
index 3d738de..3211497 100644
--- a/src/condor_shadow.V6.1/baseshadow.cpp
+++ b/src/condor_shadow.V6.1/baseshadow.cpp
@@ -319,7 +319,7 @@ int BaseShadow::cdToIwd() {
 		formatstr(hold_reason, "Cannot access initial working directory %s: %s",
 		                    iwd.c_str(), strerror(chdir_errno));
 		dprintf( D_ALWAYS, "%s\n",hold_reason.c_str());
-		holdJobAndExit(hold_reason.c_str(),CONDOR_HOLD_CODE_IwdError,chdir_errno);
+		holdJobAndExit(hold_reason.c_str(),CONDOR_HOLD_CODE::IwdError,chdir_errno);
 		iRet = -1;
 	}
 	
@@ -829,7 +829,7 @@ void BaseShadow::initUserLog()
 		formatstr(hold_reason,"Failed to initialize user log");
 		dprintf( D_ALWAYS, "%s\n",hold_reason.c_str());
 		holdJobAndExit(hold_reason.c_str(),
-				CONDOR_HOLD_CODE_UnableToInitUserLog,0);
+				CONDOR_HOLD_CODE::UnableToInitUserLog,0);
 			// holdJobAndExit() should not return, but just in case it does
 			// EXCEPT
 		EXCEPT("Failed to initialize user log: %s",hold_reason.c_str());
diff --git a/src/condor_startd.V6/Resource.cpp b/src/condor_startd.V6/Resource.cpp
index 490f7a7..bb72dd5 100644
--- a/src/condor_startd.V6/Resource.cpp
+++ b/src/condor_startd.V6/Resource.cpp
@@ -1762,7 +1762,7 @@ Resource::hold_job( bool soft )
 
 	EvalInteger("WANT_HOLD_SUBCODE", r_classad, r_cur->ad(), hold_subcode);
 
-	r_cur->starterHoldJob(hold_reason.c_str(),CONDOR_HOLD_CODE_StartdHeldJob,hold_subcode,soft);
+	r_cur->starterHoldJob(hold_reason.c_str(),CONDOR_HOLD_CODE::StartdHeldJob,hold_subcode,soft);
 }
 
 int
diff --git a/src/condor_starter.V6.1/StarterHookMgr.cpp b/src/condor_starter.V6.1/StarterHookMgr.cpp
index b198b4c..9a89d32 100644
--- a/src/condor_starter.V6.1/StarterHookMgr.cpp
+++ b/src/condor_starter.V6.1/StarterHookMgr.cpp
@@ -162,7 +162,7 @@ StarterHookMgr::tryHookPrepareJob()
 				"ERROR in StarterHookMgr::tryHookPrepareJob: %s\n",
 				err_msg.c_str());
 		Starter->jic->notifyStarterError(err_msg.c_str(), true,
-						 CONDOR_HOLD_CODE_HookPrepareJobFailure, 0);
+						 CONDOR_HOLD_CODE::HookPrepareJobFailure, 0);
 		delete hook_client;
 		return -1;
 	}
@@ -298,7 +298,7 @@ HookPrepareJobClient::hookExited(int exit_status) {
 				"ERROR in StarterHookMgr::tryHookPrepareJob: %s\n",
 				err_msg.c_str());
 		Starter->jic->notifyStarterError(err_msg.c_str(), true,
-							 CONDOR_HOLD_CODE_HookPrepareJobFailure, subcode);
+							 CONDOR_HOLD_CODE::HookPrepareJobFailure, subcode);
 		Starter->RemoteShutdownFast(0);
 	}
 	else {
diff --git a/src/condor_starter.V6.1/docker_proc.cpp b/src/condor_starter.V6.1/docker_proc.cpp
index 61976c2..9ac4f7c 100644
--- a/src/condor_starter.V6.1/docker_proc.cpp
+++ b/src/condor_starter.V6.1/docker_proc.cpp
@@ -294,7 +294,7 @@ bool DockerProc::JobReaper( int pid, int status ) {
 			}
 			}
 			message = buf;
-			Starter->jic->holdJob(message.c_str(), CONDOR_HOLD_CODE_InvalidDockerImage, 0);
+			Starter->jic->holdJob(message.c_str(), CONDOR_HOLD_CODE::InvalidDockerImage, 0);
 			{
 			TemporaryPrivSentry sentry(PRIV_USER);
 			unlink("docker_stderror");
@@ -480,7 +480,7 @@ bool DockerProc::JobReaper( int pid, int status ) {
 			dprintf(D_ALWAYS, "%s, going on hold\n", message.c_str());
 
 
-			Starter->jic->holdJob(message.c_str(), CONDOR_HOLD_CODE_JobOutOfResources, 0);
+			Starter->jic->holdJob(message.c_str(), CONDOR_HOLD_CODE::JobOutOfResources, 0);
 			DockerAPI::rm( containerName, error );
 
 			if ( Starter->Hold( ) ) {
@@ -505,7 +505,7 @@ bool DockerProc::JobReaper( int pid, int status ) {
 			dprintf(D_ALWAYS, "%s, going on hold\n", message.c_str());
 
 
-			Starter->jic->holdJob(message.c_str(), CONDOR_HOLD_CODE_FailedToCreateProcess, 0);
+			Starter->jic->holdJob(message.c_str(), CONDOR_HOLD_CODE::FailedToCreateProcess, 0);
 			DockerAPI::rm( containerName, error );
 
 			if ( Starter->Hold( ) ) {
diff --git a/src/condor_starter.V6.1/glexec_privsep_helper.linux.cpp b/src/condor_starter.V6.1/glexec_privsep_helper.linux.cpp
index 721e593..1ff4a21 100644
--- a/src/condor_starter.V6.1/glexec_privsep_helper.linux.cpp
+++ b/src/condor_starter.V6.1/glexec_privsep_helper.linux.cpp
@@ -200,7 +200,7 @@ GLExecPrivSepHelper::chown_sandbox_to_user(PrivSepError &err)
 	MyString error_desc = "error changing sandbox ownership to the user: ";
 	int rc = run_script(args,error_desc);
 	if( rc != 0) {
-		int hold_code = CONDOR_HOLD_CODE_GlexecChownSandboxToUser;
+		int hold_code = CONDOR_HOLD_CODE::GlexecChownSandboxToUser;
 		if( rc != INVALID_PROXY_RC && !param_boolean("GLEXEC_HOLD_ON_INITIAL_FAILURE",true) ) {
 			// Do not put the job on hold due to glexec failure.
 			// It will simply return to idle status and try again.
@@ -240,7 +240,7 @@ GLExecPrivSepHelper::chown_sandbox_to_condor(PrivSepError &err)
 	int rc = run_script(args,error_desc);
 	if( rc != 0) {
 		err.setHoldInfo(
-			CONDOR_HOLD_CODE_GlexecChownSandboxToCondor, rc,
+			CONDOR_HOLD_CODE::GlexecChownSandboxToCondor, rc,
 			error_desc.c_str());
 		return false;
 	}
diff --git a/src/condor_starter.V6.1/jic_local_schedd.cpp b/src/condor_starter.V6.1/jic_local_schedd.cpp
index f64ac98..ead75d3 100644
--- a/src/condor_starter.V6.1/jic_local_schedd.cpp
+++ b/src/condor_starter.V6.1/jic_local_schedd.cpp
@@ -497,7 +497,7 @@ JICLocalSchedd::initLocalUserLog( void )
 	bool ret = u_log->initFromJobAd( job_ad, false );
 	if( ! ret ) {
 		job_ad->Assign( ATTR_HOLD_REASON, "Failed to initialize user log");
-		job_ad->Assign( ATTR_HOLD_REASON_CODE, CONDOR_HOLD_CODE_UnableToInitUserLog );
+		job_ad->Assign( ATTR_HOLD_REASON_CODE, CONDOR_HOLD_CODE::UnableToInitUserLog );
 		job_ad->Assign( ATTR_HOLD_REASON_SUBCODE, 0 );
 		job_updater->updateJob(U_HOLD);
 		Starter->StarterExit(JOB_SHOULD_HOLD);
diff --git a/src/condor_starter.V6.1/jic_shadow.cpp b/src/condor_starter.V6.1/jic_shadow.cpp
index 5a411b4..e7568f2 100644
--- a/src/condor_starter.V6.1/jic_shadow.cpp
+++ b/src/condor_starter.V6.1/jic_shadow.cpp
@@ -1856,7 +1856,7 @@ JICShadow::proxyExpiring()
 {
 	// we log the return value, but even if it failed we still try to clean up
 	// because we are about to lose control of the job otherwise.
-	holdJob("Proxy about to expire", CONDOR_HOLD_CODE_CorruptedCredential, 0);
+	holdJob("Proxy about to expire", CONDOR_HOLD_CODE::CorruptedCredential, 0);
 
 	// this will actually clean up the job
 	if ( Starter->Hold( ) ) {
diff --git a/src/condor_starter.V6.1/os_proc.cpp b/src/condor_starter.V6.1/os_proc.cpp
index 7f7fe68..42416fc 100644
--- a/src/condor_starter.V6.1/os_proc.cpp
+++ b/src/condor_starter.V6.1/os_proc.cpp
@@ -529,7 +529,7 @@ OsProc::StartJob(FamilyInfo* family_info, FilesystemRemap* fs_remap=NULL)
 				starterErrorMessage += singErrorMessage;
 				Starter->jic->notifyStarterError( starterErrorMessage.c_str(),
 			    	                              	true,
-			        	                          CONDOR_HOLD_CODE_SingularityTestFailed,
+			        	                          CONDOR_HOLD_CODE::SingularityTestFailed,
 			            	                      0);
 				return 0;
 			}
@@ -744,7 +744,7 @@ OsProc::StartJob(FamilyInfo* family_info, FilesystemRemap* fs_remap=NULL)
 			if( !ThisProcRunsAlongsideMainProc() ) {
 				Starter->jic->notifyStarterError( err_msg.c_str(),
 			    	                              true,
-			        	                          CONDOR_HOLD_CODE_FailedToCreateProcess,
+			        	                          CONDOR_HOLD_CODE::FailedToCreateProcess,
 			            	                      create_process_errno );
 			}
 		}
diff --git a/src/condor_starter.V6.1/remote_proc.cpp b/src/condor_starter.V6.1/remote_proc.cpp
index 2a8e76b..7179b23 100644
--- a/src/condor_starter.V6.1/remote_proc.cpp
+++ b/src/condor_starter.V6.1/remote_proc.cpp
@@ -143,7 +143,7 @@ bool RemoteProc::JobReaper( int pid, int status )
 				unlink(".worker_stdout");
 			}
 			message = buf;
-			Starter->jic->holdJob(message.c_str(), CONDOR_HOLD_CODE_FailedToCreateProcess, 0);
+			Starter->jic->holdJob(message.c_str(), CONDOR_HOLD_CODE::FailedToCreateProcess, 0);
 			return UserProc::JobReaper( pid, status );
 		}
 
diff --git a/src/condor_starter.V6.1/script_proc.cpp b/src/condor_starter.V6.1/script_proc.cpp
index d9e2bce..64d9a10 100644
--- a/src/condor_starter.V6.1/script_proc.cpp
+++ b/src/condor_starter.V6.1/script_proc.cpp
@@ -297,7 +297,7 @@ ScriptProc::StartJob()
 			}
 			err_msg += ": ";
 			err_msg += create_process_error;
-			Starter->jic->notifyStarterError( err_msg.c_str(), true, CONDOR_HOLD_CODE_FailedToCreateProcess, create_process_errno );
+			Starter->jic->notifyStarterError( err_msg.c_str(), true, CONDOR_HOLD_CODE::FailedToCreateProcess, create_process_errno );
 		}
 
 		EXCEPT( "Create_Process(%s,%s, ...) failed",
diff --git a/src/condor_starter.V6.1/starter.cpp b/src/condor_starter.V6.1/starter.cpp
index be826a8..50e56bd 100644
--- a/src/condor_starter.V6.1/starter.cpp
+++ b/src/condor_starter.V6.1/starter.cpp
@@ -2814,7 +2814,7 @@ Starter::Reaper(int pid, int exit_status)
 			// This kills the shadow, which should cause us to catch a
 			// SIGQUIT from the startd in short order...
 			jic->holdJob( "Pre script failed.",
-				CONDOR_HOLD_CODE_PreScriptFailed,
+				CONDOR_HOLD_CODE::PreScriptFailed,
 				0 );
 
 			// ... but we might as well do what the SIGQUIT handler does
@@ -2852,7 +2852,7 @@ Starter::Reaper(int pid, int exit_status)
 			// This kills the shadow, which should cause us to catch a
 			// SIGQUIT from the startd in short order...
 			jic->holdJob( "Post script failed.",
-				CONDOR_HOLD_CODE_PostScriptFailed,
+				CONDOR_HOLD_CODE::PostScriptFailed,
 				0 );
 
 			// ... but we might as well do what the SIGQUIT handler does
diff --git a/src/condor_starter.V6.1/tool_daemon_proc.cpp b/src/condor_starter.V6.1/tool_daemon_proc.cpp
index 505333f..721df66 100644
--- a/src/condor_starter.V6.1/tool_daemon_proc.cpp
+++ b/src/condor_starter.V6.1/tool_daemon_proc.cpp
@@ -311,7 +311,7 @@ ToolDaemonProc::StartJob()
 			std::string err_msg;
 			formatstr( err_msg, "Failed to execute '%s': %s",
 							 args_string.c_str(), create_process_error );
-			Starter->jic->notifyStarterError( err_msg.c_str(), true, CONDOR_HOLD_CODE_FailedToCreateProcess, create_process_errno );
+			Starter->jic->notifyStarterError( err_msg.c_str(), true, CONDOR_HOLD_CODE::FailedToCreateProcess, create_process_errno );
 		}
 		EXCEPT( "Create_Process(%s, ...) failed", args_string.c_str() );
 		return FALSE;
diff --git a/src/condor_starter.V6.1/user_proc.cpp b/src/condor_starter.V6.1/user_proc.cpp
index 7bf5d7d..c66deea 100644
--- a/src/condor_starter.V6.1/user_proc.cpp
+++ b/src/condor_starter.V6.1/user_proc.cpp
@@ -361,8 +361,8 @@ UserProc::getStdFile( std_file_type type,
 			std::string err_msg;
 			formatstr( err_msg, "unable to establish %s stream", phrase );
 			Starter->jic->notifyStarterError( err_msg.c_str(), true,
-			    is_output ? CONDOR_HOLD_CODE_UnableToOpenOutputStream :
-			                CONDOR_HOLD_CODE_UnableToOpenInputStream, 0 );
+			    is_output ? CONDOR_HOLD_CODE::UnableToOpenOutputStream :
+			                CONDOR_HOLD_CODE::UnableToOpenInputStream, 0 );
 			return false;
 		}
 		*out_fd = handler->GetJobPipe();
@@ -472,8 +472,8 @@ UserProc::openStdFile( std_file_type type,
 		                 errno );
 		dprintf( D_ALWAYS, "%s\n", err_msg.c_str() );
 		Starter->jic->notifyStarterError( err_msg.c_str(), true,
-		  is_output ? CONDOR_HOLD_CODE_UnableToOpenOutput :
-		              CONDOR_HOLD_CODE_UnableToOpenInput, open_errno );
+		  is_output ? CONDOR_HOLD_CODE::UnableToOpenOutput :
+		              CONDOR_HOLD_CODE::UnableToOpenInput, open_errno );
 		return -1;
 	}
 	dprintf( (filename == NULL_FILE) ? D_FULLDEBUG : D_ALWAYS,
diff --git a/src/condor_starter.V6.1/vanilla_proc.cpp b/src/condor_starter.V6.1/vanilla_proc.cpp
index 8256ea9..b1406a5 100644
--- a/src/condor_starter.V6.1/vanilla_proc.cpp
+++ b/src/condor_starter.V6.1/vanilla_proc.cpp
@@ -927,7 +927,7 @@ VanillaProc::JobReaper(int pid, int status)
 				checkpointExitBySignal ? checkpointExitSignal : checkpointExitCode,
 				WIFSIGNALED( exit_status ) ? "on signal" : "with exit code",
 				WIFSIGNALED( exit_status ) ? WTERMSIG( exit_status ) : WEXITSTATUS( exit_status ) );
-			Starter->jic->holdJob( holdMessage.c_str(), CONDOR_HOLD_CODE_FailedToCheckpoint, exit_status );
+			Starter->jic->holdJob( holdMessage.c_str(), CONDOR_HOLD_CODE::FailedToCheckpoint, exit_status );
 			Starter->Hold();
 			return true;
 		}
@@ -1142,7 +1142,7 @@ VanillaProc::outOfMemoryEvent(int /* fd */)
 	cleanupOOM();
 
 	// This ulogs the hold event and KILLS the shadow
-	Starter->jic->holdJob(ss.str().c_str(), CONDOR_HOLD_CODE_JobOutOfResources, 0);
+	Starter->jic->holdJob(ss.str().c_str(), CONDOR_HOLD_CODE::JobOutOfResources, 0);
 
 	return 0;
 }
diff --git a/src/condor_starter.V6.1/vm_proc.cpp b/src/condor_starter.V6.1/vm_proc.cpp
index 939d2ca..ef8a7f0 100644
--- a/src/condor_starter.V6.1/vm_proc.cpp
+++ b/src/condor_starter.V6.1/vm_proc.cpp
@@ -321,7 +321,7 @@ VMProc::StartJob()
 		formatstr(err_msg, "%s cannot be found in job classAd.", ATTR_JOB_CMD);
 		dprintf(D_ALWAYS, "%s\n", err_msg.c_str());
 		Starter->jic->notifyStarterError( err_msg.c_str(), true,
-				CONDOR_HOLD_CODE_FailedToCreateProcess, 0);
+				CONDOR_HOLD_CODE::FailedToCreateProcess, 0);
 		return false;
 	}
 	m_job_name = vm_job_name;
@@ -332,7 +332,7 @@ VMProc::StartJob()
 		formatstr(err_msg, "%s cannot be found in job classAd.", ATTR_JOB_VM_TYPE);
 		dprintf(D_ALWAYS, "%s\n", err_msg.c_str());
 		Starter->jic->notifyStarterError( err_msg.c_str(), true,
-				CONDOR_HOLD_CODE_FailedToCreateProcess, 0);
+				CONDOR_HOLD_CODE::FailedToCreateProcess, 0);
 		return false;
 	}
 	lower_case(vm_type_name);
@@ -643,7 +643,7 @@ VMProc::StartJob()
 				// Using i for the hold reason subcode is entirely arbitrary,
 				// but may assist in writing periodic release expressions,
 				// which I understand to be the point.
-				Starter->jic->notifyStarterError( holdReason.c_str(), true, CONDOR_HOLD_CODE_FailedToCreateProcess, i );
+				Starter->jic->notifyStarterError( holdReason.c_str(), true, CONDOR_HOLD_CODE::FailedToCreateProcess, i );
 
 				free( errorString );
 				return false;
diff --git a/src/condor_submit.V6/factory_test.cpp b/src/condor_submit.V6/factory_test.cpp
index 0c8cd9e..8ca70be 100644
--- a/src/condor_submit.V6/factory_test.cpp
+++ b/src/condor_submit.V6/factory_test.cpp
@@ -790,7 +790,7 @@ int  MaterializeNextFactoryJob(FILE* out, JobFactory * factory, int & retry_dela
 		std::string txt(factory->error_stack()->getFullText()); if (txt.empty()) { txt = ""; }
 		formatstr(msg, "failed to create ClassAd for Job %d.%d : %s", jid.cluster, jid.proc, txt.c_str());
 		dprintf(D_ALWAYS, "ERROR: %s", msg.c_str());
-		setJobFactoryPauseAndLog(factory, mmHold, CONDOR_HOLD_CODE_Unspecified, msg);
+		setJobFactoryPauseAndLog(factory, mmHold, CONDOR_HOLD_CODE::Unspecified, msg);
 		//factory->Pause(mmHold);
 		//ClusterAd->Assign(ATTR_JOB_MATERIALIZE_PAUSED, mmHold);
 		//ClusterAd->Assign(ATTR_JOB_MATERIALIZE_PAUSE_REASON, msg);
diff --git a/src/condor_utils/condor_holdcodes.h b/src/condor_utils/condor_holdcodes.h
index eff27cf..473bb5a 100644
--- a/src/condor_utils/condor_holdcodes.h
+++ b/src/condor_utils/condor_holdcodes.h
@@ -21,136 +21,158 @@
 #ifndef CONDOR_HOLDCODES_H
 #define CONDOR_HOLDCODES_H
 
+
 /* This file contains hold reason codes.
+
+   They are stored in a reflective enum class CONDOR_HOLD_CODE via enum.h 
+   (see https://tinyurl.com/yfn3auay for complete docs on Better Enums).
+   The TLDR is you can use these enums as you would expect, including conversions to ints, like so:
+       int code = CONDOR_HOLD_CODE::JobPolicy;
+       switch (code) {
+	        CONDOR_HOLD_CODE::GlobalGramError:
+            ...
+       }
+   But you can also do a bunch more than with normal enums.  For example, you can fetch 
+   the name of the enum as a string with method _to_string, and create an enum from an 
+   int with _from_integral.  A pithy example using both:
+       int reason_code = 1;   // code 1 is CONDOR_HOLD_CODE::UserRequest
+       const char *holdstr = (CONDOR_HOLD_CODE::_from_integral(reason_code))._to_string();
+       // Now holdstr = "UserRequst"
+   There is a lot more, see the docs for BetterEnums at the url above.
  */
 
-//There may still be some lingering cases that result in this
-//unspecified hold code.  Hopefully they will be eliminated soon.
-const int CONDOR_HOLD_CODE_Unspecified = 0;
+#include "enum.h" 
+BETTER_ENUM(CONDOR_HOLD_CODE, int,
 
-//User put the job on hold with condor_hold
-const int CONDOR_HOLD_CODE_UserRequest = 1;
+	//There may still be some lingering cases that result in this
+	//unspecified hold code.  Hopefully they will be eliminated soon.
+	Unspecified = 0,
 
-//Globus reported an error.  The subcode is the GRAM error number.
-const int CONDOR_HOLD_CODE_GlobusGramError = 2;
+	//User put the job on hold with condor_hold
+	UserRequest = 1,
 
-//The periodic hold expression evaluated to true
-const int CONDOR_HOLD_CODE_JobPolicy   = 3;
+	//Globus reported an error.  The subcode is the GRAM error number.
+	GlobusGramError = 2,
 
-//The credentials for the job (e.g. X509 proxy file) are invalid.
-const int CONDOR_HOLD_CODE_CorruptedCredential = 4;
+	//The periodic hold expression evaluated to true
+	JobPolicy = 3,
 
-//A job policy expression (such as PeriodicHold) evaluated to UNDEFINED.
-const int CONDOR_HOLD_CODE_JobPolicyUndefined   = 5;
+	//The credentials for the job (e.g. X509 proxy file) are invalid.
+	CorruptedCredential = 4,
 
-//The condor_starter failed to start the executable.
-//The subcode will contain the unix errno.
-const int CONDOR_HOLD_CODE_FailedToCreateProcess = 6;
+	//A job policy expression (such as PeriodicHold) evaluated to UNDEFINED.
+	JobPolicyUndefined = 5,
 
-//The standard output file for the job could not be opened.
-//The subcode will contain the unix errno.
-const int CONDOR_HOLD_CODE_UnableToOpenOutput = 7;
+	//The condor_starter failed to start the executable.
+	//The subcode will contain the unix errno.
+	FailedToCreateProcess = 6,
 
-//The standard input file for the job could not be opened.
-//The subcode will contain the unix errno.
-const int CONDOR_HOLD_CODE_UnableToOpenInput = 8;
+	//The standard output file for the job could not be opened.
+	//The subcode will contain the unix errno.
+	UnableToOpenOutput = 7,
 
-//The standard output stream for the job could not be opened.
-//The subcode will contain the unix errno.
-const int CONDOR_HOLD_CODE_UnableToOpenOutputStream = 9;
+	//The standard input file for the job could not be opened.
+	//The subcode will contain the unix errno.
+	UnableToOpenInput = 8,
 
-//The standard input stream for the job could not be opened.
-//The subcode will contain the unix errno.
-const int CONDOR_HOLD_CODE_UnableToOpenInputStream = 10;
+	//The standard output stream for the job could not be opened.
+	//The subcode will contain the unix errno.
+	UnableToOpenOutputStream = 9,
 
-//An internal Condor protocol error was encountered when transferring files.
-const int CONDOR_HOLD_CODE_InvalidTransferAck = 11;
+	//The standard input stream for the job could not be opened.
+	//The subcode will contain the unix errno.
+	UnableToOpenInputStream = 10,
 
-//The starter or shadow failed to receive or write job files.
-//The subcode will contain the unix errno.
-const int CONDOR_HOLD_CODE_DownloadFileError = 12;
+	//An internal Condor protocol error was encountered when transferring files.
+	InvalidTransferAck = 11,
 
-//The starter or shadow failed to read or send job files.
-//The subcode will contain the unix errno.
-const int CONDOR_HOLD_CODE_UploadFileError = 13;
+	//The starter or shadow failed to receive or write job files.
+	//The subcode will contain the unix errno.
+	DownloadFileError = 12,
 
-//The initial working directory of the job cannot be accessed.
-//The subcode will contain the unix errno.
-const int CONDOR_HOLD_CODE_IwdError = 14;
+	//The starter or shadow failed to read or send job files.
+	//The subcode will contain the unix errno.
+	UploadFileError = 13,
 
-//The user requested the job be submitted on hold.
-const int CONDOR_HOLD_CODE_SubmittedOnHold = 15;
+	//The initial working directory of the job cannot be accessed.
+	//The subcode will contain the unix errno.
+	IwdError = 14,
 
-//Input files are being spooled.
-const int CONDOR_HOLD_CODE_SpoolingInput = 16;
+	//The user requested the job be submitted on hold.
+	SubmittedOnHold = 15,
 
-//In the standard universe, the job and shadows versions aren't
-//compatible.
-const int CONDOR_HOLD_CODE_JobShadowMismatch = 17;
+	//Input files are being spooled.
+	SpoolingInput = 16,
 
-//An internal Condor protocol error was encountered when transferring files.
-const int CONDOR_HOLD_CODE_InvalidTransferGoAhead = 18;
+	//In the standard universe, the job and shadows versions aren't
+	//compatible.
+	JobShadowMismatch = 17,
 
-#if HAVE_JOB_HOOKS
-/**
-   HOOK_PREPARE_JOB was defined but couldn't execute or returned failure.
-   The hold subcode will be 0 if we failed to execute, the exit status
-   if it exited with a failure code, or a negative number with the signal
-   number if it was killed by a signal (e.g. -9).
-*/
-const int CONDOR_HOLD_CODE_HookPrepareJobFailure = 19;
-#endif /* HAVE_JOB_HOOKS */
+	//An internal Condor protocol error was encountered when transferring files.
+	InvalidTransferGoAhead = 18,
 
-const int CONDOR_HOLD_CODE_MissedDeferredExecutionTime = 20;
+	/**
+	   HOOK_PREPARE_JOB was defined but couldn't execute or returned failure.
+	   The hold subcode will be 0 if we failed to execute, the exit status
+	   if it exited with a failure code, or a negative number with the signal
+	   number if it was killed by a signal (e.g. -9).
+	*/
+	HookPrepareJobFailure = 19,
 
-const int CONDOR_HOLD_CODE_StartdHeldJob = 21;
+	MissedDeferredExecutionTime = 20,
 
-// There was a problem opening or otherwise initializing
-// the user log for writing.
-const int CONDOR_HOLD_CODE_UnableToInitUserLog = 22;
+	StartdHeldJob = 21,
 
-const int CONDOR_HOLD_CODE_FailedToAccessUserAccount = 23;
+	// There was a problem opening or otherwise initializing
+	// the user log for writing.
+	UnableToInitUserLog = 22,
 
-const int CONDOR_HOLD_CODE_NoCompatibleShadow = 24;
+	FailedToAccessUserAccount = 23,
 
-const int CONDOR_HOLD_CODE_InvalidCronSettings = 25;
+	NoCompatibleShadow = 24,
 
-// The SYSTEM_PERIODIC_HOLD expression put the job on hold
-const int CONDOR_HOLD_CODE_SystemPolicy = 26;
+	InvalidCronSettings = 25,
 
-const int CONDOR_HOLD_CODE_SystemPolicyUndefined = 27;
+	// The SYSTEM_PERIODIC_HOLD expression put the job on hold
+	SystemPolicy = 26,
 
-const int CONDOR_HOLD_CODE_GlexecChownSandboxToUser = 28;
+	SystemPolicyUndefined = 27,
 
-const int CONDOR_HOLD_CODE_PrivsepChownSandboxToUser = 29;
+	GlexecChownSandboxToUser = 28,
 
-const int CONDOR_HOLD_CODE_GlexecChownSandboxToCondor = 30;
+	PrivsepChownSandboxToUser = 29,
 
-const int CONDOR_HOLD_CODE_PrivsepChownSandboxToCondor = 31;
+	GlexecChownSandboxToCondor = 30,
 
-const int CONDOR_HOLD_CODE_MaxTransferInputSizeExceeded = 32;
+	PrivsepChownSandboxToCondor = 31,
 
-const int CONDOR_HOLD_CODE_MaxTransferOutputSizeExceeded = 33;
+	MaxTransferInputSizeExceeded = 32,
 
-const int CONDOR_HOLD_CODE_JobOutOfResources = 34;
+	MaxTransferOutputSizeExceeded = 33,
 
-const int CONDOR_HOLD_CODE_InvalidDockerImage = 35;
+	JobOutOfResources = 34,
 
-const int CONDOR_HOLD_CODE_FailedToCheckpoint = 36;
+	InvalidDockerImage = 35,
 
-const int CONDOR_HOLD_CODE_EC2UserError = 37;
-const int CONDOR_HOLD_CODE_EC2InternalError = 38;
-const int CONDOR_HOLD_CODE_EC2AdminError = 39;
-const int CONDOR_HOLD_CODE_EC2ConnectionProblem = 40;
-const int CONDOR_HOLD_CODE_EC2ServerError = 41;
-const int CONDOR_HOLD_CODE_EC2InstancePotentiallyLostError = 42;
+	FailedToCheckpoint = 36,
 
-const int CONDOR_HOLD_CODE_PreScriptFailed = 43;
-const int CONDOR_HOLD_CODE_PostScriptFailed = 44;
+	EC2UserError = 37,
+	EC2InternalError = 38,
+	EC2AdminError = 39,
+	EC2ConnectionProblem = 40,
+	EC2ServerError = 41,
+	EC2InstancePotentiallyLostError = 42,
+
+	PreScriptFailed = 43,
+	PostScriptFailed = 44,
+
+	// Running singularity test before a sinularity job returned non-zero
+	SingularityTestFailed = 45
+
+	// NOTE!!! If you add a new hold code here, don't forget to add a commas after all entries but the last!
+	// NOTE!!! If you add a new hold code here, don't forget to update the Appendix in the Manual for Job ClassAds!
+)
 
-// Running singularity test before a sinularity job returned non-zero
-const int CONDOR_HOLD_CODE_SingularityTestFailed = 45;
 
-// NOTE!!! If you add a new hold code here, don't forget to update the condor-wiki magic numbers page!
 
 #endif
diff --git a/src/condor_utils/email_cpp.cpp b/src/condor_utils/email_cpp.cpp
index 6aaf069..583568a 100644
--- a/src/condor_utils/email_cpp.cpp
+++ b/src/condor_utils/email_cpp.cpp
@@ -552,9 +552,9 @@ Email::shouldSend( ClassAd* ad, int exit_reason, bool is_error )
 			ad->LookupInteger( ATTR_JOB_STATUS, status );
 			ad->LookupInteger( ATTR_HOLD_REASON_CODE, code );
 			if( (status == HELD || exit_reason == JOB_SHOULD_HOLD) &&
-				code != CONDOR_HOLD_CODE_UserRequest &&
-				code != CONDOR_HOLD_CODE_JobPolicy &&
-				code != CONDOR_HOLD_CODE_SubmittedOnHold )
+				code != CONDOR_HOLD_CODE::UserRequest &&
+				code != CONDOR_HOLD_CODE::JobPolicy &&
+				code != CONDOR_HOLD_CODE::SubmittedOnHold )
 			{
 				return true;
 			}
diff --git a/src/condor_utils/file_transfer.cpp b/src/condor_utils/file_transfer.cpp
index cf3699a..db6d76d 100644
--- a/src/condor_utils/file_transfer.cpp
+++ b/src/condor_utils/file_transfer.cpp
@@ -2225,7 +2225,7 @@ FileTransfer::DoDownload( filesize_t *total_bytes, ReliSock *s)
 
 			download_success = false;
 			try_again = false;
-			hold_code = CONDOR_HOLD_CODE_DownloadFileError;
+			hold_code = CONDOR_HOLD_CODE::DownloadFileError;
 			hold_subcode = EPERM;
 
 			error_buf.formatstr_cat(
@@ -2256,7 +2256,7 @@ FileTransfer::DoDownload( filesize_t *total_bytes, ReliSock *s)
 				dprintf(D_ALWAYS,"REMAP: DoDownload: %s\n",error_buf.c_str());
 				download_success = false;
 				try_again = false;
-				hold_code = CONDOR_HOLD_CODE_DownloadFileError;
+				hold_code = CONDOR_HOLD_CODE::DownloadFileError;
 				hold_subcode = EPERM;
 
 					// In order for the wire protocol to remain in a well
@@ -2274,7 +2274,7 @@ FileTransfer::DoDownload( filesize_t *total_bytes, ReliSock *s)
 						dprintf(D_ALWAYS, "REMAP: DoDownload: %s\n",error_buf.c_str());
 						download_success = false;
 						try_again = false;
-						hold_code = CONDOR_HOLD_CODE_DownloadFileError;
+						hold_code = CONDOR_HOLD_CODE::DownloadFileError;
 						hold_subcode = EPERM;
 						fullname = NULL_FILE;
 					} else {
@@ -2304,7 +2304,7 @@ FileTransfer::DoDownload( filesize_t *total_bytes, ReliSock *s)
 				dprintf(D_ALWAYS,"DoDownload: %s\n",error_buf.Value());
 				download_success = false;
 				try_again = false;
-				hold_code = CONDOR_HOLD_CODE_DownloadFileError;
+				hold_code = CONDOR_HOLD_CODE::DownloadFileError;
 				hold_subcode = EPERM;
 
 					// In order for the wire protocol to remain in a well
@@ -2479,7 +2479,7 @@ FileTransfer::DoDownload( filesize_t *total_bytes, ReliSock *s)
 						s->my_ip_str(),fullname.c_str());
 					download_success = false;
 					try_again = false;
-					hold_code = CONDOR_HOLD_CODE_DownloadFileError;
+					hold_code = CONDOR_HOLD_CODE::DownloadFileError;
 					hold_subcode = rt_result;
 
 					dprintf(D_ALWAYS,
@@ -2644,7 +2644,7 @@ FileTransfer::DoDownload( filesize_t *total_bytes, ReliSock *s)
 								if (!htcondor::generate_presigned_url(jobAd, url_value, "PUT", signed_url, err)) {
 								    std::string errorMessage;
 								    formatstr( errorMessage, "DoDownload: Failure when signing URL '%s': %s", url_value.c_str(), err.message() );
-								    result_ad.Assign( ATTR_HOLD_REASON_CODE, CONDOR_HOLD_CODE_DownloadFileError );
+								    result_ad.Assign( ATTR_HOLD_REASON_CODE, CONDOR_HOLD_CODE::DownloadFileError );
 								    result_ad.Assign( ATTR_HOLD_REASON_SUBCODE, err.code() );
 								    result_ad.Assign( ATTR_HOLD_REASON, errorMessage.c_str() );
 								    dprintf( D_ALWAYS, "%s\n", errorMessage.c_str() );
@@ -2837,7 +2837,7 @@ FileTransfer::DoDownload( filesize_t *total_bytes, ReliSock *s)
 						strerror(the_error),the_error);
 					download_success = false;
 					try_again = false;
-					hold_code = CONDOR_HOLD_CODE_DownloadFileError;
+					hold_code = CONDOR_HOLD_CODE::DownloadFileError;
 					hold_subcode = the_error;
 
 					dprintf(D_ALWAYS,
@@ -2897,7 +2897,7 @@ FileTransfer::DoDownload( filesize_t *total_bytes, ReliSock *s)
 				// be periodically released from hold.
 
 				try_again = false;
-				hold_code = CONDOR_HOLD_CODE_DownloadFileError;
+				hold_code = CONDOR_HOLD_CODE::DownloadFileError;
 				hold_subcode = the_error;
 
 				dprintf(D_ALWAYS,
@@ -2911,14 +2911,14 @@ FileTransfer::DoDownload( filesize_t *total_bytes, ReliSock *s)
 				// well defined in this case, so we can't report a specific
 				// error message.
 				try_again = true;
-				hold_code = CONDOR_HOLD_CODE_DownloadFileError;
+				hold_code = CONDOR_HOLD_CODE::DownloadFileError;
 				hold_subcode = the_error;
 
 				if( rc == GET_FILE_MAX_BYTES_EXCEEDED ) {
 					try_again = false;
 					error_buf.formatstr_cat(": max total download bytes exceeded (max=%ld MB)",
 											(long int)(MaxDownloadBytes/1024/1024));
-					hold_code = CONDOR_HOLD_CODE_MaxTransferOutputSizeExceeded;
+					hold_code = CONDOR_HOLD_CODE::MaxTransferOutputSizeExceeded;
 					hold_subcode = 0;
 				}
 
@@ -3023,7 +3023,7 @@ FileTransfer::DoDownload( filesize_t *total_bytes, ReliSock *s)
 				dprintf( D_ALWAYS, "FILETRANSFER: Multiple file download failed: %s\n",
 					errstack.getFullText().c_str() );
 				download_success = false;
-				hold_code = CONDOR_HOLD_CODE_DownloadFileError;
+				hold_code = CONDOR_HOLD_CODE::DownloadFileError;
 				hold_subcode = rc;
 				try_again = false;
 				error_buf.formatstr( "%s", errstack.getFullText().c_str() );
@@ -3160,7 +3160,7 @@ FileTransfer::GetTransferAck(Stream *s,bool &success,bool &try_again,int &hold_c
 		dprintf(D_ALWAYS,"Download acknowledgment missing attribute: %s.  Full classad: [\n%s]\n",ATTR_RESULT,ad_str.c_str());
 		success = false;
 		try_again = false;
-		hold_code = CONDOR_HOLD_CODE_InvalidTransferAck;
+		hold_code = CONDOR_HOLD_CODE::InvalidTransferAck;
 		hold_subcode = 0;
 		error_desc.formatstr("Download acknowledgment missing attribute: %s",ATTR_RESULT);
 		return;
@@ -3893,7 +3893,7 @@ FileTransfer::DoUpload(filesize_t *total_bytes, ReliSock *s)
 					/* do upload ACK (required to put job on hold) */ true,
 					/* do download ACK */ false,
 					/* try again */ false,
-					CONDOR_HOLD_CODE_UploadFileError,
+					CONDOR_HOLD_CODE::UploadFileError,
 					/* hold subcode */ 3,
 					errorMessage.c_str(), __LINE__ );
 			}
@@ -4037,7 +4037,7 @@ FileTransfer::DoUpload(filesize_t *total_bytes, ReliSock *s)
 
 		std::string holdReason;
 		if( signed_ad.LookupString( ATTR_HOLD_REASON, holdReason ) ) {
-			int holdCode = CONDOR_HOLD_CODE_DownloadFileError;
+			int holdCode = CONDOR_HOLD_CODE::DownloadFileError;
 			signed_ad.LookupInteger( ATTR_HOLD_REASON_CODE, holdCode );
 
 			int holdSubCode = -1;
@@ -4180,7 +4180,7 @@ FileTransfer::DoUpload(filesize_t *total_bytes, ReliSock *s)
 			do_upload_ack = true;    // tell receiver that we failed
 			do_download_ack = true;
 			try_again = false; // put job on hold
-			hold_code = CONDOR_HOLD_CODE_UploadFileError;
+			hold_code = CONDOR_HOLD_CODE::UploadFileError;
 			hold_subcode = EPERM;
 			return ExitDoUpload(total_bytes,numFiles, s,saved_priv,socket_default_crypto,
 			                    upload_success,do_upload_ack,do_download_ack,
@@ -4268,7 +4268,7 @@ FileTransfer::DoUpload(filesize_t *total_bytes, ReliSock *s)
 					first_failed_file_transfer_happened = true;
 					first_failed_upload_success = false;
 					first_failed_try_again = false;
-					first_failed_hold_code = CONDOR_HOLD_CODE_UploadFileError;
+					first_failed_hold_code = CONDOR_HOLD_CODE::UploadFileError;
 					first_failed_hold_subcode = 1;
 					first_failed_error_desc = error_desc;
 					first_failed_line_number = __LINE__;
@@ -4577,7 +4577,7 @@ FileTransfer::DoUpload(filesize_t *total_bytes, ReliSock *s)
 			error_desc.formatstr("error sending %s",fullname.c_str());
 			if((rc == PUT_FILE_OPEN_FAILED) || (rc == PUT_FILE_PLUGIN_FAILED) || (rc == PUT_FILE_MAX_BYTES_EXCEEDED)) {
 				try_again = false; // put job on hold
-				hold_code = CONDOR_HOLD_CODE_UploadFileError;
+				hold_code = CONDOR_HOLD_CODE::UploadFileError;
 				hold_subcode = the_error;
 
 				if (rc == PUT_FILE_OPEN_FAILED) {
@@ -4601,7 +4601,7 @@ FileTransfer::DoUpload(filesize_t *total_bytes, ReliSock *s)
 											 using_peer_max_transfer_bytes ? "download" : "upload",
 											 (long int)(effective_max_upload_bytes/1024/1024),
 											 (long int)(this_file_size/1024/1024));
-					hold_code = using_peer_max_transfer_bytes ? CONDOR_HOLD_CODE_MaxTransferOutputSizeExceeded : CONDOR_HOLD_CODE_MaxTransferInputSizeExceeded;
+					hold_code = using_peer_max_transfer_bytes ? CONDOR_HOLD_CODE::MaxTransferOutputSizeExceeded : CONDOR_HOLD_CODE::MaxTransferInputSizeExceeded;
 					the_error = 0;
 				} else {
 					// add on the error string from the errstack used
@@ -4694,7 +4694,7 @@ FileTransfer::DoUpload(filesize_t *total_bytes, ReliSock *s)
 				first_failed_file_transfer_happened = true;
 				first_failed_upload_success = false;
 				first_failed_try_again = false;
-				first_failed_hold_code = CONDOR_HOLD_CODE_UploadFileError;
+				first_failed_hold_code = CONDOR_HOLD_CODE::UploadFileError;
 				first_failed_hold_subcode = 1;
 				first_failed_error_desc = error_desc;
 				first_failed_line_number = __LINE__;
@@ -4711,7 +4711,7 @@ FileTransfer::DoUpload(filesize_t *total_bytes, ReliSock *s)
 			first_failed_file_transfer_happened = true;
 			first_failed_upload_success = false;
 			first_failed_try_again = false;
-			first_failed_hold_code = CONDOR_HOLD_CODE_UploadFileError;
+			first_failed_hold_code = CONDOR_HOLD_CODE::UploadFileError;
 			first_failed_hold_subcode = 2;
 			first_failed_error_desc = error_desc;
 			first_failed_line_number = __LINE__;
@@ -4989,7 +4989,7 @@ FileTransfer::DoReceiveTransferGoAhead(
 							   "Full classad: [\n%s]",
 							   ATTR_RESULT,msg_str.c_str());
 			try_again = false;
-			hold_code = CONDOR_HOLD_CODE_InvalidTransferGoAhead;
+			hold_code = CONDOR_HOLD_CODE::InvalidTransferGoAhead;
 			hold_subcode = 1;
 			return false;
 		}
diff --git a/src/condor_utils/submit_utils.cpp b/src/condor_utils/submit_utils.cpp
index 8131f7b..3130645 100644
--- a/src/condor_utils/submit_utils.cpp
+++ b/src/condor_utils/submit_utils.cpp
@@ -2064,17 +2064,17 @@ int SubmitHash::SetJobStatus()
 			ABORT_AND_RETURN( 1 );
 		}
 		AssignJobVal(ATTR_JOB_STATUS, HELD);
-		AssignJobVal(ATTR_HOLD_REASON_CODE, CONDOR_HOLD_CODE_SubmittedOnHold);
+		AssignJobVal(ATTR_HOLD_REASON_CODE, CONDOR_HOLD_CODE::SubmittedOnHold);
 		SubmitOnHold = true;
-		SubmitOnHoldCode = CONDOR_HOLD_CODE_SubmittedOnHold;
+		SubmitOnHoldCode = CONDOR_HOLD_CODE::SubmittedOnHold;
 
 		AssignJobString(ATTR_HOLD_REASON, "submitted on hold at user's request");
 	} else 
 	if ( IsRemoteJob ) {
 		AssignJobVal(ATTR_JOB_STATUS, HELD);
-		AssignJobVal(ATTR_HOLD_REASON_CODE, CONDOR_HOLD_CODE_SpoolingInput);
+		AssignJobVal(ATTR_HOLD_REASON_CODE, CONDOR_HOLD_CODE::SpoolingInput);
 		SubmitOnHold = true;
-		SubmitOnHoldCode = CONDOR_HOLD_CODE_SpoolingInput;
+		SubmitOnHoldCode = CONDOR_HOLD_CODE::SpoolingInput;
 
 		AssignJobString(ATTR_HOLD_REASON, "Spooling input data files");
 	} else {
diff --git a/src/condor_utils/user_job_policy.cpp b/src/condor_utils/user_job_policy.cpp
index 14f34d7..ffdfda2 100644
--- a/src/condor_utils/user_job_policy.cpp
+++ b/src/condor_utils/user_job_policy.cpp
@@ -931,9 +931,9 @@ bool UserPolicy::FiringReason(MyString &reason,int &reason_code,int &reason_subc
 #ifdef USE_NON_MUTATING_USERPOLICY
 			exprString = m_fire_unparsed_expr.c_str();
 			if (m_fire_expr_val == -1) {
-				reason_code = CONDOR_HOLD_CODE_JobPolicyUndefined;
+				reason_code = CONDOR_HOLD_CODE::JobPolicyUndefined;
 			} else {
-				reason_code = CONDOR_HOLD_CODE_JobPolicy;
+				reason_code = CONDOR_HOLD_CODE::JobPolicy;
 				reason_subcode = m_fire_subcode;
 				reason = m_fire_reason;
 			}
@@ -963,10 +963,10 @@ bool UserPolicy::FiringReason(MyString &reason,int &reason_code,int &reason_subc
 #ifdef USE_NON_MUTATING_USERPOLICY
 			exprString = m_fire_unparsed_expr.c_str();
 			if( m_fire_expr_val == -1 ) {
-				reason_code = CONDOR_HOLD_CODE_SystemPolicyUndefined;
+				reason_code = CONDOR_HOLD_CODE::SystemPolicyUndefined;
 			}
 			else {
-				reason_code = CONDOR_HOLD_CODE_SystemPolicy;
+				reason_code = CONDOR_HOLD_CODE::SystemPolicy;
 				reason_subcode = m_fire_subcode;
 				reason = m_fire_reason;
 			}
diff --git a/src/python-bindings/schedd.cpp b/src/python-bindings/schedd.cpp
index de24a49..a68ab94 100644
--- a/src/python-bindings/schedd.cpp
+++ b/src/python-bindings/schedd.cpp
@@ -149,7 +149,7 @@ make_spool(classad::ClassAd& ad)
         THROW_EX(HTCondorInternalError, "Unable to set job to hold.");
     if (!ad.InsertAttr(ATTR_HOLD_REASON, "Spooling input data files"))
         THROW_EX(HTCondorInternalError, "Unable to set job hold reason.")
-    if (!ad.InsertAttr(ATTR_HOLD_REASON_CODE, CONDOR_HOLD_CODE_SpoolingInput))
+    if (!ad.InsertAttr(ATTR_HOLD_REASON_CODE, CONDOR_HOLD_CODE::SpoolingInput))
         THROW_EX(HTCondorInternalError, "Unable to set job hold code.")
     std::stringstream ss;
     ss << ATTR_JOB_STATUS << " == " << COMPLETED << " && ( ";
