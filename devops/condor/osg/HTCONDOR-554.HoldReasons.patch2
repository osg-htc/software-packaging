diff --git a/src/condor_schedd.V6/qmgmt.cpp b/src/condor_schedd.V6/qmgmt.cpp
index 2de6fdf..c44e5a4 100644
--- a/src/condor_schedd.V6/qmgmt.cpp
+++ b/src/condor_schedd.V6/qmgmt.cpp
@@ -4546,10 +4546,26 @@ SetAttribute(int cluster_id, int proc_id, const char *attr_name,
 		// if the hold reason is set to one of the magic values that indicate a hold for spooling
 		// data, we want to attach a trigger to the transaction so we know to do filepath fixups
 		// after the transaction is committed.
+		// if the hold reason code is NOT spooling for data, then we want to update aggregates
+		// on the number of holds and number of holds per reason.
 		bool is_spooling_hold = false;
 		if (attr_id == idATTR_HOLD_REASON_CODE) {
 			int hold_reason = (int)strtol( attr_value, NULL, 10 );
 			is_spooling_hold = (CONDOR_HOLD_CODE::SpoolingInput == hold_reason);
+			if (!is_spooling_hold) {
+				// Update count in job ad of how many times job was put on hold
+				incrementJobAdAttr(cluster_id, proc_id, ATTR_NUM_HOLDS);
+
+				// Update count per hold reason in the job ad.
+				// If the reason_code int is not a valid CONDOR_HOLD_CODE enum, an exception will be thrown.
+				try {
+					incrementJobAdAttr(cluster_id, proc_id, (CONDOR_HOLD_CODE::_from_integral(hold_reason))._to_string(), ATTR_NUM_HOLDS_BY_REASON);
+				}
+				catch (std::runtime_error const&) {
+					// Somehow reason_code is not a valid hold reason, so consider it as Unspecified here.
+					incrementJobAdAttr(cluster_id, proc_id, (+CONDOR_HOLD_CODE::Unspecified)._to_string(), ATTR_NUM_HOLDS_BY_REASON);
+				}
+			}
 		} else if (attr_id == idATTR_HOLD_REASON) {
 			is_spooling_hold = YourString("Spooling input data files") == attr_value;
 		}
diff --git a/src/condor_schedd.V6/schedd.cpp b/src/condor_schedd.V6/schedd.cpp
index 0d628a2..4ebd2f4 100644
--- a/src/condor_schedd.V6/schedd.cpp
+++ b/src/condor_schedd.V6/schedd.cpp
@@ -15773,8 +15773,8 @@ abortJobsByConstraint( const char *constraint,
 	return result;
 }
 
-static void
-incrementJobAdAttr(int cluster, int proc, const char* attrName, const char *nestedAdAttrName = nullptr)
+void
+incrementJobAdAttr(int cluster, int proc, const char* attrName, const char *nestedAdAttrName)
 {
 	int val = 0;
 	if (!attrName || !attrName[0]) return;
@@ -15782,6 +15782,9 @@ incrementJobAdAttr(int cluster, int proc, const char* attrName, const char *nest
 		// Here we are going to increment an attribute in an ad nested inside the job ad.
 
 		// First, get the nested ad as a string, and parse to a classad
+		// This nested ad just has attrname=integer attributes - since it
+		// will not contain any string values we do not need to worry about
+		// setting up the parser for old vs new quoting rules.
 		classad::ClassAdParser parser;
 		char *adAsString = nullptr;
 		ClassAd ad;
@@ -15891,19 +15894,6 @@ holdJobRaw( int cluster, int proc, const char* reason,
 				 ATTR_LAST_SUSPENSION_TIME, cluster, proc );
 	}
 
-	// Update count in job ad of how many times job was put on hold
-	incrementJobAdAttr(cluster, proc, ATTR_NUM_HOLDS);
-
-	// Update count per hold reason in the job ad.
-	// If the reason_code int is not a valid CONDOR_HOLD_CODE enum, an exception will be thrown.
-	try {
-		incrementJobAdAttr(cluster, proc, (CONDOR_HOLD_CODE::_from_integral(reason_code))._to_string(), ATTR_NUM_HOLDS_BY_REASON);
-	}
-	catch (std::runtime_error) {
-		// Somehow reason_code is not a valid hold reason, so consider it as Unspecified here.
-		incrementJobAdAttr(cluster, proc, (+CONDOR_HOLD_CODE::Unspecified)._to_string(), ATTR_NUM_HOLDS_BY_REASON);
-	}
-
 	// Update count in job ad of "system holds", whatever that is supposed to mean
 	// (this is a legacy attribute from way back when, keep it the same as it was for now)
 	if ( system_hold ) {
diff --git a/src/condor_schedd.V6/scheduler.h b/src/condor_schedd.V6/scheduler.h
index 4330aa0..be090c3 100644
--- a/src/condor_schedd.V6/scheduler.h
+++ b/src/condor_schedd.V6/scheduler.h
@@ -1156,6 +1156,7 @@ extern bool moveIntAttr( PROC_ID job_id, const char* old_attr,
 						 const char* new_attr, bool verbose );
 extern bool abortJob( int cluster, int proc, const char *reason, bool use_transaction );
 extern bool abortJobsByConstraint( const char *constraint, const char *reason, bool use_transaction );
+extern void incrementJobAdAttr(int cluster, int proc, const char* attrName, const char *nestedAdAttrName = nullptr);
 extern bool holdJob( int cluster, int proc, const char* reason = NULL, 
 					 int reason_code=0, int reason_subcode=0,
 					 bool use_transaction = false, 
